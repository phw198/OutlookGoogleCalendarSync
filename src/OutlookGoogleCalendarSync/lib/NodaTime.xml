<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NodaTime</name>
    </assembly>
    <members>
        <member name="T:NodaTime.AmbiguousTimeException">
            <summary>
            Exception thrown to indicate that the specified local date/time occurs twice
            in a particular time zone due to daylight saving time changes.
            </summary>
            <remarks>
            <para>
            This occurs for transitions where the clock goes backward (usually by
            an hour). For example, suppose the time zone goes backward
            at 2am, so the second after 01:59:59 becomes 01:00:00. In that case,
            times such as 01:30:00 occur twice.
            </para>
            <para>
            This exception is used to indicate such problems, as they're usually
            not the same as other <see cref="T:System.ArgumentOutOfRangeException" /> causes,
            such as entering "15" for a month number.
            </para>
            <para>
            In theory this isn't calendar-specific; the local value will be ambiguous in
            this time zone regardless of the calendar used. However, this exception is
            always created in conjunction with a specific calendar, which leads to a more
            natural way of examining its information and constructing an error message.
            </para>
            </remarks>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="P:NodaTime.AmbiguousTimeException.LocalDateTime">
            <summary>
            Get the local date and time which is ambiguous in the time zone.
            </summary>
            <value>The local date and time which is ambiguous in the time zone.</value>
        </member>
        <member name="P:NodaTime.AmbiguousTimeException.Zone">
            <summary>
            The time zone in which the local date and time is ambiguous.
            </summary>
            <value>The time zone in which the local date and time is ambiguous.</value>
        </member>
        <member name="P:NodaTime.AmbiguousTimeException.EarlierMapping">
            <summary>
            Gets the earlier of the two occurrences of the local date and time within the time zone.
            </summary>
            <value>The earlier of the two occurrences of the local date and time within the time zone.</value>
        </member>
        <member name="P:NodaTime.AmbiguousTimeException.LaterMapping">
            <summary>
            Gets the later of the two occurrences of the local date and time within the time zone.
            </summary>
            <value>The later of the two occurrences of the local date and time within the time zone.</value>
        </member>
        <member name="M:NodaTime.AmbiguousTimeException.#ctor(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Constructs an instance from the given information.
            </summary>
            <remarks>
            <para>
            User code is unlikely to need to deliberately call this constructor except
            possibly for testing.
            </para>
            <para>
            The two mappings must have the same local time and time zone.
            </para>
            </remarks>
            <param name="earlierMapping">The earlier possible mapping</param>
            <param name="laterMapping">The later possible mapping</param>
        </member>
        <member name="T:NodaTime.Annotations.ImmutableAttribute">
            <summary>
            Indicates that a type is immutable. After construction, the publicly visible
            state of the object will not change.
            </summary>
            <remarks>
            <p>
            This attribute only applies to types, not fields:
            it's entirely feasible to have a readonly field of a mutable type, or a read/write
            field of an immutable type. In such cases for reference types (classes and interfaces)
            it's important to distinguish between the value of the variable (a reference) and the
            object it refers to. Value types are more complicated as in some cases the compiler
            will copy values before operating on them; however as all value types in Noda Time are
            immutable (aside from explicitly implemented serialization operations) this rarely causes
            an issue.
            </p>
            <p>
            Some types may be publicly immutable, but contain privately mutable
            aspects, e.g. caches. If it proves to be useful to indicate the kind of
            immutability we're implementing, we can add an appropriate property to this
            attribute.
            </p>
            </remarks>
        </member>
        <member name="T:NodaTime.Annotations.MutableAttribute">
            <summary>
            Indicates that a type is mutable. Some members of this type
            allow state to be visibly changed.
            </summary>
        </member>
        <member name="T:NodaTime.Annotations.SpecialNullHandlingAttribute">
            <summary>
            Indicates that the parameter doesn't conform to simple NotNull/CanBeNull
            behaviour, e.g. for IPattern{T}.Parse, where the parameter shouldn't be null,
            but the result will be a failed ParseResult rather than an ArgumentNullException.
            </summary>
        </member>
        <member name="T:NodaTime.Annotations.TestExemptionAttribute">
            <summary>
            Attribute to effectively ignore a particular kind of test, because it's known
            not to apply to this member. The optional message isn't stored, because we never
            need it - it's for documentation purposes.
            </summary>
        </member>
        <member name="T:NodaTime.Annotations.TrustedAttribute">
            <summary>
            Indicates that a parameter is trusted to be valid, so callers must take care
            to only pass valid values.
            </summary>
            <remarks>
            <para>This attribute should never be applied to parameters in public members, as
            all public members should validate their parameters. The exception here is
            public members within internal types, as those aren't really exposed publicly.</para>
            <para>Parameters decorated with this attribute should typically be validated in
            debug configurations, using <see cref="M:NodaTime.Utility.Preconditions.DebugCheckArgumentRange(System.String,System.Int32,System.Int32,System.Int32)"/>
            or a similar method.</para>
            </remarks>
        </member>
        <member name="T:NodaTime.Annotations.VisibleForTestingAttribute">
            <summary>
            Attribute indicating that a particular member would normally be private (or potentially protected)
            but is exposed for test purposes.
            </summary>
            <remarks>
            Currently this excludes field and events - but it could be expanded to do so. Likewise
            we don't indicate the intended access mode, which could be done via an enum. For the moment we'll
            assume everything would be private apart from for testing.
            </remarks>
        </member>
        <member name="T:NodaTime.AnnualDate">
            <summary>
            Represents an annual date (month and day) in the ISO calendar but without a specific year,
            typically for recurrent events such as birthdays, anniversaries, and deadlines.
            </summary>
            <remarks>
            <para>
            Equality and comparison order are defined in the natural way. Two values are equal if they
            represent the same month and the same day-of-month. One value is earlier than another if it
            has a smaller month, or the same month but an earlier day-of-month.
            </para>
            <para>
            In the future, this struct may be expanded to support other calendar systems,
            but this does not generalize terribly cleanly, particularly to the Hebrew calendar system
            with its leap month.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.AnnualDate.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an instance for the given month and day in the ISO calendar.
            </summary>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.
            (February 29th is considered valid.)</exception>
        </member>
        <member name="P:NodaTime.AnnualDate.Month">
            <summary>
            Gets the month of year.
            </summary>
            <value>The month of year.</value>
        </member>
        <member name="P:NodaTime.AnnualDate.Day">
            <summary>
            Gets the day of month.
            </summary>
            <value>The day of month.</value>
        </member>
        <member name="M:NodaTime.AnnualDate.InYear(System.Int32)">
            <summary>
            Returns this annual date in a particular year, as a <see cref="T:NodaTime.LocalDate"/>.
            </summary>
            <remarks>
            <para>
            If this value represents February 29th, and the specified year is not a leap
            year, the returned value will be February 28th of that year. To see whether the
            original month and day is valid without truncation in a particular year,
            use <see cref="M:NodaTime.AnnualDate.IsValidYear(System.Int32)"/>
            </para>
            </remarks>
            <param name="year">The year component of the required date.</param>
            <returns>A date in the given year, suitable for this annual date.</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.IsValidYear(System.Int32)">
            <summary>
            Checks whether the specified year forms a valid date with the month/day in this
            value, without any truncation. This will always return <c>true</c> except
            for values representing February 29th, where the specified year is a non leap year.
            </summary>
            <param name="year">The year to test for validity</param>
            <returns><c>true</c> if the current value occurs within the given year;
            <c>false</c> otherwise.</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.Equals(System.Object)">
            <summary>
            Compares this annual date with the specified reference.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The object to compare this one with</param>
            <returns>True if the specified value is an annual date which is equal to this one; false otherwise</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.GetHashCode">
            <summary>
            Returns a hash code for this annual date.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>A hash code for this annual date.</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("G").
            </returns>
        </member>
        <member name="M:NodaTime.AnnualDate.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("G").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.AnnualDate.Equals(NodaTime.AnnualDate)">
            <summary>
            Compares this annual date with the specified one for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">The other annual date to compare this one with</param>
            <returns>True if the specified annual date is equal to this one; false otherwise</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.CompareTo(NodaTime.AnnualDate)">
            <summary>
            Indicates whether this annual date is earlier, later or the same as another one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="other">The other annual date to compare this one with</param>
            <returns>A value less than zero if this annual date is earlier than <paramref name="other"/>;
            zero if this time is the same as <paramref name="other"/>; a value greater than zero if this annual date is
            later than <paramref name="other"/>.</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two AnnualDates.
            See the type documentation for a description of ordering semantics.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.AnnualDate"/></exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this AnnualDate with another one.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.AnnualDate.op_Equality(NodaTime.AnnualDate,NodaTime.AnnualDate)">
            <summary>
            Compares two <see cref="T:NodaTime.AnnualDate" /> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>True if the two dates are the same; false otherwise</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.op_Inequality(NodaTime.AnnualDate,NodaTime.AnnualDate)">
            <summary>
            Compares two <see cref="T:NodaTime.AnnualDate" /> values for inequality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>False if the two dates are the same and in the same calendar; true otherwise</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.op_LessThan(NodaTime.AnnualDate,NodaTime.AnnualDate)">
            <summary>
            Compares two annual dates to see if the left one is strictly earlier than the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is strictly earlier than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.op_LessThanOrEqual(NodaTime.AnnualDate,NodaTime.AnnualDate)">
            <summary>
            Compares two annual dates to see if the left one is earlier than or equal to the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is earlier than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.op_GreaterThan(NodaTime.AnnualDate,NodaTime.AnnualDate)">
            <summary>
            Compares two annual dates to see if the left one is strictly later than the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is strictly later than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.op_GreaterThanOrEqual(NodaTime.AnnualDate,NodaTime.AnnualDate)">
            <summary>
            Compares two annual dates to see if the left one is later than or equal to the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is later than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.AnnualDate"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.AnnualDate.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.AnnualDate.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.AnnualDate.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.Properties.AssemblyInfo">
            <summary>
            Just a static class to house the public key, which allows us to avoid repeating it all over the place.
            </summary>
        </member>
        <member name="T:NodaTime.CalendarOrdinal">
            <summary>
            Enumeration of calendar ordinal values. Used for converting between a compact integer representation and a calendar system.
            We use 6 bits to store the calendar ordinal in YearMonthDayCalendar, so we can have up to 64 calendars.
            </summary>
        </member>
        <member name="T:NodaTime.CalendarSystem">
            <summary>
            A calendar system maps the non-calendar-specific "local time line" to human concepts
            such as years, months and days.
            </summary>
            <remarks>
            <para>
            Many developers will never need to touch this class, other than to potentially ask a calendar
            how many days are in a particular year/month and the like. Noda Time defaults to using the ISO-8601
            calendar anywhere that a calendar system is required but hasn't been explicitly specified.
            </para>
            <para>
            If you need to obtain a <see cref="T:NodaTime.CalendarSystem" /> instance, use one of the static properties or methods in this
            class, such as the <see cref="P:NodaTime.CalendarSystem.Iso" /> property or the <see cref="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)" /> method.
            </para>
            <para>Although this class is currently sealed (as of Noda Time 1.2), in the future this decision may
            be reversed. In any case, there is no current intention for third-party developers to be able to implement
            their own calendar systems (for various reasons). If you require a calendar system which is not
            currently supported, please file a feature request and we'll see what we can do.
            </para>
            </remarks>
            <threadsafety>
            All calendar implementations are immutable and thread-safe. See the thread safety
            section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.CalendarSystem.ForId(System.String)">
            <summary>
            Fetches a calendar system by its unique identifier. This provides full round-tripping of a calendar
            system. This method will always return the same reference for the same ID.
            </summary>
            <param name="id">The ID of the calendar system. This is case-sensitive.</param>
            <returns>The calendar system with the given ID.</returns>
            <seealso cref="P:NodaTime.CalendarSystem.Id"/>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">No calendar system for the specified ID can be found.</exception>
            <exception cref="T:System.NotSupportedException">The calendar system with the specified ID is known, but not supported on this platform.</exception>
        </member>
        <member name="M:NodaTime.CalendarSystem.ForOrdinal(NodaTime.CalendarOrdinal)">
            <summary>
            Fetches a calendar system by its ordinal value, constructing it if necessary.
            </summary>
        </member>
        <member name="P:NodaTime.CalendarSystem.Ids">
            <summary>
            Returns the IDs of all calendar systems available within Noda Time. The order of the keys is not guaranteed.
            </summary>
            <value>The IDs of all calendar systems available within Noda Time.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.Iso">
            <summary>
            Returns a calendar system that follows the rules of the ISO-8601 standard,
            which is compatible with Gregorian for all modern dates.
            </summary>
            <remarks>
            As of Noda Time 2.0, this calendar system is equivalent to <see cref="P:NodaTime.CalendarSystem.Gregorian"/>.
            The only areas in which the calendars differed were around centuries, and the members
            relating to those differences were removed in Noda Time 2.0.
            The distinction between Gregorian and ISO has been maintained for the sake of simplicity, compatibility
            and consistency.
            </remarks>
            <value>The ISO calendar system.</value>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)">
            <summary>
            Returns a Hebrew calendar, as described at https://en.wikipedia.org/wiki/Hebrew_calendar. This is a
            purely mathematical calculator, applied proleptically to the period where the real calendar was observational. 
            </summary>
            <remarks>
            <para>Please note that support for the Hebrew calendar is somewhat experimental,
            particularly in terms of calculations involving adding or subtracting years. Additionally, text formatting
            and parsing using month names is not currently supported, due to the challenges of handling leap months.
            It is hoped that this will be improved in future versions.</para>
            <para>The implementation for this was taken from https://www.cs.tau.ac.il/~nachum/calendar-book/papers/calendar.ps,
            which is a public domain algorithm presumably equivalent to that given in the Calendrical Calculations book
            by the same authors (Nachum Dershowitz and Edward Reingold).
            </para>
            </remarks>
            <param name="monthNumbering">The month numbering system to use</param>
            <returns>A Hebrew calendar system for the given month numbering.</returns>
        </member>
        <member name="P:NodaTime.CalendarSystem.Badi">
            <summary>
            Returns the Badíʿ (meaning "wondrous" or "unique") calendar, as described at https://en.wikipedia.org/wiki/Badi_calendar. 
            This is a purely solar calendar with years starting at the vernal equinox.
            </summary>
            <remarks>
            <para>The Badíʿ calendar was developed and defined by the founders of the Bahá'í Faith in the mid to late
            1800's A.D. The first year in the calendar coincides with 1844 A.D. Years are labeled "B.E." for Bahá'í Era.</para>
            <para>A year consists of 19 months, each with 19 days. Each day starts at sunset. Years are grouped into sets
            of 19 "Unities" (Váḥid) and 19 Unities make up 1 "All Things" (Kull-i-Shay’).</para>
            <para>A period of days (usually 4 or 5, called Ayyám-i-Há) occurs between the 18th and 19th months. The length of this 
            period of intercalary days is solely determined by the date of the following vernal equinox. The vernal equinox is 
            a momentary point in time, so the "date" of the equinox is determined by the date (beginning 
            at sunset) in effect in Tehran, Iran at the moment of the equinox.</para>
            <para>In this Noda Time implementation, days start at midnight and lookup tables are used to determine vernal equinox dates.
            Ayyám-i-Há is internally modelled as extra days added to the 18th month. As a result, a few functions will
            not work as expected for Ayyám-i-Há, such as EndOfMonth.</para>
            </remarks>
            <returns>The Badíʿ calendar system.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)">
            <summary>
            Returns an Islamic, or Hijri, calendar system.
            </summary>
            <remarks>
            <para>
            This returns a tabular calendar, rather than one based on lunar observation. This calendar is a
            lunar calendar with 12 months, each of 29 or 30 days, resulting in a year of 354 days (or 355 on a leap
            year).
            </para>
            <para>
            Year 1 in the Islamic calendar began on July 15th or 16th, 622 CE (Julian), thus
            Islamic years do not begin at the same time as Julian years. This calendar
            is not proleptic, as it does not allow dates before the first Islamic year.
            </para>
            <para>
            There are two basic forms of the Islamic calendar, the tabular and the
            observed. The observed form cannot easily be used by computers as it
            relies on human observation of the new moon. The tabular calendar, implemented here, is an
            arithmetic approximation of the observed form that follows relatively simple rules.
            </para>
            <para>You should choose an epoch based on which external system you wish
            to be compatible with. The epoch beginning on July 16th is the more common
            one for the tabular calendar, so using <see cref="F:NodaTime.Calendars.IslamicEpoch.Civil" />
            would usually be a logical choice. However, Windows uses July 15th, so
            if you need to be compatible with other Windows systems, you may wish to use
            <see cref="F:NodaTime.Calendars.IslamicEpoch.Astronomical" />. The fact that the Islamic calendar
            traditionally starts at dusk, a Julian day traditionally starts at noon,
            and all calendar systems in Noda Time start their days at midnight adds
            somewhat inevitable confusion to the mix, unfortunately.</para>
            <para>
            The tabular form of the calendar defines 12 months of alternately
            30 and 29 days. The last month is extended to 30 days in a leap year.
            Leap years occur according to a 30 year cycle. There are four recognised
            patterns of leap years in the 30 year cycle:
            </para>
            <list type="table">
               <listheader><term>Origin</term><description>Leap years</description></listheader>
               <item><term>Kūshyār ibn Labbān</term><description>2, 5, 7, 10, 13, 15, 18, 21, 24, 26, 29</description></item>
               <item><term>al-Fazārī</term><description>2, 5, 7, 10, 13, 16, 18, 21, 24, 26, 29</description></item>
               <item><term>Fātimid (also known as Misri or Bohra)</term><description>2, 5, 8, 10, 13, 16, 19, 21, 24, 27, 29</description></item>
               <item><term>Habash al-Hasib</term><description>2, 5, 8, 11, 13, 16, 19, 21, 24, 27, 30</description></item>
            </list>
            <para>
            The leap year pattern to use is determined from the first parameter to this factory method.
            The second parameter determines which epoch is used - the "astronomical" or "Thursday" epoch
            (July 15th 622CE) or the "civil" or "Friday" epoch (July 16th 622CE).
            </para>
            <para>
            This implementation defines a day as midnight to midnight exactly as per
            the ISO calendar. This correct start of day is at sunset on the previous
            day, however this cannot readily be modelled and has been ignored.
            </para>
            </remarks>
            <param name="leapYearPattern">The pattern of years in the 30-year cycle to consider as leap years</param>
            <param name="epoch">The kind of epoch to use (astronomical or civil)</param>
            <returns>A suitable Islamic calendar reference; the same reference may be returned by several
            calls as the object is immutable and thread-safe.</returns>
        </member>
        <member name="P:NodaTime.CalendarSystem.Id">
            <summary>
            Returns the unique identifier for this calendar system. This is provides full round-trip capability
            using <see cref="M:NodaTime.CalendarSystem.ForId(System.String)" /> to retrieve the calendar system from the identifier.
            </summary>
            <remarks>
            <para>
            A unique ID for a calendar is required when serializing types which include a <see cref="T:NodaTime.CalendarSystem"/>.
            As of 2 Nov 2012 (ISO calendar) there are no ISO or RFC standards for naming a calendar system. As such,
            the identifiers provided here are specific to Noda Time, and are not guaranteed to interoperate with any other
            date and time API.
            </para>
            <list type="table">
              <listheader>
                <term>Calendar ID</term>
                <description>Equivalent factory method or property</description>
              </listheader>
              <item><term>ISO</term><description><see cref="P:NodaTime.CalendarSystem.Iso"/></description></item>
              <item><term>Gregorian</term><description><see cref="P:NodaTime.CalendarSystem.Gregorian"/></description></item>
              <item><term>Coptic</term><description><see cref="P:NodaTime.CalendarSystem.Coptic"/></description></item>
              <item><term>Badi</term><description><see cref="P:NodaTime.CalendarSystem.Badi"/></description></item>
              <item><term>Julian</term><description><see cref="P:NodaTime.CalendarSystem.Julian"/></description></item>
              <item><term>Hijri Civil-Indian</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.Indian, IslamicEpoch.Civil)</description></item>
              <item><term>Hijri Civil-Base15</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.Base15, IslamicEpoch.Civil)</description></item>
              <item><term>Hijri Civil-Base16</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.Base16, IslamicEpoch.Civil)</description></item>
              <item><term>Hijri Civil-HabashAlHasib</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.HabashAlHasib, IslamicEpoch.Civil)</description></item>
              <item><term>Hijri Astronomical-Indian</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.Indian, IslamicEpoch.Astronomical)</description></item>
              <item><term>Hijri Astronomical-Base15</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.Base15, IslamicEpoch.Astronomical)</description></item>
              <item><term>Hijri Astronomical-Base16</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.Base16, IslamicEpoch.Astronomical)</description></item>
              <item><term>Hijri Astronomical-HabashAlHasib</term><description><see cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>(IslamicLeapYearPattern.HabashAlHasib, IslamicEpoch.Astronomical)</description></item>
              <item><term>Persian Simple</term><description><see cref="P:NodaTime.CalendarSystem.PersianSimple"/></description></item>
              <item><term>Persian Arithmetic</term><description><see cref="P:NodaTime.CalendarSystem.PersianArithmetic"/></description></item>
              <item><term>Persian Algorithmic</term><description><see cref="P:NodaTime.CalendarSystem.PersianAstronomical"/> (see note)</description></item>
              <item><term>Um Al Qura</term><description><see cref="P:NodaTime.CalendarSystem.UmAlQura"/>()</description></item>
              <item><term>Hebrew Civil</term><description><see cref="P:NodaTime.CalendarSystem.HebrewCivil"/></description></item>
              <item><term>Hebrew Scriptural</term><description><see cref="P:NodaTime.CalendarSystem.HebrewScriptural"/></description></item>
            </list>
            <para>
            The ID "Persian Algorithmic" for the Persian Astronomical calendar is an unfortunate error. The ID has been incorrect
            in Noda Time for so long that "fixing" it now would cause compatibility issues between systems storing or
            exchanging Noda Time data.
            </para>
            </remarks>
            <value>The unique identifier for this calendar system.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.Name">
            <summary>
            Returns the name of this calendar system. Each kind of calendar system has a unique name, but this
            does not usually provide enough information for round-tripping. (For example, the name of an
            Islamic calendar system does not indicate which kind of leap cycle it uses.)
            </summary>
            <value>The name of this calendar system.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.MinYear">
            <summary>
            Gets the minimum valid year (inclusive) within this calendar.
            </summary>
            <value>The minimum valid year (inclusive) within this calendar.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.MaxYear">
            <summary>
            Gets the maximum valid year (inclusive) within this calendar.
            </summary>
            <value>The maximum valid year (inclusive) within this calendar.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.MinDays">
            <summary>
            Returns the minimum day number this calendar can handle.
            </summary>
        </member>
        <member name="P:NodaTime.CalendarSystem.MaxDays">
            <summary>
            Returns the maximum day number (inclusive) this calendar can handle.
            </summary>
        </member>
        <member name="P:NodaTime.CalendarSystem.Ordinal">
            <summary>
            Returns the ordinal value of this calendar.
            </summary>
        </member>
        <member name="P:NodaTime.CalendarSystem.Eras">
            <summary>
            Gets a read-only list of eras used in this calendar system.
            </summary>
            <value>A read-only list of eras used in this calendar system.</value>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetAbsoluteYear(System.Int32,NodaTime.Calendars.Era)">
            <summary>
            Returns the "absolute year" (the one used throughout most of the API, without respect to eras)
            from a year-of-era and an era.
            </summary>
            <remarks>
            For example, in the Gregorian and Julian calendar systems, the BCE era starts at year 1, which is
            equivalent to an "absolute year" of 0 (then BCE year 2 has an absolute year of -1, and so on).  The absolute
            year is the year that is used throughout the API; year-of-era is typically used primarily when formatting
            and parsing date values to and from text.
            </remarks>
            <param name="yearOfEra">The year within the era.</param>
            <param name="era">The era in which to consider the year</param>
            <returns>The absolute year represented by the specified year of era.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="yearOfEra"/> is out of the range of years for the given era.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="era"/> is not an era used in this calendar.</exception>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetMaxYearOfEra(NodaTime.Calendars.Era)">
            <summary>
            Returns the maximum valid year-of-era in the given era.
            </summary>
            <remarks>Note that depending on the calendar system, it's possible that only
            part of the returned year falls within the given era. It is also possible that
            the returned value represents the earliest year of the era rather than the latest
            year. (See the BC era in the Gregorian calendar, for example.)</remarks>
            <param name="era">The era in which to find the greatest year</param>
            <returns>The maximum valid year in the given era.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="era"/> is not an era used in this calendar.</exception>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetMinYearOfEra(NodaTime.Calendars.Era)">
            <summary>
            Returns the minimum valid year-of-era in the given era.
            </summary>
            <remarks>Note that depending on the calendar system, it's possible that only
            part of the returned year falls within the given era. It is also possible that
            the returned value represents the latest year of the era rather than the earliest
            year. (See the BC era in the Gregorian calendar, for example.)</remarks>
            <param name="era">The era in which to find the greatest year</param>
            <returns>The minimum valid year in the given era.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="era"/> is not an era used in this calendar.</exception>
        </member>
        <member name="M:NodaTime.CalendarSystem.ToString">
            <summary>
            Converts this calendar system to text by simply returning its unique ID.
            </summary>
            <returns>The ID of this calendar system.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetDaysSinceEpoch(NodaTime.YearMonthDay)">
            <summary>
            Returns the number of days since the Unix epoch (1970-01-01 ISO) for the given date.
            </summary>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetDayOfWeek(NodaTime.YearMonthDay)">
            <summary>
            Returns the IsoDayOfWeek corresponding to the day of week for the given year, month and day.
            </summary>
            <param name="yearMonthDay">The year, month and day to use to find the day of the week</param>
            <returns>The day of the week as an IsoDayOfWeek</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetDaysInYear(System.Int32)">
            <summary>
            Returns the number of days in the given year.
            </summary>
            <param name="year">The year to determine the number of days in</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The given year is invalid for this calendar.</exception>
            <returns>The number of days in the given year.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetDaysInMonth(System.Int32,System.Int32)">
            <summary>
            Returns the number of days in the given month within the given year.
            </summary>
            <param name="year">The year in which to consider the month</param>
            <param name="month">The month to determine the number of days in</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The given year / month combination
            is invalid for this calendar.</exception>
            <returns>The number of days in the given month and year.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.IsLeapYear(System.Int32)">
            <summary>
            Returns whether or not the given year is a leap year in this calendar.
            </summary>
            <param name="year">The year to consider.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The given year is invalid for this calendar.
            Note that some implementations may return a value rather than throw this exception. Failure to throw an
            exception should not be treated as an indication that the year is valid.</exception>
            <returns>True if the given year is a leap year; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.GetMonthsInYear(System.Int32)">
            <summary>
            Returns the maximum valid month (inclusive) within this calendar in the given year.
            </summary>
            <remarks>
            It is assumed that in all calendars, every month between 1 and this month
            number is valid for the given year. This does not necessarily mean that the first month of the year
            is 1, however. (See the Hebrew calendar system using the scriptural month numbering system for example.)
            </remarks>
            <param name="year">The year to consider.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The given year is invalid for this calendar.
            Note that some implementations may return a month rather than throw this exception (for example, if all
            years have the same number of months in this calendar system). Failure to throw an exception should not be
            treated as an indication that the year is valid.</exception>
            <returns>The maximum month number within the given year.</returns>
        </member>
        <member name="M:NodaTime.CalendarSystem.DebugValidateYearMonthDay(NodaTime.YearMonthDay)">
            <summary>
            In debug configurations only, this method calls <see cref="M:NodaTime.CalendarSystem.ValidateYearMonthDay(System.Int32,System.Int32,System.Int32)"/>
            with the components of the given YearMonthDay, ensuring that it's valid in the
            current calendar.
            </summary>
            <param name="yearMonthDay">The value to validate.</param>
        </member>
        <member name="P:NodaTime.CalendarSystem.Gregorian">
            <summary>
            Returns a Gregorian calendar system.
            </summary>
            <remarks>
            <para>
            The Gregorian calendar system defines every
            fourth year as leap, unless the year is divisible by 100 and not by 400.
            This improves upon the Julian calendar leap year rule.
            </para>
            <para>
            Although the Gregorian calendar did not exist before 1582 CE, this
            calendar system assumes it did, thus it is proleptic. This implementation also
            fixes the start of the year at January 1.
            </para>
            </remarks>
            <value>A Gregorian calendar system.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.Julian">
            <summary>
            Returns a pure proleptic Julian calendar system, which defines every
            fourth year as a leap year. This implementation follows the leap year rule
            strictly, even for dates before 8 CE, where leap years were actually
            irregular.
            </summary>
            <remarks>
            Although the Julian calendar did not exist before 45 BCE, this calendar
            assumes it did, thus it is proleptic. This implementation also fixes the
            start of the year at January 1.
            </remarks>
            <value>A suitable Julian calendar reference; the same reference may be returned by several
            calls as the object is immutable and thread-safe.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.Coptic">
            <summary>
            Returns a Coptic calendar system, which defines every fourth year as
            leap, much like the Julian calendar. The year is broken down into 12 months,
            each 30 days in length. An extra period at the end of the year is either 5
            or 6 days in length. In this implementation, it is considered a 13th month.
            </summary>
            <remarks>
            <para>
            Year 1 in the Coptic calendar began on August 29, 284 CE (Julian), thus
            Coptic years do not begin at the same time as Julian years. This calendar
            is not proleptic, as it does not allow dates before the first Coptic year.
            </para>
            <para>
            This implementation defines a day as midnight to midnight exactly as per
            the ISO calendar. Some references indicate that a Coptic day starts at
            sunset on the previous ISO day, but this has not been confirmed and is not
            implemented.
            </para>
            </remarks>
            <value>A suitable Coptic calendar reference; the same reference may be returned by several
            calls as the object is immutable and thread-safe.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.IslamicBcl">
            <summary>
            Returns an Islamic calendar system equivalent to the one used by the BCL HijriCalendar.
            </summary>
            <remarks>
            This uses the <see cref="F:NodaTime.Calendars.IslamicLeapYearPattern.Base16"/> leap year pattern and the
            <see cref="F:NodaTime.Calendars.IslamicEpoch.Astronomical"/> epoch. This is equivalent to HijriCalendar
            when the <c>HijriCalendar.HijriAdjustment</c> is 0.
            </remarks>
            <seealso cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>
            <value>An Islamic calendar system equivalent to the one used by the BCL.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.PersianSimple">
            <summary>
            Returns a Persian (also known as Solar Hijri) calendar system implementing the behaviour of the
            BCL <c>PersianCalendar</c> before .NET 4.6, and the sole Persian calendar in Noda Time 1.3.
            </summary>
            <remarks>
            This implementation uses a simple 33-year leap cycle, where years  1, 5, 9, 13, 17, 22, 26, and 30
            in each cycle are leap years.
            </remarks>
            <value>A Persian calendar system using a simple 33-year leap cycle.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.PersianArithmetic">
            <summary>
            Returns a Persian (also known as Solar Hijri) calendar system implementing the behaviour of the
            BCL <c>PersianCalendar</c> from .NET 4.6 onwards (and Windows 10), and the astronomical
            system described in Wikipedia and Calendrical Calculations.
            </summary>
            <remarks>
            This implementation uses data derived from the .NET 4.6 implementation (with the data built into Noda Time, so there's
            no BCL dependency) for simplicity; the actual implementation involves computing the time of noon in Iran, and
            is complex.
            </remarks>
            <value>A Persian calendar system using astronomical calculations to determine leap years.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.PersianAstronomical">
            <summary>
            Returns a Persian (also known as Solar Hijri) calendar system implementing the behaviour
            proposed by Ahmad Birashk with nested cycles of years determining which years are leap years.
            </summary>
            <remarks>
            This calendar is also known as the algorithmic Solar Hijri calendar.
            </remarks>
            <value>A Persian calendar system using cycles-within-cycles of years to determine leap years.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.HebrewCivil">
            <summary>
            Returns a Hebrew calendar system using the civil month numbering,
            equivalent to the one used by the BCL HebrewCalendar.
            </summary>
            <seealso cref="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)"/>
            <value>A Hebrew calendar system using the civil month numbering, equivalent to the one used by the
            BCL.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.HebrewScriptural">
            <summary>
            Returns a Hebrew calendar system using the scriptural month numbering.
            </summary>
            <seealso cref="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)"/>
            <value>A Hebrew calendar system using the scriptural month numbering.</value>
        </member>
        <member name="P:NodaTime.CalendarSystem.UmAlQura">
            <summary>
            Returns an Um Al Qura calendar system - an Islamic calendar system primarily used by
            Saudi Arabia.
            </summary>
            <remarks>
            This is a tabular calendar, relying on pregenerated data.
            </remarks>
            <value>A calendar system for the Um Al Qura calendar.</value>
        </member>
        <member name="T:NodaTime.CalendarSystem.IslamicCalendars">
            <summary>
            Specifically the calendars implemented by IslamicYearMonthDayCalculator, as opposed to all
            Islam-based calendars (which would include UmAlQura and Persian, for example).
            </summary>
        </member>
        <member name="T:NodaTime.CalendarSystem.MiscellaneousCalendars">
            <summary>
            Odds and ends, with an assumption that it's not *that* painful to initialize UmAlQura if you only
            need Coptic, for example.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.BadiYearMonthDayCalculator">
            <summary>
            See <see cref="P:NodaTime.CalendarSystem.Badi" /> for details about the Badíʿ calendar.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.BadiYearMonthDayCalculator.Month18">
            <remarks>
            There are 19 months in a year. Between the 18th and 19th month are the "days of Ha" (Ayyam-i-Ha).
            In order to make everything else in Noda Time work appropriately, Ayyam-i-Ha are counted as
            extra days at the end of month 18.
            </remarks>
        </member>
        <member name="F:NodaTime.Calendars.BadiYearMonthDayCalculator.YearInfoRaw">
            <summary>
            This is the base64 representation of information for years 172 to 1000.
            NazRuzDate falls on March 19, 20, 21, or 22.
            DaysInAyymiHa can be 4,5.
            For each year, the value in the array is (NawRuzDate - 19) + 10 * (DaysInAyyamiHa - 4)
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.Era">
            <summary>
            Represents an era used in a calendar.
            </summary>
            <remarks>All the built-in calendars in Noda Time use the values specified by the static
            read-only fields in this class. These may be compared for reference equality to check for specific
            eras.</remarks>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.Calendars.Era.Common">
            <summary>
            The "Common" era (CE), also known as Anno Domini (AD). This is used in the ISO, Gregorian and Julian calendars.
            </summary>
            <value>The "Common" era (CE), also known as Anno Domini (AD).</value>
        </member>
        <member name="P:NodaTime.Calendars.Era.BeforeCommon">
            <summary>
            The "before common" era (BCE), also known as Before Christ (BC). This is used in the ISO, Gregorian and Julian calendars.
            </summary>
            <value>The "before common" era (BCE), also known as Before Christ (BC).</value>
        </member>
        <member name="P:NodaTime.Calendars.Era.AnnoMartyrum">
            <summary>
            The "Anno Martyrum" or "Era of the Martyrs". This is the sole era used in the Coptic calendar.
            </summary>
            <value>The "Anno Martyrum" or "Era of the Martyrs".</value>
        </member>
        <member name="P:NodaTime.Calendars.Era.AnnoHegirae">
            <summary>
            The "Anno Hegira" era. This is the sole era used in the Hijri (Islamic) calendar.
            </summary>
            <value>The "Anno Hegira" era.</value>
        </member>
        <member name="P:NodaTime.Calendars.Era.AnnoMundi">
            <summary>
            The "Anno Mundi" era. This is the sole era used in the Hebrew calendar.
            </summary>
            <value>The "Anno Mundi" era.</value>
        </member>
        <member name="P:NodaTime.Calendars.Era.AnnoPersico">
            <summary>
            The "Anno Persico" era. This is the sole era used in the Persian calendar.
            </summary>
            <value>The "Anno Persico" era.</value>
        </member>
        <member name="P:NodaTime.Calendars.Era.Bahai">
            <summary>
            The "Bahá'í" era. This is the sole era used in the Badi calendar.
            </summary>
            <value>The "Bahá'í" era.</value>
        </member>
        <member name="P:NodaTime.Calendars.Era.Name">
            <summary>
            Returns the name of this era, e.g. "CE" or "BCE".
            </summary>
            <value>The name of this era.</value>
        </member>
        <member name="M:NodaTime.Calendars.Era.ToString">
            <summary>
            Returns the name of this era.
            </summary>
            <returns>The name of this era.</returns>
        </member>
        <member name="T:NodaTime.Calendars.EraCalculator">
            <summary>
            Takes responsibility for all era-based calculations for a calendar.
            YearMonthDay arguments can be assumed to be valid for the relevant calendar,
            but other arguments should be validated. (Eras should be validated for nullity as well
            as for the presence of a particular era.)
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.FixedMonthYearMonthDayCalculator">
            <summary>
            Abstract implementation of a year/month/day calculator based around months which always have 30 days.
            </summary>
            <remarks>
            As the month length is fixed various calculations can be optimised.
            This implementation assumes any additional days after twelve
            months fall into a thirteenth month.
            </remarks>
        </member>
        <member name="T:NodaTime.Calendars.GJEraCalculator">
            <summary>
            Era calculator for Gregorian and Julian calendar systems, which use BC and AD.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.GJYearMonthDayCalculator.GenerateTotalDaysByMonth(System.Int32[])">
            <summary>
            Produces an array with "the sum of the elements of <paramref name="monthLengths"/> before the corresponding index".
            So for an input of [0, 1, 2, 3, 4, 5] this would produce [0, 0, 1, 3, 6, 10].
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.GregorianYearMonthDayCalculator.GetGregorianYearMonthDayCalendarFromDaysSinceEpoch(System.Int32)">
            <summary>
            Specifically Gregorian-optimized conversion from "days since epoch" to year/month/day.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.HebrewMonthConverter">
            <summary>
            Conversions between civil and scriptural month numbers in the Hebrew calendar system.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.HebrewMonthConverter.CivilToScriptural(System.Int32,System.Int32)">
            <summary>
            Given a civil month number and a year in which it occurs, this method returns
            the equivalent scriptural month number.
            </summary>
            <remarks>
            No validation is performed in this method: an input month number of 13 in a non-leap-year
            will return a result of 7.
            </remarks>
            <param name="year">Year during which the month occurs.</param>
            <param name="month">Civil month number.</param>
            <returns>The scriptural month number.</returns>
        </member>
        <member name="M:NodaTime.Calendars.HebrewMonthConverter.ScripturalToCivil(System.Int32,System.Int32)">
            <summary>
            Given an scriptural month number and a year in which it occurs, this method returns
            the equivalent scriptural month number.
            </summary>
            <remarks>
            No validation is performed in this method: an input month number of 13 in a non-leap-year
            will return a result of 7.
            </remarks>
            <param name="year">Year during which the month occurs.</param>
            <param name="month">Civil month number.</param>
            <returns>The scriptural month number.</returns>
        </member>
        <member name="T:NodaTime.Calendars.HebrewMonthNumbering">
            <summary>
            The month numbering to use for the Hebrew calendar.
            </summary>
            <remarks>
            When requesting a Hebrew calendar with <see cref="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)"/>, a month numbering
            system needs to be specified. There are two main ways of numbering the Hebrew months: the civil
            system where month 1 is the start of the new year (Tishri) and scriptural system where month 1 is
            Nisan, according to biblical custom.
            </remarks>
        </member>
        <member name="F:NodaTime.Calendars.HebrewMonthNumbering.Civil">
            <summary>
            <para>
            The numbering system where month 1 is Tishri. This has the advantage of familiarity with other
            calendars where the first month is 1; it is easier to tell which date comes before which, aside
            from anything else. It is also the numbering system used by the BCL.
            </para>
            <para>The main disadvantage is that due to leap years effectively "splitting" Adar into Adar I
            and Adar II, the months after that (Nisan, Iyyar and so on) have month numberings which depend
            on the year.</para>
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.HebrewMonthNumbering.Scriptural">
            <summary>
            <para>
            The numbering system where month 1 is Nisan. This is the numbering system which matches biblical
            custom (such as Leviticus 23:5). This has the advantage that the split of Adar is at the end of the
            numbering system, so all other month names are stable.
            </para>
            <para>The primary disadvantage of this numbering system is that months 1-6 come after months 7-12 (or 13),
            which is counter-intuitive.</para>
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.HebrewScripturalCalculator">
            <summary>
            Implementation of the algorithms described in
            https://www.cs.tau.ac.il/~nachum/calendar-book/papers/calendar.ps, using scriptural
            month numbering.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.HebrewScripturalCalculator.ElapsedDays(System.Int32)">
            <summary>
            Elapsed days since the Hebrew epoch at the start of the given Hebrew year.
            This is *inclusive* of the first day of the year, so ElapsedDays(1) returns 1.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.HebrewScripturalCalculator.GetOrPopulateCache(System.Int32)">
            <summary>
            Returns the cached "elapsed day at start of year / IsHeshvanLong / IsKislevShort" combination,
            populating the cache if necessary. Bits 2-24 are the "elapsed days start of year"; bit 0 is
            "is Heshvan long"; bit 1 is "is Kislev short". If the year is out of the range for the cache,
            the value is populated but not cached.
            </summary>
            <param name="year"></param>
        </member>
        <member name="M:NodaTime.Calendars.HebrewScripturalCalculator.ComputeCacheEntry(System.Int32)">
            <summary>
            Computes the cache entry value for the given year, but without populating the cache.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.HebrewYearMonthDayCalculator">
            <summary>
            See <see cref="M:NodaTime.CalendarSystem.GetHebrewCalendar(NodaTime.Calendars.HebrewMonthNumbering)" /> for details. This is effectively
            an adapter around <see cref="T:NodaTime.Calendars.HebrewScripturalCalculator"/>.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.HebrewYearMonthDayCalculator.IsLeapYear(System.Int32)">
            <summary>
            Returns whether or not the given year is a leap year - that is, one with 13 months. This is
            not quite the same as a leap year in (say) the Gregorian calendar system...
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.HebrewYearMonthDayCalculator.SetYear(NodaTime.YearMonthDay,System.Int32)">
            <summary>
            Change the year, maintaining month and day as well as possible. This doesn't
            work in the same way as other calendars; see https://judaism.stackexchange.com/questions/39053
            for the reasoning behind the rules.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.IslamicEpoch">
            <summary>
            The epoch to use when constructing an Islamic calendar.
            </summary>
            <remarks>
            The Islamic, or Hijri, calendar can either be constructed
            starting on July 15th 622CE (in the Julian calendar) or on the following day.
            The former is the "astronomical" or "Thursday" epoch; the latter is the "civil" or "Friday" epoch.
            </remarks>
            <seealso cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>
        </member>
        <member name="F:NodaTime.Calendars.IslamicEpoch.Astronomical">
            <summary>
            Epoch beginning on July 15th 622CE (Julian), which is July 18th 622 CE in the Gregorian calendar.
            This is the epoch used by the BCL HijriCalendar.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicEpoch.Civil">
            <summary>
            Epoch beginning on July 16th 622CE (Julian), which is July 19th 622 CE in the Gregorian calendar.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.IslamicLeapYearPattern">
            <summary>
            The pattern of leap years to use when constructing an Islamic calendar.
            </summary>
            <remarks>
            <para>
            The Islamic, or Hijri, calendar is a lunar calendar of 12 months, each of 29 or 30 days.
            The calendar can be defined in either observational or tabular terms; 
            Noda Time implements a tabular calendar, where a pattern of leap years (in which the last month has
            an extra day) repeats every 30 years, according to one of the patterns within this enum.
            </para>
            <para>
            While the patterns themselves are reasonably commonly documented (see e.g.
            <a href="https://en.wikipedia.org/wiki/Tabular_Islamic_calendar">Wikipedia</a>)
            there is little standardization in terms of naming the patterns. I hope the current names do not
            cause offence to anyone; suggestions for better names would be welcome.
            </para>
            <seealso cref="M:NodaTime.CalendarSystem.GetIslamicCalendar(NodaTime.Calendars.IslamicLeapYearPattern,NodaTime.Calendars.IslamicEpoch)"/>
            </remarks>
        </member>
        <member name="F:NodaTime.Calendars.IslamicLeapYearPattern.Base15">
            <summary>
            A pattern of leap years in 2, 5, 7, 10, 13, 15, 18, 21, 24, 26 and 29.
            This pattern and <see cref="F:NodaTime.Calendars.IslamicLeapYearPattern.Base16"/> are the most commonly used ones,
            and only differ in whether the 15th or 16th year is deemed leap.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicLeapYearPattern.Base16">
            <summary>
            A pattern of leap years in 2, 5, 7, 10, 13, 16, 18, 21, 24, 26 and 29.
            This pattern and <see cref="F:NodaTime.Calendars.IslamicLeapYearPattern.Base15"/> are the most commonly used ones,
            and only differ in whether the 15th or 16th year is deemed leap. This is
            the pattern used by the BCL HijriCalendar.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicLeapYearPattern.Indian">
            <summary>
            A pattern of leap years in 2, 5, 8, 10, 13, 16, 19, 21, 24, 27 and 29.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicLeapYearPattern.HabashAlHasib">
            <summary>
            A pattern of leap years in 2, 5, 8, 11, 13, 16, 19, 21, 24, 27 and 30.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.MonthPairLength">
            <summary>Days in a pair of months, in days.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.LongMonthLength">
            <summary>The length of a long month, in days.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.ShortMonthLength">
            <summary>The length of a short month, in days.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.AverageDaysPer10Years">
            <summary>The typical number of days in 10 years.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.DaysPerNonLeapYear">
            <summary>The number of days in a non-leap year.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.DaysPerLeapYear">
            <summary>The number of days in a leap year.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.DaysAtCivilEpoch">
            <summary>The days for the civil (Friday) epoch of July 16th 622CE.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.DaysAtAstronomicalEpoch">
            <summary>The days for the civil (Thursday) epoch of July 15th 622CE.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.LeapYearCycleLength">
            <summary>The length of the cycle of leap years.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.DaysPerLeapCycle">
            <summary>The number of days in leap cycle.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.leapYearPatternBits">
            <summary>The pattern of leap years within a cycle, one bit per year, for this calendar.</summary>
        </member>
        <member name="F:NodaTime.Calendars.IslamicYearMonthDayCalculator.TotalDaysByMonth">
            <summary>The number of days preceding the 1-indexed month - so [0, 0, 30, 59, ...]</summary>
        </member>
        <member name="M:NodaTime.Calendars.IslamicYearMonthDayCalculator.GetLeapYearPatternBits(NodaTime.Calendars.IslamicLeapYearPattern)">
            <summary>
            Returns the pattern of leap years within a cycle, one bit per year, for the specified pattern.
            Note that although cycle years are usually numbered 1-30, the bit pattern is for 0-29; cycle year
            30 is represented by bit 0.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.IslamicYearMonthDayCalculator.GetYear1Days(NodaTime.Calendars.IslamicEpoch)">
            <summary>
            Returns the days since the Unix epoch at the specified epoch.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.IWeekYearRule">
            <summary>
            A rule determining how "week years" are arranged, including the weeks within the week year.
            Implementations provided by Noda Time itself can be obtained via the <see cref="T:NodaTime.Calendars.WeekYearRules"/>
            class.
            </summary>
            <remarks>
            <para>
            Dates are usually identified within a calendar system by a calendar year, a month within that
            calendar year, and a day within that month. For example, the date of birth of Ada Lovelace can be identified
            within the Gregorian calendar system as the year 1815, the month December (12), and the day 10. However,
            dates can also be identified (again within a calendar system) by week-year, week and day-of-week. How
            that identification occurs depends on which rule you use - but again as an example, within the Gregorian
            calendar system, using the ISO-8601 week year rule, the date of Ada Lovelace's birth is week-year 1815,
            week 49, day-of-week Sunday.
            </para>
            <para>
            The calendar year of a date and the week-year of a date are the same in most rules for most dates, but aren't
            always. When they differ, it is usually because a day near the start of the calendar year is deemed to belong
            to the last week of the previous week-year - or conversely because a day near the end of the calendar year is
            deemed to belong to the first week of the following week-year. Some rules may be more radical -
            a UK tax year rule could number weeks from April 6th onwards, such that any date earlier than that in the calendar
            year would belong to the previous week-year.
            </para>
            <para>
            The mapping of dates into week-year, week and day-of-week is always relative to a specific calendar system.
            For example, years in the Hebrew calendar system vary very significantly in length due to leap months, and this
            is reflected in the number of weeks within the week-years - as low as 50, and as high as 55.
            </para>
            <para>
            This class allows conversions between the two schemes of identifying dates: <see cref="M:NodaTime.Calendars.IWeekYearRule.GetWeekYear(NodaTime.LocalDate)"/>
            and <see cref="M:NodaTime.Calendars.IWeekYearRule.GetWeekOfWeekYear(NodaTime.LocalDate)"/> allow the week-year and week to be obtained for a date, and
            <see cref="M:NodaTime.Calendars.IWeekYearRule.GetLocalDate(System.Int32,System.Int32,NodaTime.IsoDayOfWeek,NodaTime.CalendarSystem)"/> allows the reverse mapping. Note that
            the calendar system does not need to be specified in the former methods as a <see cref="T:NodaTime.LocalDate"/> already
            contains calendar information, and there is no method to obtain the day-of-week as that is not affected by the
            week year rule being used.
            </para>
            <para>
            All implementations within Noda Time are immutable, and it is advised that any external implementations
            should be immutable too.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.Calendars.IWeekYearRule.GetLocalDate(System.Int32,System.Int32,NodaTime.IsoDayOfWeek,NodaTime.CalendarSystem)">
            <summary>
            Creates a <see cref="T:NodaTime.LocalDate" /> from a given week-year, week within that week-year,
            and day-of-week, for the specified calendar system.
            </summary>
            <remarks>
            <para>
            Wherever reasonable, implementations should ensure that all valid dates
            can be constructed via this method. In other words, given a <see cref="T:NodaTime.LocalDate"/> <c>date</c>,
            <c>rule.GetLocalDate(rule.GetWeekYear(date), rule.GetWeekOfWeekYear(date), date.IsoDayOfWeek, date.Calendar)</c>
            should always return <c>date</c>. This is true for all rules within Noda Time, but third party
            implementations may choose to simplify their implementations by restricting them to appropriate portions
            of time.
            </para>
            <para>
            Implementations may restrict which calendar systems supplied here, but the implementations provided by
            Noda Time work with all available calendar systems.
            </para>
            </remarks>
            <param name="weekYear">The week-year of the new date. Implementations provided by Noda Time allow any
            year which is a valid calendar year, and sometimes one less than the minimum calendar year
            and/or one more than the maximum calendar year, to allow for dates near the start of a calendar
            year to fall in the previous week year, and similarly for dates near the end of a calendar year.</param>
            <param name="weekOfWeekYear">The week of week-year of the new date. Valid values for this parameter
            may vary depending on <paramref name="weekYear"/>, as the length of a year in weeks varies.</param>
            <param name="dayOfWeek">The day-of-week of the new date. Valid values for this parameter may vary
            depending on <paramref name="weekYear"/> and <paramref name="weekOfWeekYear"/>.</param>
            <param name="calendar">The calendar system for the date.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not combine to form a valid date.</exception>
            <returns>A <see cref="T:NodaTime.LocalDate"/> corresponding to the specified values.</returns>
        </member>
        <member name="M:NodaTime.Calendars.IWeekYearRule.GetWeekYear(NodaTime.LocalDate)">
            <summary>
            Calculates the week-year in which the given date occurs, according to this rule.
            </summary>
            <param name="date">The date to compute the week-year of.</param>
            <returns>The week-year of <paramref name="date"/>, according to this rule.</returns>
        </member>
        <member name="M:NodaTime.Calendars.IWeekYearRule.GetWeekOfWeekYear(NodaTime.LocalDate)">
            <summary>
            Calculates the week of the week-year in which the given date occurs, according to this rule.
            </summary>
            <param name="date">The date to compute the week of.</param>
            <returns>The week of the week-year of <paramref name="date"/>, according to this rule.</returns>
        </member>
        <member name="M:NodaTime.Calendars.IWeekYearRule.GetWeeksInWeekYear(System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Returns the number of weeks in the given week-year, within the specified calendar system.
            </summary>
            <param name="weekYear">The week-year to find the range of.</param>
            <param name="calendar">The calendar system the calculation is relative to.</param>
            <returns>The number of weeks in the given week-year within the given calendar.</returns>
        </member>
        <member name="T:NodaTime.Calendars.WeekYearRuleExtensions">
            <summary>
            Extension methods on <see cref="T:NodaTime.Calendars.IWeekYearRule"/>.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.WeekYearRuleExtensions.GetLocalDate(NodaTime.Calendars.IWeekYearRule,System.Int32,System.Int32,NodaTime.IsoDayOfWeek)">
            <summary>
            Convenience method to call <see cref="M:NodaTime.Calendars.IWeekYearRule.GetLocalDate(System.Int32,System.Int32,NodaTime.IsoDayOfWeek,NodaTime.CalendarSystem)"/>
            passing in the ISO calendar system.
            </summary>
            <param name="rule">The rule to delegate the call to.</param>
            <param name="weekYear">The week-year of the new date. Implementations provided by Noda Time allow any
            year which is a valid calendar year, and sometimes one less than the minimum calendar year
            and/or one more than the maximum calendar year, to allow for dates near the start of a calendar
            year to fall in the previous week year, and similarly for dates near the end of a calendar year.</param>
            <param name="weekOfWeekYear">The week of week-year of the new date. Valid values for this parameter
            may vary depending on <paramref name="weekYear"/>, as the length of a year in weeks varies.</param>
            <param name="dayOfWeek">The day-of-week of the new date. Valid values for this parameter may vary
            depending on <paramref name="weekYear"/> and <paramref name="weekOfWeekYear"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not combine to form a valid date.</exception>
            <returns>A <see cref="T:NodaTime.LocalDate"/> corresponding to the specified values.</returns>
        </member>
        <member name="M:NodaTime.Calendars.WeekYearRuleExtensions.GetWeeksInWeekYear(NodaTime.Calendars.IWeekYearRule,System.Int32)">
            <summary>
            Convenience overload to call <see cref="M:NodaTime.Calendars.IWeekYearRule.GetWeeksInWeekYear(System.Int32,NodaTime.CalendarSystem)"/> with
            the ISO calendar system.
            </summary>
            <param name="rule">The rule to delegate the call to.</param>
            <param name="weekYear">The week year to calculate the number of contained weeks.</param>
            <returns>The number of weeks in the given week year.</returns>
        </member>
        <member name="T:NodaTime.Calendars.PersianYearMonthDayCalculator">
            <summary>
            Base class for the three variants of the Persian (Solar Hijri) calendar.
            Concrete subclasses are nested to allow different start dates and leap year calculations.
            </summary>
            <remarks>
            The constructor uses IsLeapYear to precompute lots of data; it is therefore important that
            the implementation of IsLeapYear in subclasses uses no instance fields.
            </remarks>
        </member>
        <member name="F:NodaTime.Calendars.PersianYearMonthDayCalculator.TotalDaysByMonth">
            <summary>The number of days preceding the 1-indexed month - so [0, 0, 31, 62, 93, ...]</summary>
        </member>
        <member name="T:NodaTime.Calendars.PersianYearMonthDayCalculator.Simple">
            <summary>
            Persian calendar using the simple 33-year cycle of 1, 5, 9, 13, 17, 22, 26, or 30.
            This corresponds to System.Globalization.PersianCalendar before .NET 4.6.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.PersianYearMonthDayCalculator.Simple.DaysAtStartOfYear1Constant">
            <summary>The ticks for the epoch of March 21st 622CE.</summary>
        </member>
        <member name="M:NodaTime.Calendars.PersianYearMonthDayCalculator.Simple.IsLeapYear(System.Int32)">
            <summary>
            Leap year condition using the simple 33-year cycle of 1, 5, 9, 13, 17, 22, 26, or 30.
            This corresponds to System.Globalization.PersianCalendar before .NET 4.6.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.PersianYearMonthDayCalculator.Arithmetic">
            <summary>
            Persian calendar based on Birashk's subcycle/cycle/grand cycle scheme.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.PersianYearMonthDayCalculator.Astronomical">
            <summary>
            Persian calendar based on stored BCL 4.6 information (avoids complex arithmetic for
            midday in Tehran).
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.RegularYearMonthDayCalculator">
            <summary>
            Subclass of YearMonthDayCalculator for calendars with the following attributes:
            <list type="bullet">
            <item>A fixed number of months</item>
            <item>Occasional leap years which are always 1 day longer than non-leap years</item>
            <item>The year starting with month 1, day 1 (i.e. naive YearMonthDay comparisons work)</item>
            </list>
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.RegularYearMonthDayCalculator.SetYear(NodaTime.YearMonthDay,System.Int32)">
            <summary>
            Implements a simple year-setting policy, truncating the day
            if necessary.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.SimpleWeekYearRule">
            <summary>
            Implements <see cref="T:NodaTime.Calendars.IWeekYearRule"/> for a rule where weeks are regular:
            every week has exactly 7 days, which means that some week years straddle
            the calendar year boundary. (So the start of a week can occur in one calendar
            year, and the end of the week in the following calendar year, but the whole
            week is in the same week-year.)
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.SimpleWeekYearRule.irregularWeeks">
             <summary>
             If true, the boundary of a calendar year sometimes splits a week in half. The
             last day of the calendar year is *always* in the last week of the same week-year, but
             the first day of the calendar year *may* be in the last week of the previous week-year.
             (Basically, the rule works out when the first day of the week-year would be logically,
             and then cuts it off so that it's never in the previous calendar year.)
            
             If false, all weeks are 7 days long, including across calendar-year boundaries.
             This is the state for ISO-like rules.
             </summary>
        </member>
        <member name="M:NodaTime.Calendars.SimpleWeekYearRule.GetLocalDate(System.Int32,System.Int32,NodaTime.IsoDayOfWeek,NodaTime.CalendarSystem)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Calendars.SimpleWeekYearRule.GetWeekOfWeekYear(NodaTime.LocalDate)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Calendars.SimpleWeekYearRule.GetWeeksInWeekYear(System.Int32,NodaTime.CalendarSystem)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Calendars.SimpleWeekYearRule.GetWeekYear(NodaTime.LocalDate)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Calendars.SimpleWeekYearRule.ValidateWeekYear(System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Validate that at least one day in the calendar falls in the given week year.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.SimpleWeekYearRule.GetWeekYearDaysSinceEpoch(NodaTime.Calendars.YearMonthDayCalculator,System.Int32)">
            <summary>
            Returns the days at the start of the given week-year. The week-year may be
            1 higher or lower than the max/min calendar year. For non-regular rules (i.e. where some weeks
            can be short) it returns the day when the week-year *would* have started if it were regular.
            So this *always* returns a date on firstDayOfWeek.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.SingleEraCalculator">
            <summary>
            Implementation of <see cref="T:NodaTime.Calendars.EraCalculator"/> for calendars which only have a single era.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.UmAlQuraYearMonthDayCalculator">
            <summary>
            Implementation of the Um Al Qura calendar, using the tabular data in the BCL. This is fetched
            on construction and cached - we just need to know the length of each month of each year, which is
            cheap as the current implementation only covers 183 years.
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.WeekYearRules">
            <summary>
            Factory methods to construct week-year rules supported by Noda Time.
            </summary>
        </member>
        <member name="P:NodaTime.Calendars.WeekYearRules.Iso">
            <summary>
            Returns an <see cref="T:NodaTime.Calendars.IWeekYearRule"/> consistent with ISO-8601.
            </summary>
            <remarks>
            <para>
            In the standard ISO-8601 week algorithm, the first week of the year
            is that in which at least 4 days are in the year. As a result of this
            definition, day 1 of the first week may be in the previous year. In ISO-8601,
            weeks always begin on a Monday, so this rule is equivalent to the first Thursday
            being in the first Monday-to-Sunday week of the year.
            </para>
            <para>
            For example, January 1st 2011 was a Saturday, so only two days of that week
            (Saturday and Sunday) were in 2011. Therefore January 1st is part of
            week 52 of week-year 2010. Conversely, December 31st 2012 is a Monday,
            so is part of week 1 of week-year 2013.
            </para>
            </remarks>
            <value>A <see cref="T:NodaTime.Calendars.IWeekYearRule"/> consistent with ISO-8601.</value>
        </member>
        <member name="M:NodaTime.Calendars.WeekYearRules.ForMinDaysInFirstWeek(System.Int32)">
            <summary>
            Creates a week year rule where the boundary between one week-year and the next
            is parameterized in terms of how many days of the first week of the week
            year have to be in the new calendar year. In rules created by this method, 
            weeks are always deemed to begin on an Monday.
            </summary>
            <remarks>
            <paramref name="minDaysInFirstWeek"/> determines when the first week of the week-year starts.
            For any given calendar year X, consider the Monday-to-Sunday week that includes the first day of the
            calendar year. Usually, some days of that week are in calendar year X, and some are in calendar year 
            X-1. If <paramref name="minDaysInFirstWeek"/> or more of the days are in year X, then the week is
            deemed to be the first week of week-year X. Otherwise, the week is deemed to be the last week of
            week-year X-1, and the first week of week-year X starts on the following Monday.
            </remarks>
            <param name="minDaysInFirstWeek">The minimum number of days in the first Monday-to-Sunday week
            which have to be in the new calendar year for that week to count as being in that week-year.
            Must be in the range 1 to 7 inclusive.
            </param>
            <returns>A <see cref="T:NodaTime.Calendars.SimpleWeekYearRule"/> with the specified minimum number of days in the first
            week.</returns>
        </member>
        <member name="M:NodaTime.Calendars.WeekYearRules.ForMinDaysInFirstWeek(System.Int32,NodaTime.IsoDayOfWeek)">
            <summary>
            Creates a week year rule where the boundary between one week-year and the next
            is parameterized in terms of how many days of the first week of the week
            year have to be in the new calendar year, and also by which day is deemed
            to be the first day of the week.
            </summary>
            <remarks>
            <paramref name="minDaysInFirstWeek"/> determines when the first week of the week-year starts.
            For any given calendar year X, consider the week that includes the first day of the
            calendar year. Usually, some days of that week are in calendar year X, and some are in calendar year 
            X-1. If <paramref name="minDaysInFirstWeek"/> or more of the days are in year X, then the week is
            deemed to be the first week of week-year X. Otherwise, the week is deemed to be the last week of
            week-year X-1, and the first week of week-year X starts on the following <paramref name="firstDayOfWeek"/>.
            </remarks>
            <param name="minDaysInFirstWeek">The minimum number of days in the first week (starting on
            <paramref name="firstDayOfWeek" />) which have to be in the new calendar year for that week
            to count as being in that week-year. Must be in the range 1 to 7 inclusive.
            </param>
            <param name="firstDayOfWeek">The first day of the week.</param>
            <returns>A <see cref="T:NodaTime.Calendars.SimpleWeekYearRule"/> with the specified minimum number of days in the first
            week and first day of the week.</returns>
        </member>
        <member name="M:NodaTime.Calendars.WeekYearRules.FromCalendarWeekRule(System.Globalization.CalendarWeekRule,System.DayOfWeek)">
            <summary>
            Creates a rule which behaves the same way as the BCL
            <see cref="M:System.Globalization.Calendar.GetWeekOfYear(System.DateTime,System.Globalization.CalendarWeekRule,System.DayOfWeek)"/>
            method.
            </summary>
            <remarks>The BCL week year rules are subtly different to the ISO rules.
            In particular, the last few days of the calendar year are always part of the same
            week-year in the BCL rules, whereas in the ISO rules they can fall into the next
            week-year. (The first few days of the calendar year can be part of the previous
            week-year in both kinds of rule.) This means that in the BCL rules, some weeks
            are incomplete, whereas ISO weeks are always exactly 7 days long.
            </remarks>
            <param name="calendarWeekRule">The BCL rule to emulate.</param>
            <param name="firstDayOfWeek">The first day of the week to use in the rule.</param>
            <returns>A rule which behaves the same way as the BCL
            <see cref="M:System.Globalization.Calendar.GetWeekOfYear(System.DateTime,System.Globalization.CalendarWeekRule,System.DayOfWeek)"/>
            method.</returns>
        </member>
        <member name="T:NodaTime.Calendars.YearMonthDayCalculator">
            <summary>
            The core of date calculations in Noda Time. This class *only* cares about absolute years, and only
            dates - it has no time aspects at all, nor era-related aspects.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.YearMonthDayCalculator.yearCache">
            <summary>
            Cache to speed up working out when a particular year starts.
            See the <see cref="T:NodaTime.Calendars.YearStartCacheEntry"/> documentation and <see cref="M:NodaTime.Calendars.YearMonthDayCalculator.GetStartOfYearInDays(System.Int32)"/>
            for more details.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetDaysFromStartOfYearToStartOfMonth(System.Int32,System.Int32)">
            <summary>
            Returns the number of days from the start of the given year to the start of the given month.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.CalculateStartOfYearDays(System.Int32)">
            <summary>
            Compute the start of the given year in days since 1970-01-01 ISO. The year may be outside
            the bounds advertised by the calendar, but only by a single year. This method is only
            called by <see cref="M:NodaTime.Calendars.YearMonthDayCalculator.GetStartOfYearInDays(System.Int32)"/> (unless the calendar chooses to call it itself),
            so calendars which override that method and don't call the original implementation may leave
            this unimplemented (e.g. by throwing an exception if it's ever called).
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetDaysInYear(System.Int32)">
            <summary>
            Returns the number of days in the given year, which will always be within 1 year of
            the valid range for the calculator.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.MonthsBetween(NodaTime.YearMonthDay,NodaTime.YearMonthDay)">
            <summary>
            Find the months between <paramref name="start"/> and <paramref name="end"/>.
            (If start is earlier than end, the result will be non-negative.)
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.SetYear(NodaTime.YearMonthDay,System.Int32)">
            <summary>
            Adjusts the given YearMonthDay to the specified year, potentially adjusting
            other fields as required.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetDaysSinceEpoch(NodaTime.YearMonthDay)">
            <summary>
            Computes the days since the Unix epoch at the start of the given year/month/day.
            This is the opposite of <see cref="M:NodaTime.Calendars.YearMonthDayCalculator.GetYearMonthDay(System.Int32)"/>.
            This assumes the parameter have been validated previously.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetStartOfYearInDays(System.Int32)">
            <summary>
            Fetches the start of the year (in days since 1970-01-01 ISO) from the cache, or calculates
            and caches it.
            </summary>
            <param name="year">The year to fetch the days at the start of. This must be within 1 year of the min/max
            range, but can exceed it to make week-year calculations simple.</param>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.Compare(NodaTime.YearMonthDay,NodaTime.YearMonthDay)">
            <summary>
            Compares two YearMonthDay values according to the rules of this calendar.
            The default implementation simply uses a naive comparison of the values,
            as this is suitable for most calendars (where the first month of the year is month 1).
            </summary>
            <remarks>Although the parameters are trusted (as in, they'll be valid in this calendar),
            the method being public isn't a problem - this type is never exposed.</remarks>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetDayOfYear(NodaTime.YearMonthDay)">
            <summary>
            Converts from a YearMonthDay representation to "day of year".
            This assumes the parameter have been validated previously.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetYearMonthDay(System.Int32)">
            <summary>
            Works out the year/month/day of a given days-since-epoch by first computing the year and day of year,
            then getting the month and day from those two. This is how almost all calendars are naturally implemented
            anyway.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearMonthDayCalculator.GetYear(System.Int32,System.Int32@)">
            <summary>
            Work out the year from the number of days since the epoch, as well as the
            day of that year (0-based).
            </summary>
        </member>
        <member name="T:NodaTime.Calendars.YearStartCacheEntry">
            <summary>
            Type containing as much logic as possible for how the cache of "start of year" data works.
            As of Noda Time 1.3, this is not specific to YearMonthDayCalculator - it can be used for
            other frames of reference, so long as they comply with the restrictions listed below.
            </summary>
            <remarks>
            <para>
            Each entry in the cache is a 32-bit number. The "value" part of the entry consists of the
            number of days since the Unix epoch (negative for a value before the epoch). As Noda Time
            only supports a number of ticks since the Unix epoch of between long.MinValue and long.MaxValue,
            we only need to support a number of days in the range
            [long.MinValue / TicksPerDay, long.MaxValue / TicksPerDay] which is [-10675200, 10675200] (rounding
            away from 0). This value can be stored in 25 bits.
            </para>
            <para>
            The remaining 7 bits of the value are used for validation. For any given year, the bottom
            10 bits are used as the index into the cache (which is an array). The next 7 most significant
            bits are stored in the entry. So long as we have fewer than 17 significant bits in the year value,
            this will be a unique combination. A single validation value (the most highly positive value) is
            reserved to indicate an invalid entry. The cache is initialized with all entries invalid.
            This gives us a range of year numbers greater than [-60000, 60000] without any risk of collisions. By
            contrast, the ISO calendar years are in the range [-27255, 31195] - so we'd have to be dealing with a
            calendar with either very short years, or an epoch a long way ahead or behind the Unix epoch.
            </para>
            <para>
            The fact that each cache entry is only 32 bits means that we can safely use the cache from multiple
            threads without locking. 32-bit aligned values are guaranteed to be accessed atomically, so we know we'll
            never get the value for one year with the validation bits for another, for example.
            </para>
            </remarks>
        </member>
        <member name="F:NodaTime.Calendars.YearStartCacheEntry.Invalid">
            <summary>
            Entry which is guaranteed to be obviously invalid for any real date, by having
            a validation value which is larger than any valid year number.
            </summary>
        </member>
        <member name="F:NodaTime.Calendars.YearStartCacheEntry.value">
            <summary>
            Entry value: most significant 25 bits are the number of days (e.g. since the Unix epoch); remaining 7 bits are
            the validator.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearStartCacheEntry.GetValidator(System.Int32)">
            <summary>
            Returns the validator to use for a given year, a non-negative number containing at most
            EntryValidationBits bits.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearStartCacheEntry.GetCacheIndex(System.Int32)">
            <summary>
            Returns the cache index, in [0, CacheSize), that should be used to store the given year's cache entry.
            </summary>
        </member>
        <member name="M:NodaTime.Calendars.YearStartCacheEntry.IsValidForYear(System.Int32)">
            <summary>
            Returns whether this cache entry is valid for the given year, and so is safe to use.  (We assume that we
            have located this entry via the correct cache index.)
            </summary>
        </member>
        <member name="P:NodaTime.Calendars.YearStartCacheEntry.StartOfYearDays">
            <summary>
            Returns the (signed) number of days since the Unix epoch for the cache entry.
            </summary>
        </member>
        <member name="T:NodaTime.DateAdjusters">
            <summary>
            Factory class for date adjusters: functions from <see cref="T:NodaTime.LocalDate"/> to <c>LocalDate</c>,
            which can be applied to <see cref="T:NodaTime.LocalDate"/>, <see cref="T:NodaTime.LocalDateTime"/>, and <see cref="T:NodaTime.OffsetDateTime"/>.
            </summary>
        </member>
        <member name="P:NodaTime.DateAdjusters.StartOfMonth">
            <summary>
            A date adjuster to move to the first day of the current month.
            </summary>
            <value>
            A date adjuster to move to the first day of the current month.
            </value>
        </member>
        <member name="P:NodaTime.DateAdjusters.EndOfMonth">
            <summary>
            A date adjuster to move to the last day of the current month.
            </summary>
            <value>
            A date adjuster to move to the last day of the current month.
            </value>
        </member>
        <member name="M:NodaTime.DateAdjusters.DayOfMonth(System.Int32)">
            <summary>
            A date adjuster to move to the specified day of the current month.
            </summary>
            <remarks>
            The returned adjuster will throw an exception if it is applied to a date
            that would create an invalid result.
            </remarks>
            <param name="day">The day of month to adjust dates to.</param>
            <returns>An adjuster which changes the day to <paramref name="day"/>,
            retaining the same year and month.</returns>
        </member>
        <member name="M:NodaTime.DateAdjusters.Month(System.Int32)">
            <summary>
            A date adjuster to move to the same day of the specified month.
            </summary>
            <remarks>
            The returned adjuster will throw an exception if it is applied to a date
            that would create an invalid result.
            </remarks>
            <param name="month">The month to adjust dates to.</param>
            <returns>An adjuster which changes the month to <paramref name="month"/>,
            retaining the same year and day of month.</returns>
        </member>
        <member name="M:NodaTime.DateAdjusters.NextOrSame(NodaTime.IsoDayOfWeek)">
            <summary>
            A date adjuster to move to the next specified day-of-week, but return the
            original date if the day is already correct.
            </summary>
            <param name="dayOfWeek">The day-of-week to adjust dates to.</param>
            <returns>An adjuster which advances a date to the next occurrence of the
            specified day-of-week, or the original date if the day is already correct.</returns>
        </member>
        <member name="M:NodaTime.DateAdjusters.PreviousOrSame(NodaTime.IsoDayOfWeek)">
            <summary>
            A date adjuster to move to the previous specified day-of-week, but return the
            original date if the day is already correct.
            </summary>
            <param name="dayOfWeek">The day-of-week to adjust dates to.</param>
            <returns>An adjuster which advances a date to the previous occurrence of the
            specified day-of-week, or the original date if the day is already correct.</returns>
        </member>
        <member name="M:NodaTime.DateAdjusters.Next(NodaTime.IsoDayOfWeek)">
            <summary>
            A date adjuster to move to the next specified day-of-week, adding
            a week if the day is already correct.
            </summary>
            <remarks>
            This is the adjuster equivalent of <see cref="M:NodaTime.LocalDate.Next(NodaTime.IsoDayOfWeek)"/>.
            </remarks>
            <param name="dayOfWeek">The day-of-week to adjust dates to.</param>
            <returns>An adjuster which advances a date to the next occurrence of the
            specified day-of-week.</returns>
        </member>
        <member name="M:NodaTime.DateAdjusters.Previous(NodaTime.IsoDayOfWeek)">
            <summary>
            A date adjuster to move to the previous specified day-of-week, subtracting
            a week if the day is already correct.
            </summary>
            <remarks>
            This is the adjuster equivalent of <see cref="M:NodaTime.LocalDate.Previous(NodaTime.IsoDayOfWeek)"/>.
            </remarks>
            <param name="dayOfWeek">The day-of-week to adjust dates to.</param>
            <returns>An adjuster which advances a date to the previous occurrence of the
            specified day-of-week.</returns>
        </member>
        <member name="M:NodaTime.DateAdjusters.AddPeriod(NodaTime.Period)">
            <summary>
            Creates a date adjuster to add the specified period to the date.
            </summary>
            <remarks>
            This is the adjuster equivalent of <see cref="M:NodaTime.LocalDate.Plus(NodaTime.Period)"/>.
            </remarks>
            <param name="period">The period to add when the adjuster is invoked. Must not contain any (non-zero) time units.</param>
            <returns>An adjuster which adds the specified period.</returns>
        </member>
        <member name="T:NodaTime.DateInterval">
            <summary>
            An interval between two dates.
            </summary>
            <remarks>
            <para>
            Equality is defined in a component-wise fashion: two date intervals are considered equal if their start dates are
            equal to each other and their end dates are equal to each other. Ordering between date intervals is not defined.
            </para>
            <para>
            The two dates must be in the same calendar, and the end date must not be earlier than the start date.
            </para>
            <para>
            The end date is deemed to be part of the range, as this matches many real life uses of
            date ranges. For example, if someone says "I'm going to be on holiday from Monday to Friday," they
            usually mean that Friday is part of their holiday.
            </para>
            </remarks>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.DateInterval.Start">
            <summary>
            Gets the start date of the interval.
            </summary>
            <value>The start date of the interval.</value>
        </member>
        <member name="P:NodaTime.DateInterval.End">
            <summary>
            Gets the end date of the interval.
            </summary>
            <value>The end date of the interval.</value>
        </member>
        <member name="M:NodaTime.DateInterval.#ctor(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Constructs a date interval from a start date and an end date, both of which are included
            in the interval.
            </summary>
            <param name="start">Start date of the interval</param>
            <param name="end">End date of the interval</param>
            <exception cref="T:System.ArgumentException"><paramref name="end"/> is earlier than <paramref name="start"/>
            or the two dates are in different calendars.
            </exception>
            <returns>A date interval between the specified dates.</returns>
        </member>
        <member name="M:NodaTime.DateInterval.GetHashCode">
            <summary>
            Returns the hash code for this interval, consistent with <see cref="M:NodaTime.DateInterval.Equals(NodaTime.DateInterval)"/>.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>The hash code for this interval.</returns>
        </member>
        <member name="M:NodaTime.DateInterval.op_Equality(NodaTime.DateInterval,NodaTime.DateInterval)">
            <summary>
            Compares two <see cref="T:NodaTime.DateInterval" /> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>True if the two date intervals have the same properties; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.DateInterval.op_Inequality(NodaTime.DateInterval,NodaTime.DateInterval)">
            <summary>
            Compares two <see cref="T:NodaTime.DateInterval" /> values for inequality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>False if the two date intervals have the same start and end date; true otherwise.</returns>
        </member>
        <member name="M:NodaTime.DateInterval.Equals(NodaTime.DateInterval)">
            <summary>
            Compares the given date interval for equality with this one.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">The date interval to compare this one with.</param>
            <returns>True if this date interval has the same same start and end date as the one specified.</returns>
        </member>
        <member name="M:NodaTime.DateInterval.Equals(System.Object)">
            <summary>
            Compares the given object for equality with this one, as per <see cref="M:NodaTime.DateInterval.Equals(NodaTime.DateInterval)"/>.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The value to compare this one with.</param>
            <returns>true if the other object is a date interval equal to this one, consistent with <see cref="M:NodaTime.DateInterval.Equals(NodaTime.DateInterval)"/>.</returns>
        </member>
        <member name="M:NodaTime.DateInterval.Contains(NodaTime.LocalDate)">
            <summary>
            Checks whether the given date is within this date interval. This requires
            that the date is not earlier than the start date, and not later than the end
            date.
            </summary>
            <param name="date">The date to check for containment within this interval.</param>
            <exception cref="T:System.ArgumentException"><paramref name="date"/> is not in the same
            calendar as the start and end date of this interval.</exception>
            <returns><c>true</c> if <paramref name="date"/> is within this interval; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:NodaTime.DateInterval.Contains(NodaTime.DateInterval)">
            <summary>
            Checks whether the given interval is within this interval. This requires that the start date of the specified
            interval is not earlier than the start date of this interval, and the end date of the specified interval is not
            later than the end date of this interval.
            </summary>
            <remarks>
            An interval contains another interval with same start and end dates, or itself.
            </remarks>
            <param name="interval">The interval to check for containment within this interval.</param>
            <exception cref="T:System.ArgumentException"><paramref name="interval" /> uses a different
            calendar to this date interval.</exception>
            <returns><c>true</c> if <paramref name="interval"/> is within this interval; <c>false</c> otherwise.</returns>
        </member>
        <member name="P:NodaTime.DateInterval.Length">
            <summary>
            Gets the length of this date interval in days. This will always be at least 1.
            </summary>
            <value>The length of this date interval in days.</value>
        </member>
        <member name="P:NodaTime.DateInterval.Calendar">
            <summary>
            Gets the calendar system of the dates in this interval.
            </summary>
            <value>The calendar system of the dates in this interval.</value>
        </member>
        <member name="M:NodaTime.DateInterval.ToString">
            <summary>
            Returns a string representation of this interval.
            </summary>
            <returns>
            A string representation of this interval, as <c>[start, end]</c>,
            where "start" and "end" are the dates formatted using an ISO-8601 compatible pattern.
            </returns>
        </member>
        <member name="M:NodaTime.DateInterval.Deconstruct(NodaTime.LocalDate@,NodaTime.LocalDate@)">
            <summary>
            Deconstruct this date interval into its components.
            </summary>
            <param name="start">The <see cref="T:NodaTime.LocalDate"/> representing the start of the interval.</param>
            <param name="end">The <see cref="T:NodaTime.LocalDate"/> representing the end of the interval.</param>
        </member>
        <member name="M:NodaTime.DateInterval.Intersection(NodaTime.DateInterval)">
            <summary>
            Returns the intersection between the given interval and this interval.
            </summary>
            <param name="interval">
            The specified interval to intersect with this one.
            </param>
            <returns>
            A <see cref="T:NodaTime.DateInterval"/> corresponding to the intersection between the given interval and the current
            instance. If there is no intersection, a null reference is returned.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="interval" /> uses a different
            calendar to this date interval.</exception>
        </member>
        <member name="M:NodaTime.DateInterval.Union(NodaTime.DateInterval)">
            <summary>
            Returns the union between the given interval and this interval, as long as they're overlapping or contiguous.
            </summary>
            <param name="interval">The specified interval from which to generate the union interval.</param>
            <returns>
            A <see cref="T:NodaTime.DateInterval"/> corresponding to the union between the given interval and the current
            instance, in the case the intervals overlap or are contiguous; a null reference otherwise.
            </returns>
            <exception cref="T:System.ArgumentException"><paramref name="interval" /> uses a different calendar to this date interval.</exception>
        </member>
        <member name="M:NodaTime.DateInterval.GetEnumerator">
            <summary>
            Returns an enumerator for the dates in the interval, including both <see cref="P:NodaTime.DateInterval.Start"/> and <see cref="P:NodaTime.DateInterval.End"/>.
            </summary>
            <returns>An enumerator for the interval.</returns>
        </member>
        <member name="M:NodaTime.DateInterval.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.DateTimeZone">
            <summary>
            Represents a time zone - a mapping between UTC and local time. A time zone maps UTC instants to local times
             - or, equivalently, to the offset from UTC at any particular instant.
            </summary>
            <remarks>
            <para>
            The mapping is unambiguous in the "UTC to local" direction, but
            the reverse is not true: when the offset changes, usually due to a Daylight Saving transition,
            the change either creates a gap (a period of local time which never occurs in the time zone)
            or an ambiguity (a period of local time which occurs twice in the time zone). Mapping back from
            local time to an instant requires consideration of how these problematic times will be handled.
            </para>
            <para>
            Noda Time provides various options when mapping local time to a specific instant:
            <list type="bullet">
              <item>
                <description><see cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)"/> will throw an exception if the mapping from local time is either ambiguous
                or impossible, i.e. if there is anything other than one instant which maps to the given local time.</description>
              </item>
              <item>
                <description><see cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)"/> will never throw an exception due to ambiguous or skipped times,
                resolving to the earlier option of ambiguous matches, or to a value that's forward-shifted by the duration
                of the gap for skipped times.</description>
              </item>
              <item>
                <description><see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> will apply a <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/> to the result of
                a mapping.</description>
              </item>
              <item>
                <description><see cref="M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)"/> will return a <see cref="T:NodaTime.TimeZones.ZoneLocalMapping"/>
                with complete information about whether the given local time occurs zero times, once or twice. This is the most
                fine-grained approach, which is the fiddliest to use but puts the caller in the most control.</description>
              </item>
            </list>
            </para>
            <para>
            Noda Time has two built-in sources of time zone data available: a copy of the
            <a href="https://www.iana.org/time-zones">tz database</a> (also known as the IANA Time Zone database, or zoneinfo
            or Olson database), and the ability to convert .NET's own <see cref="T:System.TimeZoneInfo"/> format into a "native" Noda
            Time zone. Which of these is most appropriate for you to use will very much depend on your exact needs. The
            zoneinfo database is widely used outside Windows, and has more historical data than the Windows-provided
            information, but if you need to interoperate with other Windows systems by specifying time zone IDs, you may
            wish to stick to the Windows time zones.
            </para>
            <para>
            To obtain a <see cref="T:NodaTime.DateTimeZone"/> for a given timezone ID, use one of the methods on
            <see cref="T:NodaTime.IDateTimeZoneProvider"/> (and see <see cref="T:NodaTime.DateTimeZoneProviders"/> for access to the built-in
            providers). The UTC timezone is also available via the <see cref="P:NodaTime.DateTimeZone.Utc"/> property on this class.
            </para>
            <para>
            To obtain a <see cref="T:NodaTime.DateTimeZone"/> representing the system default time zone, you can either call
            <see cref="M:NodaTime.IDateTimeZoneProvider.GetSystemDefault"/> on a provider to obtain the <see cref="T:NodaTime.DateTimeZone"/> that
            the provider considers matches the system default time zone, or you can construct a
            <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/> via <see cref="M:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault"/>, which returns a
            <see cref="T:NodaTime.DateTimeZone"/> that wraps the system local <see cref="T:System.TimeZoneInfo"/>. The latter will always
            succeed, but has access only to that information available via the .NET time zone; the former may contain more
            complete data, but may (in uncommon cases) fail to find a matching <see cref="T:NodaTime.DateTimeZone"/>.
            Note that <c>BclDateTimeZone</c> may not be available in all versions of Noda Time 1.x and 2.x; see the class
            documentation for more details.
            </para>
            <para>
            Note that Noda Time does not require that <see cref="T:NodaTime.DateTimeZone"/> instances be singletons.
            Comparing two time zones for equality is not straightforward: if you care about whether two
            zones act the same way within a particular portion of time, use <see cref="T:NodaTime.TimeZones.ZoneEqualityComparer"/>.
            Additional guarantees are provided by <see cref="T:NodaTime.IDateTimeZoneProvider"/> and <see cref="M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)"/>.
            </para>
            </remarks>
            <threadsafety>
            All time zone implementations within Noda Time are immutable and thread-safe.
            See the thread safety section of the user guide for more information.
            It is expected that third party implementations will be immutable and thread-safe as well:
            code within Noda Time assumes that it can hand out time zones to any thread without any concerns. If you
            implement a non-thread-safe time zone, you will need to use it extremely carefully. We'd recommend that you
            avoid this if possible.
            </threadsafety>
        </member>
        <member name="F:NodaTime.DateTimeZone.UtcId">
            <summary>
            The ID of the UTC (Coordinated Universal Time) time zone. This ID is always valid, whatever provider is
            used. If the provider has its own mapping for UTC, that will be returned by <see cref="M:NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull(System.String)" />, but otherwise
            the value of the <see cref="P:NodaTime.DateTimeZone.Utc"/> property will be returned.
            </summary>
        </member>
        <member name="P:NodaTime.DateTimeZone.Utc">
            <summary>
            Gets the UTC (Coordinated Universal Time) time zone.
            </summary>
            <remarks>
            This is a single instance which is not provider-specific; it is guaranteed to have the ID "UTC", and to
            compare equal to an instance returned by calling <see cref="M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)"/> with an offset of zero, but it may
            or may not compare equal to an instance returned by e.g. <c>DateTimeZoneProviders.Tzdb["UTC"]</c>.
            </remarks>
            <value>A UTC <see cref="T:NodaTime.DateTimeZone" />.</value>
        </member>
        <member name="M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)">
            <summary>
            Returns a fixed time zone with the given offset.
            </summary>
            <remarks>
            <para>
            The returned time zone will have an ID of "UTC" if the offset is zero, or "UTC+/-Offset"
            otherwise. In the former case, the returned instance will be equal to <see cref="P:NodaTime.DateTimeZone.Utc"/>.
            </para>
            <para>
            Note also that this method is not required to return the same <see cref="T:NodaTime.DateTimeZone"/> instance for
            successive requests for the same offset; however, all instances returned for a given offset will compare
            as equal.
            </para>
            </remarks>
            <param name="offset">The offset for the returned time zone</param>
            <returns>A fixed time zone with the given offset.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.#ctor(System.String,System.Boolean,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.DateTimeZone" /> class.
            </summary>
            <param name="id">The unique id of this time zone.</param>
            <param name="isFixed">Set to <c>true</c> if this time zone has no transitions.</param>
            <param name="minOffset">Minimum offset applied within this zone</param>
            <param name="maxOffset">Maximum offset applied within this zone</param>
        </member>
        <member name="P:NodaTime.DateTimeZone.Id">
            <summary>
            Get the provider's ID for the time zone.
            </summary>
            <remarks>
            <para>
            This identifies the time zone within the current time zone provider; a different provider may
            provide a different time zone with the same ID, or may not provide a time zone with that ID at all.
            </para>
            </remarks>
            <value>The provider's ID for the time zone.</value>
        </member>
        <member name="P:NodaTime.DateTimeZone.IsFixed">
            <summary>
            Indicates whether the time zone is fixed, i.e. contains no transitions.
            </summary>
            <remarks>
            This is used as an optimization. If the time zone has no transitions but returns <c>false</c>
            for this then the behavior will be correct but the system will have to do extra work. However
            if the time zone has transitions and this returns <c>true</c> then the transitions will never
            be examined.
            </remarks>
            <value>true if the time zone is fixed; false otherwise.</value>
        </member>
        <member name="P:NodaTime.DateTimeZone.MinOffset">
            <summary>
            Gets the least (most negative) offset within this time zone, over all time.
            </summary>
            <value>The least (most negative) offset within this time zone, over all time.</value>
        </member>
        <member name="P:NodaTime.DateTimeZone.MaxOffset">
            <summary>
            Gets the greatest (most positive) offset within this time zone, over all time.
            </summary>
            <value>The greatest (most positive) offset within this time zone, over all time.</value>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)">
            <summary>
            Returns the offset from UTC, where a positive duration indicates that local time is
            later than UTC. In other words, local time = UTC + offset.
            </summary>
            <remarks>
            This is mostly a convenience method for calling <c>GetZoneInterval(instant).WallOffset</c>,
            although it can also be overridden for more efficiency.
            </remarks>
            <param name="instant">The instant for which to calculate the offset.</param>
            <returns>
            The offset from UTC at the specified instant.
            </returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone interval for the given instant; the range of time around the instant in which the same Offset
            applies (with the same split between standard time and daylight saving time, and with the same offset).
            </summary>
            <remarks>
            This will always return a valid zone interval, as time zones cover the whole of time.
            </remarks>
            <param name="instant">The <see cref="T:NodaTime.Instant" /> to query.</param>
            <returns>The defined <see cref="T:NodaTime.TimeZones.ZoneInterval" />.</returns>
            <seealso cref="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)"/>
        </member>
        <member name="M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)">
            <summary>
            Returns complete information about how the given <see cref="T:NodaTime.LocalDateTime" /> is mapped in this time zone.
            </summary>
            <remarks>
            <para>
            Mapping a local date/time to a time zone can give an unambiguous, ambiguous or impossible result, depending on
            time zone transitions. Use the return value of this method to handle these cases in an appropriate way for
            your use case.
            </para>
            <para>
            As an alternative, consider <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/>, which uses a caller-provided strategy to
            convert the <see cref="T:NodaTime.TimeZones.ZoneLocalMapping"/> returned here to a <see cref="T:NodaTime.ZonedDateTime"/>.
            </para>
            </remarks>
            <param name="localDateTime">The local date and time to map in this time zone.</param>
            <returns>A mapping of the given local date and time to zero, one or two zoned date/time values.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)">
            <summary>
            Returns the earliest valid <see cref="T:NodaTime.ZonedDateTime"/> with the given local date.
            </summary>
            <remarks>
            If midnight exists unambiguously on the given date, it is returned.
            If the given date has an ambiguous start time (e.g. the clocks go back from 1am to midnight)
            then the earlier ZonedDateTime is returned. If the given date has no midnight (e.g. the clocks
            go forward from midnight to 1am) then the earliest valid value is returned; this will be the instant
            of the transition.
            </remarks>
            <param name="date">The local date to map in this time zone.</param>
            <exception cref="T:NodaTime.SkippedTimeException">The entire day was skipped due to a very large time zone transition.
            (This is extremely rare.)</exception>
            <returns>The <see cref="T:NodaTime.ZonedDateTime"/> representing the earliest time in the given date, in this time zone.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)">
            <summary>
            Maps the given <see cref="T:NodaTime.LocalDateTime"/> to the corresponding <see cref="T:NodaTime.ZonedDateTime"/>, following
            the given <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/> to handle ambiguity and skipped times.
            </summary>
            <remarks>
            <para>
            This is a convenience method for calling <see cref="M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)"/> and passing the result to the resolver.
            Common options for resolvers are provided in the static <see cref="T:NodaTime.TimeZones.Resolvers"/> class.
            </para>
            <para>
            See <see cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)"/> and <see cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)"/> for alternative ways to map a local time to a
            specific instant.
            </para>
            </remarks>
            <param name="localDateTime">The local date and time to map in this time zone.</param>
            <param name="resolver">The resolver to apply to the mapping.</param>
            <returns>The result of resolving the mapping.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)">
            <summary>
            Maps the given <see cref="T:NodaTime.LocalDateTime"/> to the corresponding <see cref="T:NodaTime.ZonedDateTime"/>, if and only if
            that mapping is unambiguous in this time zone.  Otherwise, <see cref="T:NodaTime.SkippedTimeException"/> or
            <see cref="T:NodaTime.AmbiguousTimeException"/> is thrown, depending on whether the mapping is ambiguous or the local
            date/time is skipped entirely.
            </summary>
            <remarks>
            See <see cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)"/> and <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> for alternative ways to map a local time to a
            specific instant.
            </remarks>
            <param name="localDateTime">The local date and time to map into this time zone.</param>
            <exception cref="T:NodaTime.SkippedTimeException">The given local date/time is skipped in this time zone.</exception>
            <exception cref="T:NodaTime.AmbiguousTimeException">The given local date/time is ambiguous in this time zone.</exception>
            <returns>The unambiguous matching <see cref="T:NodaTime.ZonedDateTime"/> if it exists.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)">
            <summary>
            Maps the given <see cref="T:NodaTime.LocalDateTime"/> to the corresponding <see cref="T:NodaTime.ZonedDateTime"/> in a lenient
            manner: ambiguous values map to the earlier of the alternatives, and "skipped" values are shifted forward
            by the duration of the "gap".
            </summary>
            <remarks>
            See <see cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)"/> and <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> for alternative ways to map a local time to a
            specific instant.
            <para>Note: The behavior of this method was changed in version 2.0 to fit the most commonly seen real-world
            usage pattern.  Previous versions returned the later instance of ambiguous values, and returned the start of
            the zone interval after the gap for skipped value.  The previous functionality can still be used if desired,
            by using <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/>, passing in a resolver
            created from <see cref="P:NodaTime.TimeZones.Resolvers.ReturnLater"/> and <see cref="P:NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter"/>.</para>
            </remarks>
            <param name="localDateTime">The local date/time to map.</param>
            <returns>The unambiguous mapping if there is one, the earlier result if the mapping is ambiguous,
            or the forward-shifted value if the given local date/time is skipped.</returns>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetEarlierMatchingInterval(NodaTime.TimeZones.ZoneInterval,NodaTime.LocalInstant)">
            <summary>
            Returns the interval before this one, if it contains the given local instant, or null otherwise.
            </summary>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetLaterMatchingInterval(NodaTime.TimeZones.ZoneInterval,NodaTime.LocalInstant)">
            <summary>
            Returns the next interval after this one, if it contains the given local instant, or null otherwise.
            </summary>
        </member>
        <member name="M:NodaTime.DateTimeZone.ToString">
            <summary>
            Returns the ID of this time zone.
            </summary>
            <returns>
            The ID of this time zone.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.DateTimeZone.BuildFixedZoneCache">
            <summary>
            Creates a fixed time zone for offsets -12 to +15 at every half hour,
            fixing the 0 offset as DateTimeZone.Utc.
            </summary>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Returns all the zone intervals which occur for any instant in the interval [<paramref name="start"/>, <paramref name="end"/>).
            </summary>
            <remarks>
            <para>This method is simply a convenience method for calling <see cref="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)"/> without
            explicitly constructing the interval beforehand.
            </para>
            </remarks>
            <param name="start">Inclusive start point of the interval for which to retrieve zone intervals.</param>
            <param name="end">Exclusive end point of the interval for which to retrieve zone intervals.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="end"/> is earlier than <paramref name="start"/>.</exception>
            <returns>A sequence of zone intervals covering the given interval.</returns>
            <seealso cref="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)"/>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)">
            <summary>
            Returns all the zone intervals which occur for any instant in the given interval.
            </summary>
            <remarks>
            <para>The zone intervals are returned in chronological order.
            This method is equivalent to calling <see cref="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)"/> for every
            instant in the interval and then collapsing to a set of distinct zone intervals.
            The first and last zone intervals are likely to also cover instants outside the given interval;
            the zone intervals returned are not truncated to match the start and end points.
            </para>
            </remarks>
            <param name="interval">Interval to find zone intervals for. This is allowed to be unbounded (i.e.
            infinite in both directions).</param>
            <returns>A sequence of zone intervals covering the given interval.</returns>
            <seealso cref="M:NodaTime.DateTimeZone.GetZoneInterval(NodaTime.Instant)"/>
        </member>
        <member name="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval,NodaTime.TimeZones.ZoneEqualityComparer.Options)">
            <summary>
            Returns the zone intervals within the given interval, potentially coalescing some of the
            original intervals according to options.
            </summary>
            <remarks>
            <para>
            This is equivalent to <see cref="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)"/>, but may coalesce some intervals.
            For example, if the <see cref="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset"/> is specified,
            and two consecutive zone intervals have the same offset but different names, a single zone interval
            will be returned instead of two separate ones. When zone intervals are coalesced, all aspects of
            the first zone interval are used except its end instant, which is taken from the second zone interval.
            </para>
            <para>
            As the options are only used to determine which intervals to coalesce, the
            <see cref="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions"/> option does not affect
            the intervals returned.
            </para>
            </remarks>
            <param name="interval">Interval to find zone intervals for. This is allowed to be unbounded (i.e.
            infinite in both directions).</param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="T:NodaTime.DateTimeZoneProviders">
            <summary>
            Static access to date/time zone providers built into Noda Time and for global configuration where this is unavoidable.
            All properties are thread-safe, and the providers returned by the read-only properties cache their results.
            </summary>
        </member>
        <member name="P:NodaTime.DateTimeZoneProviders.Tzdb">
            <summary>
            Gets a time zone provider which uses a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/>.
            The underlying source is <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Default"/>, which is initialized from
            resources within the NodaTime assembly.
            </summary>
            <value>A time zone provider using a <c>TzdbDateTimeZoneSource</c>.</value>
        </member>
        <member name="P:NodaTime.DateTimeZoneProviders.Bcl">
            <summary>
            Gets a time zone provider which uses a <see cref="T:NodaTime.TimeZones.BclDateTimeZoneSource"/>.
            </summary>
            <remarks>
            <para>
            See note on <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/> for details of some incompatibilities with the BCL.
            </para>
            <para>
            In Noda Time 1.x and 2.x, this property is only available on the .NET Framework builds of Noda Time, and not
            the PCL (Noda Time 1.x) or .NET Standard 1.3 (Noda Time 2.x) builds.
            </para>
            </remarks>
            <value>A time zone provider which uses a <c>BclDateTimeZoneSource</c>.</value>
        </member>
        <member name="P:NodaTime.DateTimeZoneProviders.Serialization">
            <summary>
            Gets the <see cref="T:NodaTime.IDateTimeZoneProvider"/> to use to interpret a time zone ID read as part of
            XML serialization. This property is obsolete as of version 3.0; the functionality still exists
            in <see cref="P:NodaTime.Xml.XmlSerializationSettings.DateTimeZoneProvider"/>, which this property delegates
            to. (The behavior has not changed; this is purely an exercise in moving/renaming.)
            </summary>
        </member>
        <member name="T:NodaTime.Duration">
            <summary>
            Represents a fixed (and calendar-independent) length of time.
            </summary>
            <remarks>
            <para>
            A duration is a length of time defined by an integral number of nanoseconds.
            Although durations are usually used with a positive number of nanoseconds, negative durations are valid, and may occur
            naturally when e.g. subtracting a later <see cref="T:NodaTime.Instant"/> from an earlier one.
            </para>
            <para>Equality and ordering are defined in the natural way, simply comparing the number of nanoseconds contained.</para>
            <para>
            A duration represents a fixed length of elapsed time along the time line that occupies the same amount of
            time regardless of when it is applied. In contrast, <see cref="T:NodaTime.Period"/> represents a period of time in
            calendrical terms (years, months, days, and so on) that may vary in elapsed time when applied.
            </para>
            <para>
            In general, use <see cref="T:NodaTime.Duration"/> to represent durations applied to global types like <see cref="T:NodaTime.Instant"/>
            and <see cref="T:NodaTime.ZonedDateTime"/>; use <c>Period</c> to represent a period applied to local types like
            <see cref="T:NodaTime.LocalDateTime"/>.
            </para>
            <para>
            The range of valid values of a <c>Duration</c> is greater than the span of time supported by Noda Time - so for
            example, subtracting one <see cref="T:NodaTime.Instant"/> from another will always give a valid <c>Duration</c>. The range
            is also greater than that of <see cref="T:System.TimeSpan"/> (<see cref="F:System.Int64.MinValue" /> ticks to <see cref="F:System.Int64.MaxValue"/> ticks).
            See the user guide for more details of the exact range, but it is not expected that this will ever be exceeded in normal code.
            </para>
            <para>
            Various operations accept or return a <see cref="T:System.Double"/>, in-keeping with durations often being natural lengths
            of time which are imprecisely measured anyway. The implementation of these operations should never result in a not-a-number
            or infinite value, nor do any operations accept not-a-number or infinite values. Additionally, operations involving
            <c>Double</c> have initially been implemented fairly naively; it's possible that future releases will improve the accuracy
            or performance (or both) of various operations.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.Duration.Zero">
            <summary>
            Gets a zero <see cref="T:NodaTime.Duration"/> of 0 nanoseconds.
            </summary>
            <value>The zero <see cref="T:NodaTime.Duration"/> value.</value>
        </member>
        <member name="P:NodaTime.Duration.Epsilon">
            <summary>
            Gets a <see cref="T:NodaTime.Duration"/> value equal to 1 nanosecond; the smallest amount by which an instant can vary.
            </summary>
            <value>A duration representing 1 nanosecond.</value>
        </member>
        <member name="P:NodaTime.Duration.MaxValue">
            <summary>
            Gets the maximum value supported by <see cref="T:NodaTime.Duration"/>.
            </summary>
        </member>
        <member name="P:NodaTime.Duration.MinValue">
            <summary>
            Gets the minimum (largest negative) value supported by <see cref="T:NodaTime.Duration"/>.
            </summary>
        </member>
        <member name="P:NodaTime.Duration.OneWeek">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equal to the number of nanoseconds in 1 standard week (7 days).
            </summary>
            <remarks>
            The value of this property is 604,800,000,000,000 nanoseconds.
            </remarks>
        </member>
        <member name="P:NodaTime.Duration.OneDay">
            <summary>
            Represents the <see cref="T:NodaTime.Duration"/> value equal to the number of nanoseconds in 1 day.
            </summary>
            <remarks>
            The value of this property is 86.4 trillion nanoseconds; that is, 86,400,000,000,000 nanoseconds.
            </remarks>
        </member>
        <member name="M:NodaTime.Duration.#ctor(System.Int64,System.String,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Constructs an instance from a given number of units. This was previously a method (FromUnits) but making it a
            constructor avoids calling the other constructor which validates its "days" parameter.
            Note that we could compute various parameters from nanosPerUnit, but we know them as compile-time constants, so
            there's no point in recomputing them on each call.
            </summary>
            <param name="units">Number of units</param>
            <param name="paramName">Name of the parameter, e.g. "hours"</param>
            <param name="minValue">Minimum number of units for a valid duration.</param>
            <param name="maxValue">Maximum number of units for a valid duration.</param>
            <param name="unitsPerDay">Number of units in a day.</param>
            <param name="nanosPerUnit">Number of nanoseconds per unit.</param>
        </member>
        <member name="P:NodaTime.Duration.FloorDays">
            <summary>
            Days portion of this duration. The <see cref="P:NodaTime.Duration.NanosecondOfFloorDay" /> is added to this
            value, so this effectively Math.Floor(TotalDays).
            </summary>
        </member>
        <member name="P:NodaTime.Duration.NanosecondOfFloorDay">
            <summary>
            Nanosecond within the "floor day". This is *always* non-negative, even for
            negative durations.
            </summary>
        </member>
        <member name="P:NodaTime.Duration.Days">
            <summary>
            Gets the whole number of standard (24 hour) days within this duration. This is truncated towards zero;
            for example, "-1.75 days" and "1.75 days" would have results of -1 and 1 respectively.
            </summary>
            <value>The whole number of days in the duration</value>
        </member>
        <member name="P:NodaTime.Duration.NanosecondOfDay">
            <summary>
            Gets the number of nanoseconds within the day of this duration. For negative durations, this
            will be negative (or zero).
            </summary>
            <value>The number of nanoseconds within the day of this duration.</value>
        </member>
        <member name="P:NodaTime.Duration.Hours">
            <summary>
            The hour component of this duration, in the range [-23, 23], truncated towards zero.
            </summary>
            <value>The hour component of the duration, within the day.</value>
        </member>
        <member name="P:NodaTime.Duration.Minutes">
            <summary>
            The minute component of this duration, in the range [-59, 59], truncated towards zero.
            </summary>
            <value>The minute component of the duration, within the hour.</value>
        </member>
        <member name="P:NodaTime.Duration.Seconds">
            <summary>
            Gets the second component of this duration, in the range [-59, 59], truncated towards zero.
            </summary>
            <value>The second component of the duration, within the minute.</value>
        </member>
        <member name="P:NodaTime.Duration.Milliseconds">
            <summary>
            Gets the subsecond component of this duration, expressed in milliseconds, in the range [-999, 999] and truncated towards zero.
            </summary>
            <value>The subsecond component of the duration, in milliseconds.</value>
        </member>
        <member name="P:NodaTime.Duration.SubsecondTicks">
            <summary>
            Gets the subsecond component of this duration, expressed in ticks, in the range [-9999999, 9999999] and truncated towards zero.
            </summary>
            <value>The subsecond component of the duration, in ticks.</value>
        </member>
        <member name="P:NodaTime.Duration.SubsecondNanoseconds">
            <summary>
            Gets the subsecond component of this duration, expressed in nanoseconds, in the range [-999999999, 999999999].
            </summary>
            <value>The subsecond component of the duration, in nanoseconds.</value>
        </member>
        <member name="P:NodaTime.Duration.BclCompatibleTicks">
            <summary>
            Gets the total number of ticks in the duration as a 64-bit integer, truncating towards zero where necessary.
            </summary>
            <remarks>
            <para>
            Within the constraints specified below, this property is intended to be equivalent to
            <see cref="P:System.TimeSpan.Ticks"/>.
            </para>
            <para>
            If the number of nanoseconds in a duration is not a whole number of ticks, it is truncated towards zero.
            For example, durations in the range [-99ns, 99ns] would all count as 0 ticks.
            </para>
            <para>Although this method can overflow, it will only do so in very exceptional cases, with durations
            with a magnitude of more than 29000 Gregorian years or so.</para>
            </remarks>
            <exception cref="T:System.OverflowException">The number of ticks cannot be represented a signed 64-bit integer.</exception>
            <value>The total number of ticks in the duration.</value>
            <seealso cref="P:NodaTime.Duration.TotalTicks"/>
        </member>
        <member name="P:NodaTime.Duration.TotalDays">
            <summary>
            Gets the total number of days in this duration, as a <see cref="T:System.Double"/>.
            </summary>
            <remarks>This property is the <c>Duration</c> equivalent of <see cref="P:System.TimeSpan.TotalDays"/>.
            It represents the complete duration in days, rather than only the whole number of
            days. For example, for a duration of 36 hours, this property would return 1.5.
            </remarks>
            <value>The total number of days in this duration.</value>
        </member>
        <member name="P:NodaTime.Duration.TotalHours">
            <summary>
            Gets the total number of hours in this duration, as a <see cref="T:System.Double"/>.
            </summary>
            <remarks>
            This property is the <c>Duration</c> equivalent of <see cref="P:System.TimeSpan.TotalHours"/>.
            Unlike <see cref="P:NodaTime.Duration.Hours"/>, it represents the complete duration in hours rather than the
            whole number of hours as part of the day. So for a duration
            of 1 day, 2 hours and 30 minutes, the <c>Hours</c> property will return 2, but <c>TotalHours</c>
            will return 26.5.
            </remarks>
            <value>The total number of hours in this duration.</value>
        </member>
        <member name="P:NodaTime.Duration.TotalMinutes">
            <summary>
            Gets the total number of minutes in this duration, as a <see cref="T:System.Double"/>.
            </summary>
            <remarks>This property is the <c>Duration</c> equivalent of <see cref="P:System.TimeSpan.TotalMinutes"/>.
            Unlike <see cref="P:NodaTime.Duration.Minutes"/>, it represents the complete duration in minutes rather than
            the whole number of minutes within the hour. So for a duration
            of 2 hours, 30 minutes and 45 seconds, the <c>Minutes</c> property will return 30, but <c>TotalMinutes</c>
            will return 150.75.
            </remarks>
            <value>The total number of minutes in this duration.</value>
        </member>
        <member name="P:NodaTime.Duration.TotalSeconds">
            <summary>
            Gets the total number of seconds in this duration, as a <see cref="T:System.Double"/>.
            </summary>
            <remarks>
            This property is the <c>Duration</c> equivalent of <see cref="P:System.TimeSpan.TotalSeconds"/>.
            Unlike <see cref="P:NodaTime.Duration.Seconds"/>, it represents the complete duration in seconds rather than
            the whole number of seconds within the minute. So for a duration
            of 10 minutes, 20 seconds and 250 milliseconds, the <c>Seconds</c> property will return 20, but <c>TotalSeconds</c>
            will return 620.25.
            </remarks>
            <value>The total number of seconds in this duration.</value>
        </member>
        <member name="P:NodaTime.Duration.TotalMilliseconds">
            <summary>
            Gets the total number of milliseconds in this duration, as a <see cref="T:System.Double"/>.
            </summary>
            <remarks>This property is the <c>Duration</c> equivalent of <see cref="P:System.TimeSpan.TotalMilliseconds"/>.
            Unlike <see cref="P:NodaTime.Duration.Milliseconds"/>, it represents the complete duration in seconds rather than
            the whole number of seconds within the minute. So for a duration
            of 10 minutes, 20 seconds and 250 milliseconds, the <c>Seconds</c> property will return 20, but <c>TotalSeconds</c>
            will return 620.25.
            </remarks>
            <value>The total number of milliseconds in this duration.</value>
        </member>
        <member name="P:NodaTime.Duration.TotalTicks">
            <summary>
            Gets the total number of ticks in this duration, as a <see cref="T:System.Double"/>.
            </summary>
            <remarks>This property is the <c>Duration</c> equivalent of <see cref="P:System.TimeSpan.Ticks"/>,
            except represented as double-precision floating point number instead of a 64-bit integer. This
            is because <see cref="T:NodaTime.Duration"/> has a precision of nanoseconds, and also because the range
            of 64-bit integers doesn't cover the number of possible ticks in a <see cref="T:NodaTime.Duration"/>. (The
            latter is only an issue in durations outside the range of <see cref="T:System.TimeSpan"/> - in other words,
            with magnitudes of over 29,000 years.)
            </remarks>
            <value>The total number of ticks in this duration.</value>
            <seealso cref="P:NodaTime.Duration.BclCompatibleTicks"/>
        </member>
        <member name="P:NodaTime.Duration.TotalNanoseconds">
            <summary>
            Gets the total number of nanoseconds in this duration, as a <see cref="T:System.Double"/>.
            </summary>
            <remarks>The result is always an integer, but may not be precise due to the limitations
            of the <c>Double</c> type. In other works, <c>Duration.FromNanoseconds(duration.TotalNanoseconds)</c>
            is not guaranteed to round-trip. To guarantee precision and round-tripping,
            use <see cref="M:NodaTime.Duration.ToBigIntegerNanoseconds" /> and <see cref="M:NodaTime.Duration.FromNanoseconds(System.Numerics.BigInteger)"/>.
            </remarks>
            <returns>This duration as a number of nanoseconds, represented as a <c>Double</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.PlusSmallNanoseconds(System.Int64)">
            <summary>
            Adds a "small" number of nanoseconds to this duration: it is trusted to be less or equal to than 24 hours
            in magnitude.
            </summary>
        </member>
        <member name="M:NodaTime.Duration.MinusSmallNanoseconds(System.Int64)">
            <summary>
            Subtracts a "small" number of nanoseconds from this duration: it is trusted to be less than 24 hours
            in magnitude.
            </summary>
        </member>
        <member name="M:NodaTime.Duration.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.Duration.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.Duration.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("o"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.Duration.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("o").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Duration.op_Addition(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator + (addition).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Add(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Adds one duration to another. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Plus(NodaTime.Duration)">
            <summary>
            Returns the result of adding another duration to this one, for a fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="other">The duration to add</param>
            <returns>A new <see cref="T:NodaTime.Duration" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Subtraction(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator - (subtraction).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Subtract(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Subtracts one duration from another. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Minus(NodaTime.Duration)">
            <summary>
            Returns the result of subtracting another duration from this one, for a fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="other">The duration to subtract</param>
            <returns>A new <see cref="T:NodaTime.Duration" /> representing the result of the subtraction.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Division(NodaTime.Duration,System.Int64)">
            <summary>
            Implements the operator / (division) to divide a duration by an <see cref="T:System.Int64"/>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the result of dividing <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Division(NodaTime.Duration,System.Double)">
            <summary>
            Implements the operator / (division) to divide a duration by a <see cref="T:System.Double"/>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the result of dividing <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Division(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator / (division) to divide one duration by another.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>The <see cref="T:System.Double"/> representing the result of dividing <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.Divide(NodaTime.Duration,System.Int64)">
            <summary>
            Divides a duration by an <see cref="T:System.Int64"/>. Friendly alternative to <c>operator/()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the result of dividing <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.Divide(NodaTime.Duration,System.Double)">
            <summary>
            Divides a duration by a <see cref="T:System.Double"/>. Friendly alternative to <c>operator/()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the result of dividing <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.Divide(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Divides one duration by another. Friendly alternative to <c>operator/()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>The <see cref="T:System.Double"/> representing the result of dividing <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Multiply(NodaTime.Duration,System.Double)">
            <summary>
            Implements the operator * (multiplication).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the result of multiplying <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Multiply(NodaTime.Duration,System.Int64)">
            <summary>
            Implements the operator * (multiplication).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the result of multiplying <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Multiply(System.Int64,NodaTime.Duration)">
            <summary>
            Implements the operator * (multiplication).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the result of multiplying <paramref name="left"/> by
            <paramref name="right"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.Multiply(NodaTime.Duration,System.Int64)">
            <summary>
            Multiplies a duration by a number. Friendly alternative to <c>operator*()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the product of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Multiply(NodaTime.Duration,System.Double)">
            <summary>
            Multiplies a duration by a number. Friendly alternative to <c>operator*()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the product of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.Multiply(System.Int64,NodaTime.Duration)">
            <summary>
            Multiplies a duration by a number. Friendly alternative to <c>operator*()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration"/> representing the product of the given values.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Equality(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator == (equality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_Inequality(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator != (inequality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_LessThan(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator &lt; (less than).
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_LessThanOrEqual(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator &lt;= (less than or equal).
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_GreaterThan(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator &gt; (greater than).
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_GreaterThanOrEqual(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Implements the operator &gt;= (greater than or equal).
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.op_UnaryNegation(NodaTime.Duration)">
            <summary>
            Implements the unary negation operator.
            </summary>
            <param name="duration">Duration to negate</param>
            <returns>The negative value of this duration</returns>
        </member>
        <member name="M:NodaTime.Duration.Negate(NodaTime.Duration)">
            <summary>
            Implements a friendly alternative to the unary negation operator.
            </summary>
            <param name="duration">Duration to negate</param>
            <returns>The negative value of this duration</returns>
        </member>
        <member name="M:NodaTime.Duration.CompareTo(NodaTime.Duration)">
            <summary>
            Implementation of <see cref="M:System.IComparable`1.CompareTo(`0)"/> to compare two durations.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared.
            The return value has the following meanings:
            <list type="table">
            <listheader>
            <term>Value</term>
            <description>Meaning</description>
            </listheader>
            <item>
            <term>&lt; 0</term>
            <description>This object is less than the <paramref name="other"/> parameter.</description>
            </item>
            <item>
            <term>0</term>
            <description>This object is equal to <paramref name="other"/>.</description>
            </item>
            <item>
            <term>&gt; 0</term>
            <description>This object is greater than <paramref name="other"/>.</description>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:NodaTime.Duration.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two durations.
            See the type documentation for a description of ordering semantics.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.Duration"/>.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this instant with another one; see <see cref="M:NodaTime.Duration.CompareTo(NodaTime.Duration)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.Duration.Equals(NodaTime.Duration)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.Duration.FromDays(System.Int32)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of days, assuming a 'standard' 24-hour
            day.
            </summary>
            <param name="days">The number of days.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of days.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromDays(System.Double)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of days, assuming a 'standard' 24-hour
            day.
            </summary>
            <param name="days">The number of days.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of days.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromHours(System.Int32)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of hours.
            </summary>
            <param name="hours">The number of hours.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of hours.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromHours(System.Double)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of hours.
            </summary>
            <param name="hours">The number of hours.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of hours.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromMinutes(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of minutes.
            </summary>
            <param name="minutes">The number of minutes.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of minutes.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromMinutes(System.Double)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of minutes.
            </summary>
            <param name="minutes">The number of minutes.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of minutes.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromSeconds(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of seconds.
            </summary>
            <param name="seconds">The number of seconds.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of seconds.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromSeconds(System.Double)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of seconds.
            </summary>
            <param name="seconds">The number of seconds.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of seconds.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromMilliseconds(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of milliseconds.
            </summary>
            <param name="milliseconds">The number of milliseconds.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of milliseconds.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromMilliseconds(System.Double)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of milliseconds.
            </summary>
            <param name="milliseconds">The number of milliseconds.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of milliseconds.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromTicks(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of ticks.
            </summary>
            <param name="ticks">The number of ticks.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of ticks.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromTicks(System.Double)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of ticks.
            </summary>
            <param name="ticks">The number of ticks.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of ticks.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromNanoseconds(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the given number of nanoseconds.
            </summary>
            <param name="nanoseconds">The number of nanoseconds.</param>
            <returns>A <see cref="T:NodaTime.Duration"/> representing the given number of nanoseconds.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromNanoseconds(System.Double)">
            <summary>
            Converts a number of nanoseconds expressed as a <see cref="T:System.Double"/> into a duration. Any fractional
            parts of the value are truncated towards zero.
            </summary>
            <param name="nanoseconds">The number of nanoseconds to represent.</param>
            <returns>A duration with the given number of nanoseconds.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromNanoseconds(System.Numerics.BigInteger)">
            <summary>
            Converts a number of nanoseconds expressed as a <see cref="T:System.Numerics.BigInteger"/> into a duration.
            </summary>
            <param name="nanoseconds">The number of nanoseconds to represent.</param>
            <returns>A duration with the given number of nanoseconds.</returns>
        </member>
        <member name="M:NodaTime.Duration.FromTimeSpan(System.TimeSpan)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> that represents the same number of ticks as the
            given <see cref="T:System.TimeSpan"/>.
            </summary>
            <param name="timeSpan">The TimeSpan value to convert</param>
            <returns>A new Duration with the same number of ticks as the given TimeSpan.</returns>
        </member>
        <member name="M:NodaTime.Duration.ToTimeSpan">
            <summary>
            Returns a <see cref="T:System.TimeSpan"/> that represents the same number of ticks as this
            <see cref="T:NodaTime.Duration"/>.
            </summary>
            <remarks>
            If the number of nanoseconds in a duration is not a whole number of ticks, it is truncated towards zero.
            For example, durations in the range [-99ns, 99ns] would all count as 0 ticks.
            </remarks>
            <exception cref="T:System.OverflowException">The number of ticks cannot be represented a signed 64-bit integer.</exception>
            <returns>A new TimeSpan with the same number of ticks as this Duration.</returns>
        </member>
        <member name="M:NodaTime.Duration.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.Duration"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Duration.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Duration.ToInt64Nanoseconds">
            <summary>
            Conversion to an <see cref="T:System.Int64"/> number of nanoseconds. This will fail if the number of nanoseconds is
            out of the range of <c>Int64</c>, which is approximately 292 years (positive or negative).
            </summary>
            <exception cref="T:System.OverflowException">The number of nanoseconds is outside the representable range.</exception>
            <returns>This duration as a number of nanoseconds, represented as an <c>Int64</c>.</returns>
        </member>
        <member name="P:NodaTime.Duration.IsInt64Representable">
            <summary>
            A quick check to tell whether this duration is within the range of an Int64 value of nanoseconds
            (roughly +/- 292 years). This is conservative as it only checks the days field -
            there may be values just within Int64 range for which this property returns true, but they're
            unlikely to come up... this property should *only* be used for optimization purposes.
            </summary>
        </member>
        <member name="M:NodaTime.Duration.ToInt64NanosecondsUnchecked">
            <summary>
            Performs an unchecked conversion from this duration to an Int64 value of nanoseconds.
            This should only be called if IsInt64Representable returns true.
            </summary>
        </member>
        <member name="M:NodaTime.Duration.ToBigIntegerNanoseconds">
            <summary>
            Conversion to a <see cref="T:System.Numerics.BigInteger"/> number of nanoseconds, as a convenient built-in numeric
            type which can always represent values in the range we need.
            </summary>
            <returns>This duration as a number of nanoseconds, represented as a <c>BigInteger</c>.</returns>
        </member>
        <member name="M:NodaTime.Duration.Max(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Returns the larger duration of the given two.
            </summary>
            <remarks>
            A "larger" duration is one that advances time by more than a "smaller" one. This means
            that a positive duration is always larger than a negative one, for example. (This is the same
            comparison used by the binary comparison operators.)
            </remarks>
            <param name="x">The first duration to compare.</param>
            <param name="y">The second duration to compare.</param>
            <returns>The larger duration of <paramref name="x"/> or <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.Duration.Min(NodaTime.Duration,NodaTime.Duration)">
            <summary>
            Returns the smaller duration of the given two.
            </summary>
            <remarks>
            A "larger" duration is one that advances time by more than a "smaller" one. This means
            that a positive duration is always larger than a negative one, for example. (This is the same
            comparison used by the binary comparison operators.)
            </remarks>
            <param name="x">The first duration to compare.</param>
            <param name="y">The second duration to compare.</param>
            <returns>The smaller duration of <paramref name="x"/> or <paramref name="y"/>.</returns>
        </member>
        <member name="T:NodaTime.Extensions.ClockExtensions">
            <summary>
            Extension methods for <see cref="T:NodaTime.IClock"/>.
            </summary>
        </member>
        <member name="M:NodaTime.Extensions.ClockExtensions.InZone(NodaTime.IClock,NodaTime.DateTimeZone)">
            <summary>
            Constructs a <see cref="T:NodaTime.ZonedClock"/> from a clock (the target of the method),
            and a time zone.
            </summary>
            <param name="clock">Clock to use in the returned object.</param>
            <param name="zone">Time zone to use in the returned object.</param>
            <returns>A <see cref="T:NodaTime.ZonedClock"/> with the given clock and time zone, in the ISO calendar system.</returns>
        </member>
        <member name="M:NodaTime.Extensions.ClockExtensions.InZone(NodaTime.IClock,NodaTime.DateTimeZone,NodaTime.CalendarSystem)">
            <summary>
            Constructs a <see cref="T:NodaTime.ZonedClock"/> from a clock (the target of the method),
            a time zone, and a calendar system.
            </summary>
            <param name="clock">Clock to use in the returned object.</param>
            <param name="zone">Time zone to use in the returned object.</param>
            <param name="calendar">Calendar to use in the returned object.</param>
            <returns>A <see cref="T:NodaTime.ZonedClock"/> with the given clock, time zone and calendar system.</returns>
        </member>
        <member name="M:NodaTime.Extensions.ClockExtensions.InUtc(NodaTime.IClock)">
            <summary>
            Constructs a <see cref="T:NodaTime.ZonedClock"/> from a clock (the target of the method),
            using the UTC time zone and ISO calendar system.
            </summary>
            <param name="clock">Clock to use in the returned object.</param>
            <returns>A <see cref="T:NodaTime.ZonedClock"/> with the given clock, in the UTC time zone and ISO calendar system.</returns>
        </member>
        <member name="M:NodaTime.Extensions.ClockExtensions.InTzdbSystemDefaultZone(NodaTime.IClock)">
            <summary>
            Constructs a <see cref="T:NodaTime.ZonedClock"/> from a clock (the target of the method),
            in the TZDB mapping for the system default time zone time zone and the ISO calendar system.
            </summary>
            <param name="clock">Clock to use in the returned object.</param>
            <returns>A <c>ZonedClock</c> in the system default time zone (using TZDB) and the ISO calendar system,
            using the system clock.</returns>
            <exception cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException">The system default time zone is not mapped by
            TZDB.</exception>
            <seealso cref="P:NodaTime.DateTimeZoneProviders.Tzdb"/>
        </member>
        <member name="M:NodaTime.Extensions.ClockExtensions.InBclSystemDefaultZone(NodaTime.IClock)">
            <summary>
            Constructs a <see cref="T:NodaTime.ZonedClock"/> from a clock (the target of the method), in the wrapper for the
            BCL system default time zone time zone and the ISO calendar system.
            </summary>
            <remarks>The <c>DateTimeZone</c> used is a wrapper for <see cref="P:System.TimeZoneInfo.Local"/>.</remarks>
            <param name="clock">Clock to use in the returned object.</param>
            <returns>A <c>ZonedClock</c> in the system default time zone and the ISO calendar system,
            using the system clock.</returns>
            <seealso cref="P:NodaTime.DateTimeZoneProviders.Bcl"/>
        </member>
        <member name="T:NodaTime.Extensions.DateTimeExtensions">
            <summary>
            Extension methods for <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:NodaTime.Extensions.DateTimeExtensions.ToLocalDateTime(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> of any kind to <see cref="T:NodaTime.LocalDateTime"/>.
            </summary>
            <remarks>This is a convenience method which calls <see cref="M:NodaTime.LocalDateTime.FromDateTime(System.DateTime)"/>.</remarks>        
            <param name="dateTime">The <c>DateTime</c> to convert.</param>
            <returns>A new <see cref="T:NodaTime.LocalDateTime"/> with the same values as <paramref name="dateTime"/>.</returns>
        </member>
        <member name="M:NodaTime.Extensions.DateTimeExtensions.ToInstant(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> with a kind of <see cref="F:System.DateTimeKind.Utc"/> into an <see cref="T:NodaTime.Instant"/>.
            </summary>
            <remarks>This is a convenience method which calls <see cref="M:NodaTime.Instant.FromDateTimeUtc(System.DateTime)"/>.</remarks>        
            <param name="dateTime">The <c>DateTime</c> to convert.</param>
            <returns>An <see cref="T:NodaTime.Instant"/> value representing the same instant in time as <paramref name="dateTime"/>.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="dateTime"/> does not have a kind of <c>Utc</c>.</exception>
        </member>
        <member name="T:NodaTime.Extensions.DateTimeOffsetExtensions">
            <summary>
            Extension methods for <see cref="T:System.DateTimeOffset"/>.
            </summary>
        </member>
        <member name="M:NodaTime.Extensions.DateTimeOffsetExtensions.ToOffsetDateTime(System.DateTimeOffset)">
            <summary>
            Converts a <see cref="T:System.DateTimeOffset"/> to <see cref="T:NodaTime.OffsetDateTime"/>.
            </summary>
            <remarks>This is a convenience method which calls <see cref="M:NodaTime.OffsetDateTime.FromDateTimeOffset(System.DateTimeOffset)"/>.</remarks>        
            <param name="dateTimeOffset">The <c>DateTimeOffset</c> to convert.</param>
            <returns>A new <see cref="T:NodaTime.OffsetDateTime"/> with the same values as <paramref name="dateTimeOffset"/>.</returns>
        </member>
        <member name="M:NodaTime.Extensions.DateTimeOffsetExtensions.ToZonedDateTime(System.DateTimeOffset)">
            <summary>
            Converts a <see cref="T:System.DateTimeOffset"/> to <see cref="T:NodaTime.ZonedDateTime"/>.
            </summary>
            <remarks>This is a convenience method which calls <see cref="M:NodaTime.ZonedDateTime.FromDateTimeOffset(System.DateTimeOffset)"/>.</remarks>        
            <param name="dateTimeOffset">The <c>DateTimeOffset</c> to convert.</param>
            <returns>A new <see cref="T:NodaTime.ZonedDateTime"/> with the same values as <paramref name="dateTimeOffset"/>,
            using a fixed-offset time zone.</returns>
        </member>
        <member name="M:NodaTime.Extensions.DateTimeOffsetExtensions.ToInstant(System.DateTimeOffset)">
            <summary>
            Converts a <see cref="T:System.DateTimeOffset"/> into an <see cref="T:NodaTime.Instant"/>.
            </summary>
            <remarks>This is a convenience method which calls <see cref="M:NodaTime.Instant.FromDateTimeOffset(System.DateTimeOffset)"/>.</remarks>        
            <param name="dateTimeOffset">The <c>DateTimeOffset</c> to convert.</param>
            <returns>An <see cref="T:NodaTime.Instant"/> value representing the same instant in time as <paramref name="dateTimeOffset"/>.</returns>
        </member>
        <member name="T:NodaTime.Extensions.DateTimeZoneProviderExtensions">
            <summary>
            Extensions for <see cref="T:NodaTime.IDateTimeZoneProvider"/>
            </summary>
        </member>
        <member name="M:NodaTime.Extensions.DateTimeZoneProviderExtensions.GetAllZones(NodaTime.IDateTimeZoneProvider)">
            <summary>
            Returns a lazily-evaluated sequence of time zones from the specified provider,
            in the same order in which the IDs are returned by the provider.
            </summary>
            <param name="provider">The provider to fetch time zones from.</param>
            <returns>All the time zones from the provider.</returns>
        </member>
        <member name="T:NodaTime.Extensions.DayOfWeekExtensions">
            <summary>
            Extension methods for <see cref="T:System.DayOfWeek"/>.
            </summary>
        </member>
        <member name="M:NodaTime.Extensions.DayOfWeekExtensions.ToIsoDayOfWeek(System.DayOfWeek)">
            <summary>
            Converts a <see cref="T:System.DayOfWeek"/> into the corresponding <see cref="T:NodaTime.IsoDayOfWeek"/>.
            </summary>
            <remarks>This is a convenience method which calls <see cref="M:NodaTime.Utility.BclConversions.ToIsoDayOfWeek(System.DayOfWeek)"/>.</remarks>        
            <param name="dayOfWeek">The <c>DayOfWeek</c> to convert.</param>
            <returns>The <c>IsoDayOfWeek</c> equivalent to <paramref name="dayOfWeek"/></returns>
        </member>
        <member name="T:NodaTime.Extensions.IsoDayOfWeekExtensions">
            <summary>
            Extension methods 
            </summary>
        </member>
        <member name="M:NodaTime.Extensions.IsoDayOfWeekExtensions.ToDayOfWeek(NodaTime.IsoDayOfWeek)">
            <summary>
            Converts a <see cref="T:NodaTime.IsoDayOfWeek"/> into the corresponding <see cref="T:System.DayOfWeek"/>.
            </summary>
            <remarks>This is a convenience method which calls <see cref="M:NodaTime.Utility.BclConversions.ToDayOfWeek(NodaTime.IsoDayOfWeek)"/>.</remarks>        
            <param name="isoDayOfWeek">The <c>IsoDayOfWeek</c> to convert.</param>
            <returns>The <c>DayOfWeek</c> equivalent to <paramref name="isoDayOfWeek"/></returns>
        </member>
        <member name="T:NodaTime.Extensions.StopwatchExtensions">
            <summary>
            Extension methods for <see cref="T:System.Diagnostics.Stopwatch"/>.
            </summary>
        </member>
        <member name="M:NodaTime.Extensions.StopwatchExtensions.ElapsedDuration(System.Diagnostics.Stopwatch)">
            <summary>
            Returns the elapsed time of <paramref name="stopwatch"/> as a <see cref="T:NodaTime.Duration"/>.
            </summary>
            <param name="stopwatch">The <c>Stopwatch</c> to obtain the elapsed time from.</param>
            <returns>The elapsed time of <paramref name="stopwatch"/> as a <c>Duration</c>.</returns>
        </member>
        <member name="T:NodaTime.Extensions.TimeSpanExtensions">
            <summary>
            Extension methods for <see cref="T:System.TimeSpan"/>.
            </summary>
        </member>
        <member name="M:NodaTime.Extensions.TimeSpanExtensions.ToDuration(System.TimeSpan)">
            <summary>
            Converts a <see cref="T:System.TimeSpan"/> into a <see cref="T:NodaTime.Duration"/>.
            </summary>
            <remarks>This is a convenience method which calls <see cref="M:NodaTime.Duration.FromTimeSpan(System.TimeSpan)"/>.</remarks>        
            <param name="timeSpan">The <c>TimeSpan</c> to convert.</param>
            <returns>A <c>Duration</c> representing the same length of time as <paramref name="timeSpan"/>.</returns>
        </member>
        <member name="M:NodaTime.Extensions.TimeSpanExtensions.ToOffset(System.TimeSpan)">
            <summary>
            Converts a <see cref="T:System.TimeSpan"/> into an <see cref="T:NodaTime.Offset"/>.
            </summary>
            <remarks>This is a convenience method which calls <see cref="M:NodaTime.Offset.FromTimeSpan(System.TimeSpan)"/>.</remarks>        
            <param name="timeSpan">The <c>TimeSpan</c> to convert.</param>
            <returns>An <c>Offset</c> representing the same length of time as <paramref name="timeSpan"/>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeSpan"/> is too large or small to
            be represented as an <c>Offset</c>.</exception>
        </member>
        <member name="T:NodaTime.Fields.DatePeriodFields">
            <summary>
            All the period fields.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.FixedLengthDatePeriodField">
            <summary>
            Date period field for fixed-length periods (weeks and days).
            </summary>
        </member>
        <member name="T:NodaTime.Fields.IDatePeriodField">
            <summary>
            General representation of the difference between two dates in a particular time unit,
            such as "days" or "months".
            </summary>
        </member>
        <member name="M:NodaTime.Fields.IDatePeriodField.Add(NodaTime.LocalDate,System.Int32)">
            <summary>
            Adds a duration value (which may be negative) to the date. This may not
            be reversible; for example, adding a month to January 30th will result in
            February 28th or February 29th.
            </summary>
            <param name="localDate">The local date to add to</param>
            <param name="value">The value to add, in the units of the field</param>
            <returns>The updated local date</returns>
        </member>
        <member name="M:NodaTime.Fields.IDatePeriodField.UnitsBetween(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Computes the difference between two local dates, as measured in the units
            of this field, rounding towards zero. This rounding means that
            unit.Add(start, unit.UnitsBetween(start, end)) always ends up with a date
            between start and end. (Ideally equal to end, but importantly, it never overshoots.)
            </summary>
            <param name="start">The start date</param>
            <param name="end">The end date</param>
            <returns>The difference in the units of this field</returns>
        </member>
        <member name="T:NodaTime.Fields.MonthsPeriodField">
            <summary>
            Period field which uses a <see cref="T:NodaTime.Calendars.YearMonthDayCalculator" /> to add/subtract months.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.TimePeriodField">
            <summary>
            Period field class representing a field with a fixed duration regardless of when it occurs.
            </summary>
            <remarks>
            2014-06-29: Tried optimizing time period calculations by making these static methods accepting
            the number of ticks. I'd expected that to be really significant, given that it would avoid
            finding the object etc. It turned out to make about 10% difference, at the cost of quite a bit
            of code elegance.
            </remarks>
        </member>
        <member name="M:NodaTime.Fields.TimePeriodField.GetUnitsInDuration(NodaTime.Duration)">
            <summary>
            Returns the number of units in the given duration, rounding towards zero.
            </summary>
        </member>
        <member name="M:NodaTime.Fields.TimePeriodField.ToDuration(System.Int64)">
            <summary>
            Returns a <see cref="T:NodaTime.Duration"/> representing the given number of units.
            </summary>
        </member>
        <member name="T:NodaTime.Fields.YearsPeriodField">
            <summary>
            Period field which uses a <see cref="T:NodaTime.Calendars.YearMonthDayCalculator" /> to add/subtract years.
            </summary>
        </member>
        <member name="T:NodaTime.Globalization.NodaFormatInfo">
            <summary>
            A <see cref="T:System.IFormatProvider"/> for Noda Time types, usually initialised from a <see cref="T:System.Globalization.CultureInfo"/>.
            This provides a single place defining how NodaTime values are formatted and displayed, depending on the culture.
            </summary>
            <remarks>
            Currently this is "shallow-immutable" - although none of these properties can be changed, the
            CultureInfo itself may be mutable. If the CultureInfo is mutated after initialization, results are not
            guaranteed: some aspects of the CultureInfo may be extracted at initialization time, others may be
            extracted on first demand but cached, and others may be extracted on-demand each time.
            </remarks>
            <threadsafety>Instances which use read-only CultureInfo instances are immutable,
            and may be used freely between threads. Instances with mutable cultures should not be shared between threads
            without external synchronization.
            See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.Globalization.NodaFormatInfo.InvariantInfo">
            <summary>
            A NodaFormatInfo wrapping the invariant culture.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> class based solely
            on a <see cref="T:System.Globalization.CultureInfo"/>.
            </summary>
            <param name="cultureInfo">The culture info to use.</param>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.#ctor(System.Globalization.CultureInfo,System.Globalization.DateTimeFormatInfo)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> class based on
            potentially disparate <see cref="T:System.Globalization.CultureInfo"/> and
            <see cref="T:System.Globalization.DateTimeFormatInfo"/> instances.
            </summary>
            <param name="cultureInfo">The culture info to use for text comparisons and resource lookups.</param>
            <param name="dateTimeFormat">The date/time format to use for format strings etc.</param>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.ConvertMonthArray(System.String[])">
            <summary>
            The BCL returns arrays of month names starting at 0; we want a read-only list starting at 1 (with 0 as an empty string).
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.ConvertDayArray(System.String[])">
            <summary>
            The BCL returns arrays of week names starting at 0 as Sunday; we want a read-only list starting at 1 (with 0 as an empty string)
            and with 7 as Sunday.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.ConvertGenitiveMonthArray(System.Collections.Generic.IReadOnlyList{System.String},System.String[],System.String[])">
            <summary>
            Checks whether any of the genitive names differ from the non-genitive names, and returns
            either a reference to the non-genitive names or a converted list as per ConvertMonthArray.
            </summary>
            <remarks>
            <para>
            Mono uses the invariant month names for the genitive month names by default, so we'll assume that
            if we see an invariant name, that *isn't* deliberately a genitive month name. A non-invariant culture
            which decided to have genitive month names exactly matching the invariant ones would be distinctly odd.
            See https://xamarin.github.io/bugzilla-archives/32/3278/bug.html for more details and progress.
            </para>
            <para>
            Mono 3.0.6 has an exciting and different bug, where all the abbreviated genitive month names are just numbers ("1" etc).
            So again, if we detect that, we'll go back to the non-genitive version.
            See https://xamarin.github.io/bugzilla-archives/11/11361/bug.html for more details and progress.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.CultureInfo">
            <summary>
            Gets the culture info associated with this format provider. This is used
            for resource lookups and text comparisons.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.CompareInfo">
            <summary>
            Gets the text comparison information associated with this format provider.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.LongMonthNames">
            <summary>
            Returns a read-only list of the names of the months for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, to allow a more natural mapping from (say) 1 to the string "January".
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.ShortMonthNames">
            <summary>
            Returns a read-only list of the abbreviated names of the months for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, to allow a more natural mapping from (say) 1 to the string "Jan".
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.LongMonthGenitiveNames">
            <summary>
            Returns a read-only list of the names of the months for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, to allow a more natural mapping from (say) 1 to the string "January".
            The genitive form is used for month text where the day of month also appears in the pattern.
            If the culture does not use genitive month names, this property will return the same reference as
            <see cref="P:NodaTime.Globalization.NodaFormatInfo.LongMonthNames"/>.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.ShortMonthGenitiveNames">
            <summary>
            Returns a read-only list of the abbreviated names of the months for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, to allow a more natural mapping from (say) 1 to the string "Jan".
            The genitive form is used for month text where the day also appears in the pattern.
            If the culture does not use genitive month names, this property will return the same reference as
            <see cref="P:NodaTime.Globalization.NodaFormatInfo.ShortMonthNames"/>.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.LongDayNames">
            <summary>
            Returns a read-only list of the names of the days of the week for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, and the other elements correspond with the index values returned from
            <see cref="P:NodaTime.LocalDateTime.DayOfWeek"/> and similar properties.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.ShortDayNames">
            <summary>
            Returns a read-only list of the abbreviated names of the days of the week for the default calendar for this culture.
            See the usage guide for caveats around the use of these names for other calendars.
            Element 0 of the list is null, and the other elements correspond with the index values returned from
            <see cref="P:NodaTime.LocalDateTime.DayOfWeek"/> and similar properties.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.DateTimeFormat">
            <summary>
            Gets the BCL date time format associated with this formatting information.
            </summary>
            <remarks>
            This is usually the <see cref="T:System.Globalization.DateTimeFormatInfo"/> from <see cref="P:NodaTime.Globalization.NodaFormatInfo.CultureInfo"/>,
            but in some cases they're different: if a DateTimeFormatInfo is provided with no
            CultureInfo, that's used for format strings but the invariant culture is used for
            text comparisons and culture lookups for non-BCL formats (such as Offset) and for error messages.
            </remarks>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.TimeSeparator">
            <summary>
            Gets the time separator.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.DateSeparator">
            <summary>
            Gets the date separator.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.AMDesignator">
            <summary>
            Gets the AM designator.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.PMDesignator">
            <summary>
            Gets the PM designator.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.GetEraNames(NodaTime.Calendars.Era)">
            <summary>
            Returns the names for the given era in this culture.
            </summary>
            <param name="era">The era to find the names of.</param>
            <returns>A read-only list of names for the given era, or an empty list if
            the era is not known in this culture.</returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.GetEraPrimaryName(NodaTime.Calendars.Era)">
            <summary>
            Returns the primary name for the given era in this culture.
            </summary>
            <param name="era">The era to find the primary name of.</param>
            <returns>The primary name for the given era, or an empty string if the era name is not known.</returns>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.CurrentInfo">
            <summary>
            Gets the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> object for the current thread.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternLong">
            <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "l" pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternMedium">
            <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "m" pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternShort">
            <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "s" pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternLongNoPunctuation">
            <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "L" pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternMediumNoPunctuation">
            <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "M" pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Globalization.NodaFormatInfo.OffsetPatternShortNoPunctuation">
            <summary>
            Gets the <see cref="T:NodaTime.Offset" /> "S" pattern.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.ClearCache">
            <summary>
            Clears the cache. Only used for test purposes.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.GetFormatInfo(System.Globalization.CultureInfo)">
            <summary>
            Gets the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> for the given <see cref="P:NodaTime.Globalization.NodaFormatInfo.CultureInfo" />.
            </summary>
            <remarks>
            This method maintains a cache of results for read-only cultures.
            </remarks>
            <param name="cultureInfo">The culture info.</param>
            <returns>The <see cref="T:NodaTime.Globalization.NodaFormatInfo" />. Will never be null.</returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.GetInstance(System.IFormatProvider)">
            <summary>
            Gets the <see cref="T:NodaTime.Globalization.NodaFormatInfo" /> for the given <see cref="T:System.IFormatProvider" />. If the
            format provider is null then the format object for the current thread is returned. If it's
            a CultureInfo, that's used for everything. If it's a DateTimeFormatInfo, that's used for
            format strings, day names etc but the invariant culture is used for text comparisons and
            resource lookups. Otherwise, <see cref="T:System.ArgumentException"/> is thrown.
            </summary>
            <param name="provider">The <see cref="T:System.IFormatProvider" />.</param>
            <exception cref="T:System.ArgumentException">The format provider cannot be used for Noda Time.</exception>
            <returns>The <see cref="T:NodaTime.Globalization.NodaFormatInfo" />. Will never be null.</returns>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
        </member>
        <member name="T:NodaTime.Globalization.NodaFormatInfo.EraDescription">
            <summary>
            The description for an era: the primary name and all possible names.
            </summary>
        </member>
        <member name="M:NodaTime.Globalization.NodaFormatInfo.EraDescription.GetEraNameFromBcl(NodaTime.Calendars.Era,System.Globalization.CultureInfo)">
            <summary>
            Returns the name of the era within a culture according to the BCL, if this is known and we're confident that
            it's correct. (The selection here seems small, but it covers most cases.) This isn't ideal, but it's better
            than nothing, and fixes an issue where non-English BCL cultures have "gg" in their patterns.
            </summary>
        </member>
        <member name="T:NodaTime.Globalization.PatternResources">
            <summary>
            Takes the place of the designer-generated code for PatternResources.resx
            </summary>
        </member>
        <member name="T:NodaTime.IClock">
            <summary>
            Represents a clock which can return the current time as an <see cref="T:NodaTime.Instant" />.
            </summary>
            <remarks>
            <see cref="T:NodaTime.IClock"/> is intended for use anywhere you need to have access to the current time.
            Although it's not strictly incorrect to call <c>SystemClock.Instance.GetCurrentInstant()</c> directly,
            in the same way as you might call <see cref="P:System.DateTime.UtcNow"/>, it's strongly discouraged
            as a matter of style for production code. We recommend providing an instance of <see cref="T:NodaTime.IClock"/>
            to anything that needs it, which allows you to write tests using the fake clock in the NodaTime.Testing
            assembly (or your own implementation).
            </remarks>
            <seealso cref="T:NodaTime.SystemClock"/>
            <threadsafety>All implementations in Noda Time are thread-safe; custom implementations
            should be thread-safe too. See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.IClock.GetCurrentInstant">
            <summary>
            Gets the current <see cref="T:NodaTime.Instant"/> on the time line according to this clock.
            </summary>
            <returns>The current instant on the time line according to this clock.</returns>
        </member>
        <member name="T:NodaTime.IDateTimeZoneProvider">
            <summary>
            Provides stable, performant time zone data.
            </summary>
            <remarks>
            <para>Consumers should be able to treat an <see cref="T:NodaTime.IDateTimeZoneProvider"/> like a cache: 
            lookups should be quick (after at most one lookup of a given ID), and multiple calls for a given ID must
            always return references to equal instances, even if they are not references to a single instance.
            Consumers should not feel the need to cache data accessed through this interface.</para>
            <para>Implementations designed to work with any <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource"/> implementation (such as
            <see cref="T:NodaTime.TimeZones.DateTimeZoneCache"/>) should not attempt to handle exceptions thrown by the source. A source-specific
            provider may do so, as it has more detailed knowledge of what can go wrong and how it can best be handled.</para>
            </remarks>
        </member>
        <member name="P:NodaTime.IDateTimeZoneProvider.VersionId">
            <summary>
            Gets the version ID of this provider.
            </summary>
            <value>The version ID of this provider.</value>
        </member>
        <member name="P:NodaTime.IDateTimeZoneProvider.Ids">
            <summary>
            Gets the list of valid time zone ids advertised by this provider.
            </summary>
            <remarks>
            <para>
            This list will be sorted in ordinal lexicographic order. It cannot be modified by callers, and
            must not be modified by the provider either: client code can safely treat it as thread-safe
            and deeply immutable.
            </para>
            <para>
            In addition to the list returned here, providers always support the fixed-offset timezones with IDs "UTC"
            and "UTC+/-Offset". These may or may not be included explicitly in this list.
            </para>
            </remarks>
            <value>The <see cref="T:System.Collections.Generic.IEnumerable`1" /> of string ids.</value>
        </member>
        <member name="M:NodaTime.IDateTimeZoneProvider.GetSystemDefault">
            <summary>
            Gets the time zone from this provider that matches the system default time zone, if a matching time zone is
            available.
            </summary>
            <remarks>
            <para>
            Callers should be aware that this method will throw <see cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException"/> if no matching
            time zone is found. For the built-in Noda Time providers, this is unlikely to occur in practice (assuming
            the system is using a standard Windows time zone), but can occur even then, if no mapping is found. The TZDB
            source contains mappings for almost all Windows system time zones, but a few (such as "Mid-Atlantic Standard Time")
            are unmappable.
            </para>
            <para>
            If it is necessary to handle this case, callers can construct a
            <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/> via <see cref="M:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault"/>, which returns a
            <see cref="T:NodaTime.DateTimeZone"/> that wraps the system local <see cref="T:System.TimeZoneInfo"/>, and which always
            succeeds.
            Note that <c>BclDateTimeZone</c> may not be available in all versions of Noda Time 1.x and 2.x; see
            the class documentation for more details.
            </para>
            </remarks>
            <exception cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException">The system default time zone is not mapped by
            this provider.</exception>
            <returns>
            The provider-specific representation of the system default time zone.
            </returns>
        </member>
        <member name="M:NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)">
            <summary>
            Returns the time zone for the given ID, if it's available.
            </summary>
            <remarks>
            <para>
            Note that this may return a <see cref="T:NodaTime.DateTimeZone"/> that has a different ID to that requested, if the ID
            provided is an alias.
            </para>
            <para>
            Note also that this method is not required to return the same <see cref="T:NodaTime.DateTimeZone"/> instance for
            successive requests for the same ID; however, all instances returned for a given ID must compare
            as equal.
            </para>
            <para>
            The fixed-offset timezones with IDs "UTC" and "UTC+/-Offset" are always available.
            </para>
            </remarks>
            <param name="id">The time zone ID to find.</param>
            <returns>The <see cref="T:NodaTime.DateTimeZone" /> for the given ID or null if the provider does not support
            the given ID.</returns>
        </member>
        <member name="P:NodaTime.IDateTimeZoneProvider.Item(System.String)">
            <summary>
            Returns the time zone for the given ID.
            </summary>
            <remarks>
            <para>
            Unlike <see cref="M:NodaTime.IDateTimeZoneProvider.GetZoneOrNull(System.String)"/>, this indexer will never return a null reference. If the ID is not
            supported by this provider, it will throw <see cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException" />.
            </para>
            <para>
            Note that this may return a <see cref="T:NodaTime.DateTimeZone"/> that has a different ID to that requested, if the ID
            provided is an alias.
            </para>
            <para>
            Note also that this method is not required to return the same <see cref="T:NodaTime.DateTimeZone"/> instance for
            successive requests for the same ID; however, all instances returned for a given ID must compare
            as equal.
            </para>
            <para>
            The fixed-offset timezones with IDs "UTC" and "UTC+/-Offset" are always available.
            </para>
            </remarks>
            <param name="id">The time zone id to find.</param>
            <value>The <see cref="T:NodaTime.DateTimeZone" /> for the given ID.</value>
            <exception cref="T:NodaTime.TimeZones.DateTimeZoneNotFoundException">This provider does not support the given ID.</exception>
        </member>
        <member name="T:NodaTime.Instant">
            <summary>
            Represents an instant on the global timeline, with nanosecond resolution.
            </summary>
            <remarks>
            <para>
            An <see cref="T:NodaTime.Instant"/> has no concept of a particular time zone or calendar: it simply represents a point in
            time that can be globally agreed-upon.
            </para>
            <para>
            Equality and ordering comparisons are defined in the natural way, with earlier points on the timeline
            being considered "less than" later points.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.Instant.MinValue">
            <summary>
            Represents the smallest possible <see cref="T:NodaTime.Instant"/>.
            </summary>
            <remarks>This value is equivalent to -9998-01-01T00:00:00Z</remarks>
        </member>
        <member name="P:NodaTime.Instant.MaxValue">
            <summary>
            Represents the largest possible <see cref="T:NodaTime.Instant"/>.
            </summary>
            <remarks>This value is equivalent to 9999-12-31T23:59:59.999999999Z</remarks>
        </member>
        <member name="F:NodaTime.Instant.BeforeMinValue">
            <summary>
            Instant which is invalid *except* for comparison purposes; it is earlier than any valid value.
            This must never be exposed.
            </summary>
        </member>
        <member name="F:NodaTime.Instant.AfterMaxValue">
            <summary>
            Instant which is invalid *except* for comparison purposes; it is later than any valid value.
            This must never be exposed.
            </summary>
        </member>
        <member name="F:NodaTime.Instant.duration">
            <summary>
            Time elapsed since the Unix epoch.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructor which should *only* be used to construct the invalid instances.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.#ctor(NodaTime.Duration)">
            <summary>
            Constructor which constructs a new instance with the given duration, which
            is trusted to be valid. Should only be called from FromTrustedDuration and
            FromUntrustedDuration.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.FromTrustedDuration(NodaTime.Duration)">
            <summary>
            Creates an Instant with the given duration, with no validation (in release mode).
            </summary>
        </member>
        <member name="M:NodaTime.Instant.FromUntrustedDuration(NodaTime.Duration)">
            <summary>
            Creates an Instant with the given duration, validating that it has a suitable
            "day" part. (It is assumed that the nanoOfDay is okay.)
            </summary>
        </member>
        <member name="P:NodaTime.Instant.IsValid">
            <summary>
            Returns whether or not this is a valid instant. Returns true for all but
            <see cref="F:NodaTime.Instant.BeforeMinValue"/> and <see cref="F:NodaTime.Instant.AfterMaxValue"/>.
            </summary>
        </member>
        <member name="P:NodaTime.Instant.TimeSinceEpoch">
            <summary>
            Get the elapsed time since the Unix epoch, to nanosecond resolution.
            </summary>
            <returns>The elapsed time since the Unix epoch.</returns>
        </member>
        <member name="P:NodaTime.Instant.DaysSinceEpoch">
            <summary>
            Number of days since the local unix epoch.
            </summary>
        </member>
        <member name="P:NodaTime.Instant.NanosecondOfDay">
            <summary>
            Nanosecond within the day.
            </summary>
        </member>
        <member name="M:NodaTime.Instant.CompareTo(NodaTime.Instant)">
            <summary>
            Compares the current object with another object of the same type.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
              A 32-bit signed integer that indicates the relative order of the objects being compared.
              The return value has the following meanings:
              <list type = "table">
                <listheader>
                  <term>Value</term>
                  <description>Meaning</description>
                </listheader>
                <item>
                  <term>&lt; 0</term>
                  <description>This object is less than the <paramref name = "other" /> parameter.</description>
                </item>
                <item>
                  <term>0</term>
                  <description>This object is equal to <paramref name = "other" />.</description>
                </item>
                <item>
                  <term>&gt; 0</term>
                  <description>This object is greater than <paramref name = "other" />.</description>
                </item>
              </list>
            </returns>
        </member>
        <member name="M:NodaTime.Instant.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two instants.
            See the type documentation for a description of ordering semantics.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.Instant"/>.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this instant with another one; see <see cref="M:NodaTime.Instant.CompareTo(NodaTime.Instant)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.Instant.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.Instant.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.Instant.PlusTicks(System.Int64)">
            <summary>
            Returns a new value of this instant with the given number of ticks added to it.
            </summary>
            <param name="ticks">The ticks to add to this instant to create the return value.</param>
            <returns>The result of adding the given number of ticks to this instant.</returns>
        </member>
        <member name="M:NodaTime.Instant.PlusNanoseconds(System.Int64)">
            <summary>
            Returns a new value of this instant with the given number of nanoseconds added to it.
            </summary>
            <param name="nanoseconds">The nanoseconds to add to this instant to create the return value.</param>
            <returns>The result of adding the given number of ticks to this instant.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Addition(NodaTime.Instant,NodaTime.Duration)">
            <summary>
            Implements the operator + (addition) for <see cref="T:NodaTime.Instant" /> + <see cref="T:NodaTime.Duration" />.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Plus(NodaTime.Offset)">
            <summary>
            Adds the given offset to this instant, to return a <see cref="T:NodaTime.LocalInstant" />.
            A positive offset indicates that the local instant represents a "later local time" than the UTC
            representation of this instant.
            </summary>
            <remarks>
            This was previously an operator+ implementation, but operators can't be internal.
            </remarks>
            <param name="offset">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.LocalInstant" /> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.SafePlus(NodaTime.Offset)">
            <summary>
            Adds the given offset to this instant, either returning a normal LocalInstant,
            or <see cref="F:NodaTime.LocalInstant.BeforeMinValue"/> or <see cref="F:NodaTime.LocalInstant.AfterMaxValue"/>
            if the value would overflow.
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:NodaTime.Instant.Add(NodaTime.Instant,NodaTime.Duration)">
            <summary>
            Adds a duration to an instant. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the sum of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Plus(NodaTime.Duration)">
            <summary>
            Returns the result of adding a duration to this instant, for a fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="duration">The duration to add</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Subtraction(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Implements the operator - (subtraction) for <see cref="T:NodaTime.Instant" /> - <see cref="T:NodaTime.Instant" />.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration" /> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Subtraction(NodaTime.Instant,NodaTime.Duration)">
            <summary>
            Implements the operator - (subtraction) for <see cref="T:NodaTime.Instant" /> - <see cref="T:NodaTime.Duration" />.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Subtract(NodaTime.Instant,NodaTime.Instant)">
            <summary>
              Subtracts one instant from another. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Duration" /> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Minus(NodaTime.Instant)">
            <summary>
            Returns the result of subtracting another instant from this one, for a fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="other">The other instant to subtract</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the result of the subtraction.</returns>
        </member>
        <member name="M:NodaTime.Instant.Subtract(NodaTime.Instant,NodaTime.Duration)">
            <summary>
            Subtracts a duration from an instant. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.Instant.Minus(NodaTime.Duration)">
            <summary>
            Returns the result of subtracting a duration from this instant, for a fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="duration">The duration to subtract</param>
            <returns>A new <see cref="T:NodaTime.Instant" /> representing the result of the subtraction.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Equality(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Implements the operator == (equality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_Inequality(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Implements the operator != (inequality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_LessThan(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Implements the operator &lt; (less than).
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_LessThanOrEqual(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Implements the operator &lt;= (less than or equal).
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_GreaterThan(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Implements the operator &gt; (greater than).
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.op_GreaterThanOrEqual(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Implements the operator &gt;= (greater than or equal).
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Instant.FromUtc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new instant corresponding to the given UTC date and time in the ISO calendar.
            In most cases applications should use <see cref="T:NodaTime.ZonedDateTime" /> to represent a date
            and time, but this method is useful in some situations where an <see cref="T:NodaTime.Instant" /> is
            required, such as time zone testing.
            </summary>
            <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
            <param name="monthOfYear">The month of year.</param>
            <param name="dayOfMonth">The day of month.</param>
            <param name="hourOfDay">The hour.</param>
            <param name="minuteOfHour">The minute.</param>
            <returns>An <see cref="T:NodaTime.Instant"/> value representing the given date and time in UTC and the ISO calendar.</returns>
        </member>
        <member name="M:NodaTime.Instant.FromUtc(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new instant corresponding to the given UTC date and
            time in the ISO calendar. In most cases applications should 
            use <see cref="T:NodaTime.ZonedDateTime" />
            to represent a date and time, but this method is useful in some 
            situations where an Instant is required, such as time zone testing.
            </summary>
            <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
            <param name="monthOfYear">The month of year.</param>
            <param name="dayOfMonth">The day of month.</param>
            <param name="hourOfDay">The hour.</param>
            <param name="minuteOfHour">The minute.</param>
            <param name="secondOfMinute">The second.</param>
            <returns>An <see cref="T:NodaTime.Instant"/> value representing the given date and time in UTC and the ISO calendar.</returns>
        </member>
        <member name="M:NodaTime.Instant.Max(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Returns the later instant of the given two.
            </summary>
            <param name="x">The first instant to compare.</param>
            <param name="y">The second instant to compare.</param>
            <returns>The later instant of <paramref name="x"/> or <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.Instant.Min(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Returns the earlier instant of the given two.
            </summary>
            <param name="x">The first instant to compare.</param>
            <param name="y">The second instant to compare.</param>
            <returns>The earlier instant of <paramref name="x"/> or <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.Instant.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("g"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.Instant.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("g").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Instant.Equals(NodaTime.Instant)">
            <summary>
            Indicates whether the value of this instant is equal to the value of the specified instant.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">The value to compare with this instance.</param>
            <returns>
            true if the value of this instant is equal to the value of the <paramref name="other" /> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.Instant.ToJulianDate">
            <summary>
            Returns the Julian Date of this instance - the number of days since
            <see cref="P:NodaTime.NodaConstants.JulianEpoch"/> (noon on January 1st, 4713 BCE in the Julian calendar).
            </summary>
            <returns>The number of days (including fractional days) since the Julian Epoch.</returns>
        </member>
        <member name="M:NodaTime.Instant.ToDateTimeUtc">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this Instant which has a <see cref="P:System.DateTime.Kind" />
            of <see cref="F:System.DateTimeKind.Utc"/> and represents the same instant of time as this value.
            </summary>
            <remarks>
            <para>
            If the date and time is not on a tick boundary (the unit of granularity of DateTime) the value will be truncated
            towards the start of time.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The final date/time is outside the range of <c>DateTime</c>.</exception>
            <returns>A <see cref="T:System.DateTime"/> representing the same instant in time as this value, with a kind of "universal".</returns>
        </member>
        <member name="M:NodaTime.Instant.ToDateTimeOffset">
            <summary>
            Constructs a <see cref="T:System.DateTimeOffset"/> from this Instant which has an offset of zero.
            </summary>
            <remarks>
            <para>
            If the date and time is not on a tick boundary (the unit of granularity of DateTime) the value will be truncated
            towards the start of time.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The final date/time is outside the range of <c>DateTimeOffset</c>.</exception>
            <returns>A <see cref="T:System.DateTimeOffset"/> representing the same instant in time as this value.</returns>
        </member>
        <member name="M:NodaTime.Instant.FromDateTimeOffset(System.DateTimeOffset)">
            <summary>
            Converts a <see cref="T:System.DateTimeOffset"/> into a new Instant representing the same instant in time. Note that
            the offset information is not preserved in the returned Instant.
            </summary>
            <returns>An <see cref="T:NodaTime.Instant"/> value representing the same instant in time as the given <see cref="T:System.DateTimeOffset"/>.</returns>
            <param name="dateTimeOffset">Date and time value with an offset.</param>
        </member>
        <member name="M:NodaTime.Instant.FromJulianDate(System.Double)">
            <summary>
            Converts a Julian Date representing the given number of days
            since <see cref="P:NodaTime.NodaConstants.JulianEpoch"/> (noon on January 1st, 4713 BCE in the Julian calendar)
            into an <see cref="T:NodaTime.Instant"/>.
            </summary>
            <param name="julianDate">The number of days since the Julian Epoch to convert into an <see cref="T:NodaTime.Instant"/>.</param>
            <returns>An <see cref="T:NodaTime.Instant"/> value which is <paramref name="julianDate"/> days after the Julian Epoch.</returns>
        </member>
        <member name="M:NodaTime.Instant.FromDateTimeUtc(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> into a new Instant representing the same instant in time.
            </summary>
            <returns>An <see cref="T:NodaTime.Instant"/> value representing the same instant in time as the given universal <see cref="T:System.DateTime"/>.</returns>
            <param name="dateTime">Date and time value which must have a <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Utc"/></param>
            <exception cref="T:System.ArgumentException"><paramref name="dateTime"/> is not of <see cref="P:System.DateTime.Kind"/>
            <see cref="F:System.DateTimeKind.Utc"/>.</exception>
        </member>
        <member name="M:NodaTime.Instant.FromUnixTimeSeconds(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Instant" /> struct based
            on a number of seconds since the Unix epoch of (ISO) January 1st 1970, midnight, UTC.
            </summary>
            <param name="seconds">Number of seconds since the Unix epoch. May be negative (for instants before the epoch).</param>
            <returns>An <see cref="T:NodaTime.Instant"/> at exactly the given number of seconds since the Unix epoch.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The constructed instant would be out of the range representable in Noda Time.</exception>
        </member>
        <member name="M:NodaTime.Instant.FromUnixTimeMilliseconds(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Instant" /> struct based
            on a number of milliseconds since the Unix epoch of (ISO) January 1st 1970, midnight, UTC.
            </summary>
            <param name="milliseconds">Number of milliseconds since the Unix epoch. May be negative (for instants before the epoch).</param>
            <returns>An <see cref="T:NodaTime.Instant"/> at exactly the given number of milliseconds since the Unix epoch.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The constructed instant would be out of the range representable in Noda Time.</exception>
        </member>
        <member name="M:NodaTime.Instant.FromUnixTimeTicks(System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Instant" /> struct based
            on a number of ticks since the Unix epoch of (ISO) January 1st 1970, midnight, UTC.
            </summary>
            <returns>An <see cref="T:NodaTime.Instant"/> at exactly the given number of ticks since the Unix epoch.</returns>
            <param name="ticks">Number of ticks since the Unix epoch. May be negative (for instants before the epoch).</param>
        </member>
        <member name="M:NodaTime.Instant.ToUnixTimeSeconds">
            <summary>
            Gets the number of seconds since the Unix epoch. Negative values represent instants before the Unix epoch.
            </summary>
            <remarks>
            If the number of nanoseconds in this instant is not an exact number of seconds, the value is truncated towards the start of time.
            </remarks>
            <value>The number of seconds since the Unix epoch.</value>
        </member>
        <member name="M:NodaTime.Instant.ToUnixTimeMilliseconds">
            <summary>
            Gets the number of milliseconds since the Unix epoch. Negative values represent instants before the Unix epoch.
            </summary>
            <remarks>
            If the number of nanoseconds in this instant is not an exact number of milliseconds, the value is truncated towards the start of time.
            </remarks>
            <value>The number of milliseconds since the Unix epoch.</value>
        </member>
        <member name="M:NodaTime.Instant.ToUnixTimeTicks">
            <summary>
            Gets the number of ticks since the Unix epoch. Negative values represent instants before the Unix epoch.
            </summary>
            <remarks>
            A tick is equal to 100 nanoseconds. There are 10,000 ticks in a millisecond. If the number of nanoseconds
            in this instant is not an exact number of ticks, the value is truncated towards the start of time.
            </remarks>
            <returns>The number of ticks since the Unix epoch.</returns>
        </member>
        <member name="M:NodaTime.Instant.InUtc">
            <summary>
            Returns the <see cref="T:NodaTime.ZonedDateTime"/> representing the same point in time as this instant, in the UTC time
            zone and ISO-8601 calendar. This is a shortcut for calling <see cref="M:NodaTime.Instant.InZone(NodaTime.DateTimeZone)" /> with an
            argument of <see cref="P:NodaTime.DateTimeZone.Utc"/>.
            </summary>
            <returns>A <see cref="T:NodaTime.ZonedDateTime"/> for the same instant, in the UTC time zone
            and the ISO-8601 calendar</returns>
        </member>
        <member name="M:NodaTime.Instant.InZone(NodaTime.DateTimeZone)">
            <summary>
            Returns the <see cref="T:NodaTime.ZonedDateTime"/> representing the same point in time as this instant, in the
            specified time zone and ISO-8601 calendar.
            </summary>
            <param name="zone">The time zone in which to represent this instant.</param>
            <returns>A <see cref="T:NodaTime.ZonedDateTime"/> for the same instant, in the given time zone
            and the ISO-8601 calendar</returns>
        </member>
        <member name="M:NodaTime.Instant.InZone(NodaTime.DateTimeZone,NodaTime.CalendarSystem)">
            <summary>
            Returns the <see cref="T:NodaTime.ZonedDateTime"/> representing the same point in time as this instant, in the
            specified time zone and calendar system.
            </summary>
            <param name="zone">The time zone in which to represent this instant.</param>
            <param name="calendar">The calendar system in which to represent this instant.</param>
            <returns>A <see cref="T:NodaTime.ZonedDateTime"/> for the same instant, in the given time zone
            and calendar</returns>
        </member>
        <member name="M:NodaTime.Instant.WithOffset(NodaTime.Offset)">
            <summary>
            Returns the <see cref="T:NodaTime.OffsetDateTime"/> representing the same point in time as this instant, with
            the specified UTC offset in the ISO calendar system.
            </summary>
            <param name="offset">The offset from UTC with which to represent this instant.</param>
            <returns>An <see cref="T:NodaTime.OffsetDateTime"/> for the same instant, with the given offset
            in the ISO calendar system</returns>
        </member>
        <member name="M:NodaTime.Instant.WithOffset(NodaTime.Offset,NodaTime.CalendarSystem)">
            <summary>
            Returns the <see cref="T:NodaTime.OffsetDateTime"/> representing the same point in time as this instant, with
            the specified UTC offset and calendar system.
            </summary>
            <param name="offset">The offset from UTC with which to represent this instant.</param>
            <param name="calendar">The calendar system in which to represent this instant.</param>
            <returns>An <see cref="T:NodaTime.OffsetDateTime"/> for the same instant, with the given offset
            and calendar</returns>
        </member>
        <member name="M:NodaTime.Instant.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.Instant"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Instant.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.Interval">
            <summary>
            An interval between two instants in time (start and end).
            </summary>
            <remarks>
            <para>
            Equality is defined in a component-wise fashion: two intervals are considered equal if their start instants are
            equal to each other and their end instants are equal to each other. Ordering between intervals is not defined.
            </para>
            <para>
            The interval includes the start instant and excludes the end instant. However, an interval
            may be missing its start or end, in which case the interval is deemed to be infinite in that
            direction.
            </para>
            <para>
            The end may equal the start (resulting in an empty interval), but will not be before the start.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.Interval.start">
            <summary>The start of the interval.</summary>
        </member>
        <member name="F:NodaTime.Interval.end">
            <summary>The end of the interval. This will never be earlier than the start.</summary>
        </member>
        <member name="M:NodaTime.Interval.#ctor(NodaTime.Instant,NodaTime.Instant)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Interval"/> struct.
            The interval includes the <paramref name="start"/> instant and excludes the
            <paramref name="end"/> instant. The end may equal the start (resulting in an empty interval), but must not be before the start.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="end"/> is earlier than <paramref name="start"/>.</exception>
            <param name="start">The start <see cref="T:NodaTime.Instant"/>.</param>
            <param name="end">The end <see cref="T:NodaTime.Instant"/>.</param>
        </member>
        <member name="M:NodaTime.Interval.#ctor(System.Nullable{NodaTime.Instant},System.Nullable{NodaTime.Instant})">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Interval"/> struct from two nullable <see cref="T:NodaTime.Instant"/>
            values.
            </summary>
            <remarks>
            If the start is null, the interval is deemed to stretch to the start of time. If the end is null,
            the interval is deemed to stretch to the end of time.
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="end"/> is earlier than <paramref name="start"/>,
            if they are both non-null.</exception>
            <param name="start">The start <see cref="T:NodaTime.Instant"/> or null.</param>
            <param name="end">The end <see cref="T:NodaTime.Instant"/> or null.</param>
        </member>
        <member name="P:NodaTime.Interval.Start">
            <summary>
            Gets the start instant - the inclusive lower bound of the interval.
            </summary>
            <remarks>
            This will never be later than <see cref="P:NodaTime.Interval.End"/>, though it may be equal to it.
            </remarks>
            <value>The start <see cref="T:NodaTime.Instant"/>.</value>
            <exception cref="T:System.InvalidOperationException">The interval extends to the start of time.</exception>
            <seealso cref="P:NodaTime.Interval.HasStart"/>
        </member>
        <member name="P:NodaTime.Interval.HasStart">
            <summary>
            Returns <c>true</c> if this interval has a fixed start point, or <c>false</c> if it
            extends to the start of time.
            </summary>
            <value><c>true</c> if this interval has a fixed start point, or <c>false</c> if it
            extends to the start of time.</value>
        </member>
        <member name="P:NodaTime.Interval.End">
            <summary>
            Gets the end instant - the exclusive upper bound of the interval.
            </summary>
            <value>The end <see cref="T:NodaTime.Instant"/>.</value>
            <exception cref="T:System.InvalidOperationException">The interval extends to the end of time.</exception>
            <seealso cref="P:NodaTime.Interval.HasEnd"/>
        </member>
        <member name="P:NodaTime.Interval.RawEnd">
            <summary>
            Returns the raw end value of the interval: a normal instant or <see cref="F:NodaTime.Instant.AfterMaxValue"/>.
            This value should never be exposed.
            </summary>
        </member>
        <member name="P:NodaTime.Interval.HasEnd">
            <summary>
            Returns <c>true</c> if this interval has a fixed end point, or <c>false</c> if it
            extends to the end of time.
            </summary>
            <value><c>true</c> if this interval has a fixed end point, or <c>false</c> if it
            extends to the end of time.</value>
        </member>
        <member name="P:NodaTime.Interval.Duration">
            <summary>
            Returns the duration of the interval.
            </summary>
            <remarks>
            This will always be a non-negative duration, though it may be zero.
            </remarks>
            <value>The duration of the interval.</value>
            <exception cref="T:System.InvalidOperationException">The interval extends to the start or end of time.</exception>
        </member>
        <member name="M:NodaTime.Interval.Contains(NodaTime.Instant)">
            <summary>
            Returns whether or not this interval contains the given instant.
            </summary>
            <param name="instant">Instant to test.</param>
            <returns>True if this interval contains the given instant; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.Interval.Deconstruct(System.Nullable{NodaTime.Instant}@,System.Nullable{NodaTime.Instant}@)">
            <summary>
            Deconstruct this value into its components.
            </summary>
            <param name="start">The start of the interval.</param>
            <param name="end">The end of the interval.</param>
        </member>
        <member name="M:NodaTime.Interval.Equals(NodaTime.Interval)">
            <summary>
            Indicates whether the value of this interval is equal to the value of the specified interval.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">The value to compare with this instance.</param>
            <returns>
            true if the value of this instant is equal to the value of the <paramref name="other" /> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.Interval.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.Interval.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Interval.ToString">
            <summary>
            Returns a string representation of this interval, in extended ISO-8601 format: the format
            is "start/end" where each instant uses a format of "uuuu'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFFF'Z'".
            If the start or end is infinite, the relevant part uses "StartOfTime" or "EndOfTime" to
            represent this.
            </summary>
            <returns>A string representation of this interval.</returns>
        </member>
        <member name="M:NodaTime.Interval.op_Equality(NodaTime.Interval,NodaTime.Interval)">
            <summary>
            Implements the operator ==.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:NodaTime.Interval.op_Inequality(NodaTime.Interval,NodaTime.Interval)">
            <summary>
            Implements the operator !=.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left.</param>
            <param name="right">The right.</param>
            <returns>The result of the operator.</returns>
        </member>
        <member name="M:NodaTime.Interval.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.Interval"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Interval.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.IsoDayOfWeek">
            <summary>
            Equates the days of the week with their numerical value according to
            ISO-8601. This corresponds with System.DayOfWeek except for Sunday, which
            is 7 in the ISO numbering and 0 in System.DayOfWeek.
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.None">
            <summary>
            Value indicating no day of the week; this will never be returned
            by any IsoDayOfWeek property, and is not valid as an argument to
            any method.
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Monday">
            <summary>
            Value representing Monday (1).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Tuesday">
            <summary>
            Value representing Tuesday (2).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Wednesday">
            <summary>
            Value representing Wednesday (3).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Thursday">
            <summary>
            Value representing Thursday (4).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Friday">
            <summary>
            Value representing Friday (5).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Saturday">
            <summary>
            Value representing Saturday (6).
            </summary>
        </member>
        <member name="F:NodaTime.IsoDayOfWeek.Sunday">
            <summary>
            Value representing Sunday (7).
            </summary>
        </member>
        <member name="T:NodaTime.LocalDate">
            <summary>
            LocalDate is an immutable struct representing a date within the calendar,
            with no reference to a particular time zone or time of day.
            </summary>
            <remarks>
            <para>
            Values can freely be compared for equality: a value in a different calendar system is not equal to
            a value in a different calendar system. However, ordering comparisons (either via the <see cref="M:NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)"/> method
            or via operators) fail with <see cref="T:System.ArgumentException"/>; attempting to compare values in different calendars
            almost always indicates a bug in the calling code.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.LocalDate.MaxIsoValue">
            <summary>
            The maximum (latest) date representable in the ISO calendar system.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDate.MinIsoValue">
            <summary>
            The minimum (earliest) date representable in the ISO calendar system.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(NodaTime.YearMonthDayCalendar)">
            <summary>
            Constructs an instance from values which are assumed to already have been validated.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(System.Int32)">
            <summary>
            Constructs an instance from the number of days since the unix epoch, in the ISO
            calendar system.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Constructs an instance from the number of days since the unix epoch, and a calendar
            system. The calendar system is assumed to be non-null, but the days since the epoch are
            validated.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs an instance for the given year, month and day in the ISO calendar.
            </summary>
            <param name="year">The year. This is the "absolute year", so a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <returns>The resulting date.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.</exception>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Constructs an instance for the given year, month and day in the specified calendar.
            </summary>
            <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="calendar">Calendar system in which to create the date.</param>
            <returns>The resulting date.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.</exception>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs an instance for the given era, year of era, month and day in the ISO calendar.
            </summary>
            <param name="era">The era within which to create a date. Must be a valid era within the ISO calendar.</param>
            <param name="yearOfEra">The year of era.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <returns>The resulting date.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.</exception>
        </member>
        <member name="M:NodaTime.LocalDate.#ctor(NodaTime.Calendars.Era,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Constructs an instance for the given era, year of era, month and day in the specified calendar.
            </summary>
            <param name="era">The era within which to create a date. Must be a valid era within the specified calendar.</param>
            <param name="yearOfEra">The year of era.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="calendar">Calendar system in which to create the date.</param>
            <returns>The resulting date.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date.</exception>
        </member>
        <member name="P:NodaTime.LocalDate.Calendar">
            <summary>Gets the calendar system associated with this local date.</summary>
            <value>The calendar system associated with this local date.</value>
        </member>
        <member name="P:NodaTime.LocalDate.Year">
            <summary>Gets the year of this local date.</summary>
            <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
            <value>The year of this local date.</value>
        </member>
        <member name="P:NodaTime.LocalDate.Month">
            <summary>Gets the month of this local date within the year.</summary>
            <value>The month of this local date within the year.</value>
        </member>
        <member name="P:NodaTime.LocalDate.Day">
            <summary>Gets the day of this local date within the month.</summary>
            <value>The day of this local date within the month.</value>
        </member>
        <member name="P:NodaTime.LocalDate.DaysSinceEpoch">
            <summary>Gets the number of days since the Unix epoch for this date.</summary>
            <value>The number of days since the Unix epoch for this date.</value>
        </member>
        <member name="P:NodaTime.LocalDate.DayOfWeek">
            <summary>
            Gets the week day of this local date expressed as an <see cref="T:NodaTime.IsoDayOfWeek"/> value.
            </summary>
            <value>The week day of this local date expressed as an <c>IsoDayOfWeek</c>.</value>
        </member>
        <member name="P:NodaTime.LocalDate.YearOfEra">
            <summary>Gets the year of this local date within the era.</summary>
            <value>The year of this local date within the era.</value>
        </member>
        <member name="P:NodaTime.LocalDate.Era">
            <summary>Gets the era of this local date.</summary>
            <value>The era of this local date.</value>
        </member>
        <member name="P:NodaTime.LocalDate.DayOfYear">
            <summary>Gets the day of this local date within the year.</summary>
            <value>The day of this local date within the year.</value>
        </member>
        <member name="M:NodaTime.LocalDate.AtMidnight">
            <summary>
            Gets a <see cref="T:NodaTime.LocalDateTime" /> at midnight on the date represented by this local date.
            </summary>
            <returns>The <see cref="T:NodaTime.LocalDateTime" /> representing midnight on this local date, in the same calendar
            system.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.ToDateTimeUnspecified">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this value which has a <see cref="P:System.DateTime.Kind" />
            of <see cref="F:System.DateTimeKind.Unspecified"/>. The result is midnight on the day represented
            by this value.
            </summary>
            <remarks>
            <para>
            <see cref="F:System.DateTimeKind.Unspecified"/> is slightly odd - it can be treated as UTC if you use <see cref="M:System.DateTime.ToLocalTime"/>
            or as system local time if you use <see cref="M:System.DateTime.ToUniversalTime"/>, but it's the only kind which allows
            you to construct a <see cref="T:System.DateTimeOffset"/> with an arbitrary offset, which makes it as close to
            the Noda Time non-system-specific "local" concept as exists in .NET.
            </para>
            <para>
            <see cref="T:System.DateTime"/> uses the Gregorian calendar by definition, so the value is implicitly converted
            to the Gregorian calendar first. The result will be on the same physical day,
            but the values returned by the Year/Month/Day properties of the <see cref="T:System.DateTime"/> may not
            match the Year/Month/Day properties of this value.
            </para>
            </remarks>
            <returns>A <see cref="T:System.DateTime"/> value for the same date and time as this value.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.FromDateTime(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime" /> of any kind to a LocalDate in the ISO calendar, ignoring the time of day.
            This does not perform any time zone conversions, so a DateTime with a <see cref="P:System.DateTime.Kind"/> of
            <see cref="F:System.DateTimeKind.Utc"/> will still represent the same year/month/day - it won't be converted into the local system time.
            </summary>
            <param name="dateTime">Value to convert into a Noda Time local date</param>
            <returns>A new <see cref="T:NodaTime.LocalDate"/> with the same values as the specified <c>DateTime</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.FromDateTime(System.DateTime,NodaTime.CalendarSystem)">
            <summary>
            Converts a <see cref="T:System.DateTime" /> of any kind to a LocalDate in the specified calendar, ignoring the time of day.
            This does not perform any time zone conversions, so a DateTime with a <see cref="P:System.DateTime.Kind"/> of
            <see cref="F:System.DateTimeKind.Utc"/> will still represent the same year/month/day - it won't be converted into the local system time.
            </summary>
            <param name="dateTime">Value to convert into a Noda Time local date</param>
            <param name="calendar">The calendar system to convert into</param>
            <returns>A new <see cref="T:NodaTime.LocalDate"/> with the same values as the specified <c>DateTime</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.FromWeekYearWeekAndDay(System.Int32,System.Int32,NodaTime.IsoDayOfWeek)">
            <summary>
            Returns the local date corresponding to the given "week year", "week of week year", and "day of week"
            in the ISO calendar system, using the ISO week-year rules.
            </summary>
            <param name="weekYear">ISO-8601 week year of value to return</param>
            <param name="weekOfWeekYear">ISO-8601 week of week year of value to return</param>
            <param name="dayOfWeek">ISO-8601 day of week to return</param>
            <returns>The date corresponding to the given week year / week of week year / day of week.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.FromYearMonthWeekAndDay(System.Int32,System.Int32,System.Int32,NodaTime.IsoDayOfWeek)">
            <summary>
            Returns the local date corresponding to a particular occurrence of a day-of-week
            within a year and month. For example, this method can be used to ask for "the third Monday in April 2012".
            </summary>
            <remarks>
            The returned date is always in the ISO calendar. This method is unrelated to week-years and any rules for
            "business weeks" and the like - if a month begins on a Friday, then asking for the first Friday will give
            that day, for example.
            </remarks>
            <param name="year">The year of the value to return.</param>
            <param name="month">The month of the value to return.</param>
            <param name="occurrence">The occurrence of the value to return, which must be in the range [1, 5]. The value 5 can
            be used to always return the last occurrence of the specified day-of-week, even if there are only 4
            occurrences of that day-of-week in the month.</param>
            <param name="dayOfWeek">The day-of-week of the value to return.</param>
            <returns>The date corresponding to the given year and month, on the given occurrence of the
            given day of week.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.ToYearMonth">
            <summary>
            Creates a <see cref="T:NodaTime.YearMonth"/> value for the month containing this date.
            </summary>
            <returns>A year/month value containing this date.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_Addition(NodaTime.LocalDate,NodaTime.Period)">
            <summary>
            Adds the specified period to the date.
            Fields are added in descending order of significance (years first, then months, and so on).
            </summary>
            <param name="date">The date to add the period to</param>
            <param name="period">The period to add. Must not contain any (non-zero) time units.</param>
            <returns>The sum of the given date and period</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Add(NodaTime.LocalDate,NodaTime.Period)">
            <summary>
            Adds the specified period to the date.
            Fields are added in descending order of significance (years first, then months, and so on).
            Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="date">The date to add the period to</param>
            <param name="period">The period to add. Must not contain any (non-zero) time units.</param>
            <returns>The sum of the given date and period</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Plus(NodaTime.Period)">
            <summary>
            Adds the specified period to this date.
            Fields are added in descending order of significance (years first, then months, and so on).
            Fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="period">The period to add. Must not contain any (non-zero) time units.</param>
            <returns>The sum of this date and the given period</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_Addition(NodaTime.LocalDate,NodaTime.LocalTime)">
            <summary>
            Combines the given <see cref="T:NodaTime.LocalDate"/> and <see cref="T:NodaTime.LocalTime"/> components
            into a single <see cref="T:NodaTime.LocalDateTime"/>.
            </summary>
            <param name="date">The date to add the time to</param>
            <param name="time">The time to add</param>
            <returns>The sum of the given date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_Subtraction(NodaTime.LocalDate,NodaTime.Period)">
            <summary>
            Subtracts the specified period from the date.
            Fields are subtracted in descending order of significance (years first, then months, and so on).
            This is a convenience operator over the <see cref="M:NodaTime.LocalDate.Minus(NodaTime.Period)"/> method.
            </summary>
            <param name="date">The date to subtract the period from</param>
            <param name="period">The period to subtract. Must not contain any (non-zero) time units.</param>
            <returns>The result of subtracting the given period from the date</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Subtract(NodaTime.LocalDate,NodaTime.Period)">
            <summary>
            Subtracts the specified period from the date.
            Fields are subtracted in descending order of significance (years first, then months, and so on).
            Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="date">The date to subtract the period from</param>
            <param name="period">The period to subtract. Must not contain any (non-zero) time units.</param>
            <returns>The result of subtracting the given period from the date.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Minus(NodaTime.Period)">
            <summary>
            Subtracts the specified period from this date.
            Fields are subtracted in descending order of significance (years first, then months, and so on).
            Fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="period">The period to subtract. Must not contain any (non-zero) time units.</param>
            <returns>The result of subtracting the given period from this date.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_Subtraction(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Subtracts one date from another, returning the result as a <see cref="T:NodaTime.Period"/> with units of years, months and days.
            </summary>
            <remarks>
            This is simply a convenience operator for calling <see cref="M:NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate)"/>.
            The calendar systems of the two dates must be the same; an exception will be thrown otherwise.
            </remarks>
            <param name="lhs">The date to subtract from</param>
            <param name="rhs">The date to subtract</param>
            <returns>The result of subtracting one date from another.</returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="lhs"/> and <paramref name="rhs"/> are not in the same calendar system.
            </exception>
        </member>
        <member name="M:NodaTime.LocalDate.Subtract(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Subtracts one date from another, returning the result as a <see cref="T:NodaTime.Period"/> with units of years, months and days.
            </summary>
            <remarks>
            This is simply a convenience method for calling <see cref="M:NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate)"/>.
            The calendar systems of the two dates must be the same.
            </remarks>
            <param name="lhs">The date to subtract from</param>
            <param name="rhs">The date to subtract</param>
            <returns>The result of subtracting one date from another.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Minus(NodaTime.LocalDate)">
            <summary>
            Subtracts the specified date from this date, returning the result as a <see cref="T:NodaTime.Period"/> with units of years, months and days.
            Fluent alternative to <c>operator-()</c>.
            </summary>
            <remarks>The specified date must be in the same calendar system as this.</remarks>
            <param name="date">The date to subtract from this</param>
            <returns>The difference between the specified date and this one</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_Equality(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two <see cref="T:NodaTime.LocalDate" /> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>True if the two dates are the same and in the same calendar; false otherwise</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_Inequality(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two <see cref="T:NodaTime.LocalDate" /> values for inequality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>False if the two dates are the same and in the same calendar; true otherwise</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_LessThan(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two dates to see if the left one is strictly earlier than the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is strictly earlier than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_LessThanOrEqual(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two dates to see if the left one is earlier than or equal to the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is earlier than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_GreaterThan(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two dates to see if the left one is strictly later than the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is strictly later than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.op_GreaterThanOrEqual(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Compares two dates to see if the left one is later than or equal to the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is later than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.CompareTo(NodaTime.LocalDate)">
            <summary>
            Indicates whether this date is earlier, later or the same as another one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="other">The other date to compare this one with</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="other"/> is not the
            same as the calendar system of this value.</exception>
            <returns>A value less than zero if this date is earlier than <paramref name="other"/>;
            zero if this date is the same as <paramref name="other"/>; a value greater than zero if this date is
            later than <paramref name="other"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.TrustedCompareTo(NodaTime.LocalDate)">
            <summary>
            Performs a comparison with another date, trusting that the calendar of the other date is already correct.
            This avoids duplicate calendar checks.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDate.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two LocalDates.
            See the type documentation for a description of ordering semantics.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.LocalDate"/>, or refers
            to a date in a different calendar system.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this LocalDate with another one.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDate.Max(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Returns the later date of the given two.
            </summary>
            <param name="x">The first date to compare.</param>
            <param name="y">The second date to compare.</param>
            <exception cref="T:System.ArgumentException">The two dates have different calendar systems.</exception>
            <returns>The later date of <paramref name="x"/> or <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Min(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Returns the earlier date of the given two.
            </summary>
            <param name="x">The first date to compare.</param>
            <param name="y">The second date to compare.</param>
            <exception cref="T:System.ArgumentException">The two dates have different calendar systems.</exception>
            <returns>The earlier date of <paramref name="x"/> or <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.GetHashCode">
            <summary>
            Returns a hash code for this local date.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>A hash code for this local date.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:NodaTime.LocalDate"/> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The object to compare this date with.</param>
            <returns>True if the given value is another local date equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Equals(NodaTime.LocalDate)">
            <summary>
            Compares two <see cref="T:NodaTime.LocalDate"/> values for equality.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="other">The value to compare this date with.</param>
            <returns>True if the given value is another local date equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.AtStartOfDayInZone(NodaTime.DateTimeZone)">
            <summary>
            Resolves this local date into a <see cref="T:NodaTime.ZonedDateTime"/> in the given time zone representing the
            start of this date in the given zone.
            </summary>
            <remarks>
            This is a convenience method for calling <see cref="M:NodaTime.DateTimeZone.AtStartOfDay(NodaTime.LocalDate)"/>.
            </remarks>
            <param name="zone">The time zone to map this local date into</param>
            <exception cref="T:NodaTime.SkippedTimeException">The entire day was skipped due to a very large time zone transition.
            (This is extremely rare.)</exception>
            <returns>The <see cref="T:NodaTime.ZonedDateTime"/> representing the earliest time on this date, in the given time zone.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a new LocalDate representing the same physical date, but in a different calendar.
            The returned LocalDate is likely to have different field values to this one.
            For example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.
            </summary>
            <param name="calendar">The calendar system to convert this local date to.</param>
            <returns>The converted LocalDate</returns>
        </member>
        <member name="M:NodaTime.LocalDate.PlusYears(System.Int32)">
            <summary>
            Returns a new LocalDate representing the current value with the given number of years added.
            </summary>
            <remarks>
            If the resulting date is invalid, lower fields (typically the day of month) are reduced to find a valid value.
            For example, adding one year to February 29th 2012 will return February 28th 2013; subtracting one year from
            February 29th 2012 will return February 28th 2011.
            </remarks>
            <param name="years">The number of years to add</param>
            <returns>The current value plus the given number of years.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.PlusMonths(System.Int32)">
            <summary>
            Returns a new LocalDate representing the current value with the given number of months added.
            </summary>
            <remarks>
            <para>
            This method does not try to maintain the year of the current value, so adding four months to a value in 
            October will result in a value in the following February.
            </para>
            <para>
            If the resulting date is invalid, the day of month is reduced to find a valid value.
            For example, adding one month to January 30th 2011 will return February 28th 2011; subtracting one month from
            March 30th 2011 will return February 28th 2011.
            </para>
            </remarks>
            <param name="months">The number of months to add</param>
            <returns>The current date plus the given number of months</returns>
        </member>
        <member name="M:NodaTime.LocalDate.PlusDays(System.Int32)">
            <summary>
            Returns a new LocalDate representing the current value with the given number of days added.
            </summary>
            <remarks>
            <para>
            This method does not try to maintain the month or year of the current value, so adding 3 days to a value of January 30th
            will result in a value of February 2nd.
            </para>
            </remarks>
            <param name="days">The number of days to add</param>
            <returns>The current value plus the given number of days.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.PlusWeeks(System.Int32)">
            <summary>
            Returns a new LocalDate representing the current value with the given number of weeks added.
            </summary>
            <param name="weeks">The number of weeks to add</param>
            <returns>The current value plus the given number of weeks.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Next(NodaTime.IsoDayOfWeek)">
            <summary>
            Returns the next <see cref="T:NodaTime.LocalDate" /> falling on the specified <see cref="T:NodaTime.IsoDayOfWeek"/>.
            This is a strict "next" - if this date on already falls on the target
            day of the week, the returned value will be a week later.
            </summary>
            <param name="targetDayOfWeek">The ISO day of the week to return the next date of.</param>
            <returns>The next <see cref="T:NodaTime.LocalDate"/> falling on the specified day of the week.</returns>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetDayOfWeek"/> is not a valid day of the
            week (Monday to Sunday).</exception>
        </member>
        <member name="M:NodaTime.LocalDate.Previous(NodaTime.IsoDayOfWeek)">
            <summary>
            Returns the previous <see cref="T:NodaTime.LocalDate" /> falling on the specified <see cref="T:NodaTime.IsoDayOfWeek"/>.
            This is a strict "previous" - if this date on already falls on the target
            day of the week, the returned value will be a week earlier.
            </summary>
            <param name="targetDayOfWeek">The ISO day of the week to return the previous date of.</param>
            <returns>The previous <see cref="T:NodaTime.LocalDate"/> falling on the specified day of the week.</returns>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetDayOfWeek"/> is not a valid day of the
            week (Monday to Sunday).</exception>
        </member>
        <member name="M:NodaTime.LocalDate.WithOffset(NodaTime.Offset)">
            <summary>
            Returns an <see cref="T:NodaTime.OffsetDate"/> for this local date with the given offset.
            </summary>
            <remarks>This method is purely a convenient alternative to calling the <see cref="T:NodaTime.OffsetDate"/> constructor directly.</remarks>
            <param name="offset">The offset to apply.</param>
            <returns>The result of this date offset by the given amount.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.At(NodaTime.LocalTime)">
            <summary>
            Combines this <see cref="T:NodaTime.LocalDate"/> with the given <see cref="T:NodaTime.LocalTime"/>
            into a single <see cref="T:NodaTime.LocalDateTime"/>.
            Fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="time">The time to combine with this date.</param>
            <returns>The <see cref="T:NodaTime.LocalDateTime"/> representation of the given time on this date</returns>
        </member>
        <member name="M:NodaTime.LocalDate.With(System.Func{NodaTime.LocalDate,NodaTime.LocalDate})">
            <summary>
            Returns this date, with the given adjuster applied to it.
            </summary>
            <remarks>
            If the adjuster attempts to construct an invalid date (such as by trying
            to set a day-of-month of 30 in February), any exception thrown by
            that construction attempt will be propagated through this method.
            </remarks>
            <param name="adjuster">The adjuster to apply.</param>
            <returns>The adjusted date.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.Deconstruct(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Deconstructs the current instance into its components.
            </summary>
            <param name="year">The year component of the date.</param>
            <param name="month">The month component of the date.</param>
            <param name="day">The day component of the date.</param>
        </member>
        <member name="M:NodaTime.LocalDate.Deconstruct(System.Int32@,System.Int32@,System.Int32@,NodaTime.CalendarSystem@)">
            <summary>
            Deconstructs the current instance into its components.
            </summary>
            <param name="year">The year component of the date.</param>
            <param name="month">The month component of the date.</param>
            <param name="day">The day component of the date.</param>
            <param name="calendar">The <see cref="T:NodaTime.CalendarSystem"/> associated with the date.</param>
        </member>
        <member name="M:NodaTime.LocalDate.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("D"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDate.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("D").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.LocalDate.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.LocalTime"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            the <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalDate.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.LocalDateTime">
            <summary>
            A date and time in a particular calendar system. A LocalDateTime value does not represent an
            instant on the global time line, because it has no associated time zone: "November 12th 2009 7pm, ISO calendar"
            occurred at different instants for different people around the world.
            </summary>
            <remarks>
            <para>
            This type defaults to using the ISO calendar system unless a different calendar system is
            specified.
            </para>
            <para>
            Values can freely be compared for equality: a value in a different calendar system is not equal to
            a value in a different calendar system. However, ordering comparisons (either via the <see cref="M:NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)"/> method
            or via operators) fail with <see cref="T:System.ArgumentException"/>; attempting to compare values in different calendars
            almost always indicates a bug in the calling code.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.LocalDateTime.MaxIsoValue">
            <summary>
            The maximum (latest) date and time representable in the ISO calendar system.
            This is a nanosecond before midnight at the end of <see cref="P:NodaTime.LocalDate.MaxIsoValue"/>.
            </summary>
        </member>
        <member name="P:NodaTime.LocalDateTime.MinIsoValue">
            <summary>
            The minimum (earliest) date and time representable in the ISO calendar system.
            This is midnight at the start of <see cref="P:NodaTime.LocalDate.MinIsoValue"/>.
            </summary>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(NodaTime.LocalInstant)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct using the ISO
            calendar system.
            </summary>
            <param name="localInstant">The local instant.</param>
            <returns>The resulting date/time.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct using the ISO calendar system.
            </summary>
            <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="calendar">The calendar.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct using the ISO calendar system.
            </summary>
            <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="calendar">The calendar.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct using the ISO calendar system.
            </summary>
            <param name="year">The year. This is the "absolute year",
            so a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="millisecond">The millisecond.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalDateTime"/> struct.
            </summary>
            <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="day">The day of month.</param>
            <param name="hour">The hour.</param>
            <param name="minute">The minute.</param>
            <param name="second">The second.</param>
            <param name="millisecond">The millisecond.</param>
            <param name="calendar">The calendar.</param>
            <returns>The resulting date/time.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid date/time.</exception>
        </member>
        <member name="P:NodaTime.LocalDateTime.Calendar">
            <summary>Gets the calendar system associated with this local date and time.</summary>
            <value>The calendar system associated with this local date and time.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.Year">
            <summary>Gets the year of this local date and time.</summary>
            <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
            <value>The year of this local date and time.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.YearOfEra">
            <summary>Gets the year of this local date and time within its era.</summary>
            <value>The year of this local date and time within its era.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.Era">
            <summary>Gets the era of this local date and time.</summary>
            <value>The era of this local date and time.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.Month">
            <summary>
            Gets the month of this local date and time within the year.
            </summary>
            <value>The month of this local date and time within the year.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.DayOfYear">
            <summary>
            Gets the day of this local date and time within the year.
            </summary>
            <value>The day of this local date and time within the year.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.Day">
            <summary>
            Gets the day of this local date and time within the month.
            </summary>
            <value>The day of this local date and time within the month.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.DayOfWeek">
            <summary>
            Gets the week day of this local date and time expressed as an <see cref="T:NodaTime.IsoDayOfWeek"/> value.
            </summary>
            <value>The week day of this local date and time expressed as an <c>IsoDayOfWeek</c>.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.Hour">
            <summary>
            Gets the hour of day of this local date and time, in the range 0 to 23 inclusive.
            </summary>
            <value>The hour of day of this local date and time, in the range 0 to 23 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.ClockHourOfHalfDay">
            <summary>
            Gets the hour of the half-day of this local date and time, in the range 1 to 12 inclusive.
            </summary>
            <value>The hour of the half-day of this local date and time, in the range 1 to 12 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.Minute">
            <summary>
            Gets the minute of this local date and time, in the range 0 to 59 inclusive.
            </summary>
            <value>The minute of this local date and time, in the range 0 to 59 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.Second">
            <summary>
            Gets the second of this local date and time within the minute, in the range 0 to 59 inclusive.
            </summary>
            <value>The second of this local date and time within the minute, in the range 0 to 59 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.Millisecond">
            <summary>
            Gets the millisecond of this local date and time within the second, in the range 0 to 999 inclusive.
            </summary>
            <value>The millisecond of this local date and time within the second, in the range 0 to 999 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.TickOfSecond">
            <summary>
            Gets the tick of this local time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
            <value>The tick of this local time within the second, in the range 0 to 9,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.TickOfDay">
            <summary>
            Gets the tick of this local date and time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
            <value>The tick of this local date and time within the day, in the range 0 to 863,999,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.NanosecondOfSecond">
            <summary>
            Gets the nanosecond of this local time within the second, in the range 0 to 999,999,999 inclusive.
            </summary>
            <value>The nanosecond of this local time within the second, in the range 0 to 999,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.NanosecondOfDay">
            <summary>
            Gets the nanosecond of this local date and time within the day, in the range 0 to 86,399,999,999,999 inclusive.
            </summary>
            <value>The nanosecond of this local date and time within the day, in the range 0 to 86,399,999,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.TimeOfDay">
            <summary>
            Gets the time portion of this local date and time as a <see cref="T:NodaTime.LocalTime"/>.
            </summary>
            <value>The time portion of this local date and time as a <c>LocalTime</c>.</value>
        </member>
        <member name="P:NodaTime.LocalDateTime.Date">
            <summary>
            Gets the date portion of this local date and time as a <see cref="T:NodaTime.LocalDate"/> in the same calendar system as this value.
            </summary>
            <value>The date portion of this local date and time as a <c>LocalDate</c> in the same calendar system as this value.</value>
        </member>
        <member name="M:NodaTime.LocalDateTime.ToDateTimeUnspecified">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this value which has a <see cref="P:System.DateTime.Kind" />
            of <see cref="F:System.DateTimeKind.Unspecified"/>.
            </summary>
            <remarks>
            <para>
            <see cref="F:System.DateTimeKind.Unspecified"/> is slightly odd - it can be treated as UTC if you use <see cref="M:System.DateTime.ToLocalTime"/>
            or as system local time if you use <see cref="M:System.DateTime.ToUniversalTime"/>, but it's the only kind which allows
            you to construct a <see cref="T:System.DateTimeOffset"/> with an arbitrary offset, which makes it as close to
            the Noda Time non-system-specific "local" concept as exists in .NET.
            </para>
            <para>
            If the date and time is not on a tick boundary (the unit of granularity of DateTime) the value will be truncated
            towards the start of time.
            </para>
            <para>
            <see cref="T:System.DateTime"/> uses the Gregorian calendar by definition, so the value is implicitly converted
            to the Gregorian calendar first. The result will be on the same physical day,
            but the values returned by the Year/Month/Day properties of the <see cref="T:System.DateTime"/> may not
            match the Year/Month/Day properties of this value.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The date/time is outside the range of <c>DateTime</c>.</exception>
            <returns>A <see cref="T:System.DateTime"/> value for the same date and time as this value.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.FromDateTime(System.DateTime)">
            <summary>
            Converts a <see cref="T:System.DateTime" /> of any kind to a LocalDateTime in the ISO calendar. This does not perform
            any time zone conversions, so a DateTime with a <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Utc"/>
            will still have the same day/hour/minute etc - it won't be converted into the local system time.
            </summary>
            <param name="dateTime">Value to convert into a Noda Time local date and time</param>
            <returns>A new <see cref="T:NodaTime.LocalDateTime"/> with the same values as the specified <c>DateTime</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.FromDateTime(System.DateTime,NodaTime.CalendarSystem)">
            <summary>
            Converts a <see cref="T:System.DateTime" /> of any kind to a LocalDateTime in the specified calendar. This does not perform
            any time zone conversions, so a DateTime with a <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Utc"/>
            will still have the same day/hour/minute etc - it won't be converted into the local system time.
            </summary>
            <param name="dateTime">Value to convert into a Noda Time local date and time</param>
            <param name="calendar">The calendar system to convert into</param>
            <returns>A new <see cref="T:NodaTime.LocalDateTime"/> with the same values as the specified <c>DateTime</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Equals(NodaTime.LocalDateTime)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Equality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Implements the operator == (equality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Inequality(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Implements the operator != (inequality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_LessThan(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Compares two LocalDateTime values to see if the left one is strictly earlier than the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is strictly earlier than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_LessThanOrEqual(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Compares two LocalDateTime values to see if the left one is earlier than or equal to the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is earlier than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_GreaterThan(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Compares two LocalDateTime values to see if the left one is strictly later than the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is strictly later than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_GreaterThanOrEqual(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Compares two LocalDateTime values to see if the left one is later than or equal to the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is later than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)">
            <summary>
            Indicates whether this date/time is earlier, later or the same as another one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="other">The other local date/time to compare with this value.</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="other"/> is not the
            same as the calendar system of this value.</exception>
            <returns>A value less than zero if this date/time is earlier than <paramref name="other"/>;
            zero if this date/time is the same as <paramref name="other"/>; a value greater than zero if this date/time is
            later than <paramref name="other"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two LocalDateTimes.
            See the type documentation for a description of ordering semantics.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.LocalDateTime"/>,
            or refers to a date/time in a different calendar system.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this LocalDateTime with another one; see <see cref="M:NodaTime.LocalDateTime.CompareTo(NodaTime.LocalDateTime)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Addition(NodaTime.LocalDateTime,NodaTime.Period)">
            <summary>
            Adds a period to a local date/time.
            Fields are added in descending order of significance (years first, then months, and so on).
            This is a convenience operator over the <see cref="M:NodaTime.LocalDateTime.Plus(NodaTime.Period)"/> method.
            </summary>
            <param name="localDateTime">Initial local date and time</param>
            <param name="period">Period to add</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Add(NodaTime.LocalDateTime,NodaTime.Period)">
            <summary>
            Add the specified period to the date and time.
            Fields are added in descending order of significance (years first, then months, and so on).
            Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="localDateTime">Initial local date and time</param>
            <param name="period">Period to add</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Plus(NodaTime.Period)">
            <summary>
            Adds a period to this local date/time.
            Fields are added in descending order of significance (years first, then months, and so on).
            </summary>
            <param name="period">Period to add</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Subtraction(NodaTime.LocalDateTime,NodaTime.Period)">
            <summary>
            Subtracts a period from a local date/time.
            Fields are subtracted in descending order of significance (years first, then months, and so on).
            This is a convenience operator over the <see cref="M:NodaTime.LocalDateTime.Minus(NodaTime.Period)"/> method.
            </summary>
            <param name="localDateTime">Initial local date and time</param>
            <param name="period">Period to subtract</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Subtract(NodaTime.LocalDateTime,NodaTime.Period)">
            <summary>
            Subtracts the specified period from the date and time. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="localDateTime">Initial local date and time</param>
            <param name="period">Period to subtract</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Minus(NodaTime.Period)">
            <summary>
            Subtracts a period from a local date/time.
            Fields are subtracted in descending order of significance (years first, then months, and so on).
            </summary>
            <param name="period">Period to subtract</param>
            <returns>The resulting local date and time</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.op_Subtraction(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Subtracts one date/time from another, returning the result as a <see cref="T:NodaTime.Period"/>.
            </summary>
            <remarks>
            This is simply a convenience operator for calling <see cref="M:NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime)"/>.
            The calendar systems of the two date/times must be the same.
            </remarks>
            <param name="lhs">The date/time to subtract from</param>
            <param name="rhs">The date/time to subtract</param>
            <returns>The result of subtracting one date/time from another.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Subtract(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Subtracts one date/time from another, returning the result as a <see cref="T:NodaTime.Period"/>.
            </summary>
            <remarks>
            This is simply a convenience method for calling <see cref="M:NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime)"/>.
            The calendar systems of the two date/times must be the same.
            </remarks>
            <param name="lhs">The date/time to subtract from</param>
            <param name="rhs">The date/time to subtract</param>
            <returns>The result of subtracting one date/time from another.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Minus(NodaTime.LocalDateTime)">
            <summary>
            Subtracts the specified date/time from this date/time, returning the result as a <see cref="T:NodaTime.Period"/>.
            Fluent alternative to <c>operator-()</c>.
            </summary>
            <remarks>The specified date/time must be in the same calendar system as this.</remarks>
            <param name="localDateTime">The date/time to subtract from this</param>
            <returns>The difference between the specified date/time and this one</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.With(System.Func{NodaTime.LocalDate,NodaTime.LocalDate})">
            <summary>
            Returns this date/time, with the given date adjuster applied to it, maintaining the existing time of day.
            </summary>
            <remarks>
            If the adjuster attempts to construct an
            invalid date (such as by trying to set a day-of-month of 30 in February), any exception thrown by
            that construction attempt will be propagated through this method.
            </remarks>
            <param name="adjuster">The adjuster to apply.</param>
            <returns>The adjusted date/time.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.With(System.Func{NodaTime.LocalTime,NodaTime.LocalTime})">
            <summary>
            Returns this date/time, with the given time adjuster applied to it, maintaining the existing date.
            </summary>
            <remarks>
            If the adjuster attempts to construct an invalid time, any exception thrown by
            that construction attempt will be propagated through this method.
            </remarks>
            <param name="adjuster">The adjuster to apply.</param>
            <returns>The adjusted date/time.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a new LocalDateTime representing the same physical date and time, but in a different calendar.
            The returned LocalDateTime is likely to have different date field values to this one.
            For example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.
            </summary>
            <param name="calendar">The calendar system to convert this local date to.</param>
            <returns>The converted LocalDateTime.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusYears(System.Int32)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of years added.
            </summary>
            <remarks>
            If the resulting date is invalid, lower fields (typically the day of month) are reduced to find a valid value.
            For example, adding one year to February 29th 2012 will return February 28th 2013; subtracting one year from
            February 29th 2012 will return February 28th 2011.
            </remarks>
            <param name="years">The number of years to add</param>
            <returns>The current value plus the given number of years.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusMonths(System.Int32)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of months added.
            </summary>
            <remarks>
            <para>
            This method does not try to maintain the year of the current value, so adding four months to a value in 
            October will result in a value in the following February.
            </para>
            <para>
            If the resulting date is invalid, the day of month is reduced to find a valid value.
            For example, adding one month to January 30th 2011 will return February 28th 2011; subtracting one month from
            March 30th 2011 will return February 28th 2011.
            </para>
            </remarks>
            <param name="months">The number of months to add</param>
            <returns>The current value plus the given number of months.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusDays(System.Int32)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of days added.
            </summary>
            <remarks>
            <para>
            This method does not try to maintain the month or year of the current value, so adding 3 days to a value on January 30th
            will result in a value on February 2nd.
            </para>
            </remarks>
            <param name="days">The number of days to add</param>
            <returns>The current value plus the given number of days.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusWeeks(System.Int32)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of weeks added.
            </summary>
            <param name="weeks">The number of weeks to add</param>
            <returns>The current value plus the given number of weeks.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusHours(System.Int64)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of hours added.
            </summary>
            <param name="hours">The number of hours to add</param>
            <returns>The current value plus the given number of hours.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusMinutes(System.Int64)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of minutes added.
            </summary>
            <param name="minutes">The number of minutes to add</param>
            <returns>The current value plus the given number of minutes.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusSeconds(System.Int64)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of seconds added.
            </summary>
            <param name="seconds">The number of seconds to add</param>
            <returns>The current value plus the given number of seconds.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusMilliseconds(System.Int64)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of milliseconds added.
            </summary>
            <param name="milliseconds">The number of milliseconds to add</param>
            <returns>The current value plus the given number of milliseconds.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusTicks(System.Int64)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of ticks added.
            </summary>
            <param name="ticks">The number of ticks to add</param>
            <returns>The current value plus the given number of ticks.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.PlusNanoseconds(System.Int64)">
            <summary>
            Returns a new LocalDateTime representing the current value with the given number of nanoseconds added.
            </summary>
            <param name="nanoseconds">The number of nanoseconds to add</param>
            <returns>The current value plus the given number of nanoseconds.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Next(NodaTime.IsoDayOfWeek)">
            <summary>
            Returns the next <see cref="T:NodaTime.LocalDateTime" /> falling on the specified <see cref="T:NodaTime.IsoDayOfWeek"/>,
            at the same time of day as this value.
            This is a strict "next" - if this value on already falls on the target
            day of the week, the returned value will be a week later.
            </summary>
            <param name="targetDayOfWeek">The ISO day of the week to return the next date of.</param>
            <returns>The next <see cref="T:NodaTime.LocalDateTime"/> falling on the specified day of the week.</returns>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetDayOfWeek"/> is not a valid day of the
            week (Monday to Sunday).</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.Previous(NodaTime.IsoDayOfWeek)">
            <summary>
            Returns the previous <see cref="T:NodaTime.LocalDateTime" /> falling on the specified <see cref="T:NodaTime.IsoDayOfWeek"/>,
            at the same time of day as this value.
            This is a strict "previous" - if this value on already falls on the target
            day of the week, the returned value will be a week earlier.
            </summary>
            <param name="targetDayOfWeek">The ISO day of the week to return the previous date of.</param>
            <returns>The previous <see cref="T:NodaTime.LocalDateTime"/> falling on the specified day of the week.</returns>
            <exception cref="T:System.InvalidOperationException">The underlying calendar doesn't use ISO days of the week.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="targetDayOfWeek"/> is not a valid day of the
            week (Monday to Sunday).</exception>
        </member>
        <member name="M:NodaTime.LocalDateTime.WithOffset(NodaTime.Offset)">
            <summary>
            Returns an <see cref="T:NodaTime.OffsetDateTime"/> for this local date/time with the given offset.
            </summary>
            <remarks>This method is purely a convenient alternative to calling the <see cref="T:NodaTime.OffsetDateTime"/> constructor directly.</remarks>
            <param name="offset">The offset to apply.</param>
            <returns>The result of this local date/time offset by the given amount.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.InUtc">
            <summary>
            Returns the mapping of this local date/time within <see cref="P:NodaTime.DateTimeZone.Utc"/>.
            </summary>
            <remarks>As UTC is a fixed time zone, there is no chance that this local date/time is ambiguous or skipped.</remarks>
            <returns>The result of mapping this local date/time in UTC.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)">
            <summary>
            Returns the mapping of this local date/time within the given <see cref="T:NodaTime.DateTimeZone" />,
            with "strict" rules applied such that an exception is thrown if either the mapping is
            ambiguous or the time is skipped.
            </summary>
            <remarks>
            See <see cref="M:NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)"/> and <see cref="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> for alternative ways to map a local time to a
            specific instant.
            This is solely a convenience method for calling <see cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)" />.
            </remarks>
            <param name="zone">The time zone in which to map this local date/time.</param>
            <exception cref="T:NodaTime.SkippedTimeException">This local date/time is skipped in the given time zone.</exception>
            <exception cref="T:NodaTime.AmbiguousTimeException">This local date/time is ambiguous in the given time zone.</exception>
            <returns>The result of mapping this local date/time in the given time zone.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)">
            <summary>
            Returns the mapping of this local date/time within the given <see cref="T:NodaTime.DateTimeZone" />,
            with "lenient" rules applied such that ambiguous values map to the earlier of the alternatives, and
            "skipped" values are shifted forward by the duration of the "gap".
            </summary>
            <remarks>
            See <see cref="M:NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)"/> and <see cref="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> for alternative ways to map a local time to a
            specific instant.
            This is solely a convenience method for calling <see cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)" />.
            <para>Note: The behavior of this method was changed in version 2.0 to fit the most commonly seen real-world
            usage pattern.  Previous versions returned the later instance of ambiguous values, and returned the start of
            the zone interval after the gap for skipped value.  The previous functionality can still be used if desired,
            by using <see cref="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> and passing a resolver that combines the
            <see cref="P:NodaTime.TimeZones.Resolvers.ReturnLater"/> and <see cref="P:NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter"/> resolvers.</para>
            </remarks>
            <param name="zone">The time zone in which to map this local date/time.</param>
            <returns>The result of mapping this local date/time in the given time zone.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)">
            <summary>
            Resolves this local date and time into a <see cref="T:NodaTime.ZonedDateTime"/> in the given time zone, following
            the given <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/> to handle ambiguity and skipped times.
            </summary>
            <remarks>
            See <see cref="M:NodaTime.LocalDateTime.InZoneStrictly(NodaTime.DateTimeZone)"/> and <see cref="M:NodaTime.LocalDateTime.InZoneLeniently(NodaTime.DateTimeZone)"/> for alternative ways to map a local time
            to a specific instant.
            This is a convenience method for calling <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/>.
            </remarks>
            <param name="zone">The time zone to map this local date and time into</param>
            <param name="resolver">The resolver to apply to the mapping.</param>
            <returns>The result of resolving the mapping.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Deconstruct(NodaTime.LocalDate@,NodaTime.LocalTime@)">
            <summary>
            Deconstruct this <see cref="T:NodaTime.LocalDateTime"/> into its components.
            </summary>
            <param name="date">The date portion of the value.</param>
            <param name="time">The time portion of the value.</param>
        </member>
        <member name="M:NodaTime.LocalDateTime.Max(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Returns the later date/time of the given two.
            </summary>
            <param name="x">The first date/time to compare.</param>
            <param name="y">The second date/time to compare.</param>
            <exception cref="T:System.ArgumentException">The two date/times have different calendar systems.</exception>
            <returns>The later date/time of <paramref name="x"/> or <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.Min(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Returns the earlier date/time of the given two.
            </summary>
            <param name="x">The first date/time to compare.</param>
            <param name="y">The second date/time to compare.</param>
            <exception cref="T:System.ArgumentException">The two date/times have different calendar systems.</exception>
            <returns>The earlier date/time of <paramref name="x"/> or <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("G"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("G").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.LocalDateTime.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.LocalDateTime"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            the <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.LocalInstant">
            <summary>
            Represents a local date and time without reference to a calendar system. Essentially
            this is a duration since a Unix epoch shifted by an offset (but we don't store what that
            offset is). This class has been slimmed down considerably over time - it's used much less
            than it used to be... almost solely for time zones.
            </summary>
        </member>
        <member name="F:NodaTime.LocalInstant.duration">
            <summary>
            Elapsed time since the local 1970-01-01T00:00:00.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructor which should *only* be used to construct the invalid instances.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.#ctor(NodaTime.Duration)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalInstant"/> struct.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.#ctor(System.Int32,System.Int64)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.LocalInstant"/> struct.
            </summary>
            <param name="days">Number of days since 1970-01-01, in a time zone neutral fashion.</param>
            <param name="nanoOfDay">Nanosecond of the local day.</param>
        </member>
        <member name="P:NodaTime.LocalInstant.IsValid">
            <summary>
            Returns whether or not this is a valid instant. Returns true for all but
            <see cref="F:NodaTime.LocalInstant.BeforeMinValue"/> and <see cref="F:NodaTime.LocalInstant.AfterMaxValue"/>.
            </summary>
        </member>
        <member name="P:NodaTime.LocalInstant.TimeSinceLocalEpoch">
            <summary>
            Number of nanoseconds since the local unix epoch.
            </summary>
        </member>
        <member name="P:NodaTime.LocalInstant.DaysSinceEpoch">
            <summary>
            Number of days since the local unix epoch.
            </summary>
        </member>
        <member name="P:NodaTime.LocalInstant.NanosecondOfDay">
            <summary>
            Nanosecond within the day.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.MinusZeroOffset">
            <summary>
            Returns a new instant based on this local instant, as if we'd applied a zero offset.
            This is just a slight optimization over calling <c>localInstant.Minus(Offset.Zero)</c>.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.Minus(NodaTime.Offset)">
            <summary>
            Subtracts the given time zone offset from this local instant, to give an <see cref="T:NodaTime.Instant" />.
            </summary>
            <remarks>
            This would normally be implemented as an operator, but as the corresponding "plus" operation
            on Instant cannot be written (as Instant is a public type and LocalInstant is an internal type)
            it makes sense to keep them both as methods for consistency.
            </remarks>
            <param name="offset">The offset between UTC and a time zone for this local instant</param>
            <returns>A new <see cref="T:NodaTime.Instant"/> representing the difference of the given values.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_Equality(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.SafeMinus(NodaTime.Offset)">
            <summary>
            Equivalent to <see cref="M:NodaTime.Instant.SafePlus(NodaTime.Offset)"/>, but in the opposite direction.
            </summary>
        </member>
        <member name="M:NodaTime.LocalInstant.op_Inequality(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_LessThan(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator &lt; (less than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_LessThanOrEqual(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator &lt;= (less than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_GreaterThan(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator &gt; (greater than).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.op_GreaterThanOrEqual(NodaTime.LocalInstant,NodaTime.LocalInstant)">
            <summary>
            Implements the operator &gt;= (greater than or equal).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.LocalInstant.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.LocalInstant.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.LocalInstant.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:NodaTime.LocalInstant.Equals(NodaTime.LocalInstant)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="T:NodaTime.LocalTime">
            <summary>
            LocalTime is an immutable struct representing a time of day, with no reference
            to a particular calendar, time zone or date.
            </summary>
            <remarks>
            Ordering and equality are defined in the natural way, simply comparing the number of "nanoseconds since midnight".
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.LocalTime.Midnight">
            <summary>
            Local time at midnight, i.e. 0 hours, 0 minutes, 0 seconds.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.MinValue">
            <summary>
            The minimum value of this type; equivalent to <see cref="P:NodaTime.LocalTime.Midnight"/>.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.Noon">
            <summary>
            Local time at noon, i.e. 12 hours, 0 minutes, 0 seconds.
            </summary>
        </member>
        <member name="P:NodaTime.LocalTime.MaxValue">
            <summary>
            The maximum value of this type, one nanosecond before midnight.
            </summary>
            <remarks>This is useful if you have to use an inclusive upper bound for some reason.
            In general, it's better to use an exclusive upper bound, in which case use midnight of
            the following day.</remarks>
        </member>
        <member name="F:NodaTime.LocalTime.nanoseconds">
            <summary>
            Nanoseconds since midnight, in the range [0, 86,400,000,000,000).
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a local time at the given hour and minute, with second, millisecond-of-second
            and tick-of-millisecond values of zero.
            </summary>
            <param name="hour">The hour of day.</param>
            <param name="minute">The minute of the hour.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a local time at the given hour, minute and second,
            with millisecond-of-second and tick-of-millisecond values of zero.
            </summary>
            <param name="hour">The hour of day.</param>
            <param name="minute">The minute of the hour.</param>
            <param name="second">The second of the minute.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a local time at the given hour, minute, second and millisecond,
            with a tick-of-millisecond value of zero.
            </summary>
            <param name="hour">The hour of day.</param>
            <param name="minute">The minute of the hour.</param>
            <param name="second">The second of the minute.</param>
            <param name="millisecond">The millisecond of the second.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromHourMinuteSecondMillisecondTick(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Factory method to create a local time at the given hour, minute, second, millisecond and tick within millisecond.
            </summary>
            <param name="hour">The hour of day.</param>
            <param name="minute">The minute of the hour.</param>
            <param name="second">The second of the minute.</param>
            <param name="millisecond">The millisecond of the second.</param>
            <param name="tickWithinMillisecond">The tick within the millisecond.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromHourMinuteSecondTick(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Factory method for creating a local time from the hour of day, minute of hour, second of minute, and tick of second.
            </summary>
            <remarks>
            This is not a constructor overload as it would have the same signature as the one taking millisecond of second.
            </remarks>
            <param name="hour">The hour of day in the desired time, in the range [0, 23].</param>
            <param name="minute">The minute of hour in the desired time, in the range [0, 59].</param>
            <param name="second">The second of minute in the desired time, in the range [0, 59].</param>
            <param name="tickWithinSecond">The tick within the second in the desired time, in the range [0, 9999999].</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromHourMinuteSecondNanosecond(System.Int32,System.Int32,System.Int32,System.Int64)">
            <summary>
            Factory method for creating a local time from the hour of day, minute of hour, second of minute, and nanosecond of second.
            </summary>
            <remarks>
            This is not a constructor overload as it would have the same signature as the one taking millisecond of second.
            </remarks>
            <param name="hour">The hour of day in the desired time, in the range [0, 23].</param>
            <param name="minute">The minute of hour in the desired time, in the range [0, 59].</param>
            <param name="second">The second of minute in the desired time, in the range [0, 59].</param>
            <param name="nanosecondWithinSecond">The nanosecond within the second in the desired time, in the range [0, 999999999].</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid time.</exception>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromHourMinuteSecondNanosecondTrusted(System.Int32,System.Int32,System.Int32,System.Int64)">
            <summary>
            Factory method for creating a local time from the hour of day, minute of hour, second of minute, and nanosecond of second
            where the values have already been validated.
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.#ctor(System.Int64)">
            <summary>
            Constructor only called from other parts of Noda Time - trusted to be the range [0, NanosecondsPerDay).
            </summary>
        </member>
        <member name="M:NodaTime.LocalTime.FromNanosecondsSinceMidnight(System.Int64)">
            <summary>
            Factory method for creating a local time from the number of nanoseconds which have elapsed since midnight.
            </summary>
            <param name="nanoseconds">The number of nanoseconds, in the range [0, 86,399,999,999,999]</param>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromTicksSinceMidnight(System.Int64)">
            <summary>
            Factory method for creating a local time from the number of ticks which have elapsed since midnight.
            </summary>
            <param name="ticks">The number of ticks, in the range [0, 863,999,999,999]</param>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromMillisecondsSinceMidnight(System.Int32)">
            <summary>
            Factory method for creating a local time from the number of milliseconds which have elapsed since midnight.
            </summary>
            <param name="milliseconds">The number of milliseconds, in the range [0, 86,399,999]</param>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromSecondsSinceMidnight(System.Int32)">
            <summary>
            Factory method for creating a local time from the number of seconds which have elapsed since midnight.
            </summary>
            <param name="seconds">The number of seconds, in the range [0, 86,399]</param>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromMinutesSinceMidnight(System.Int32)">
            <summary>
            Factory method for creating a local time from the number of minutes which have elapsed since midnight.
            </summary>
            <param name="minutes">The number of minutes, in the range [0, 1439]</param>
            <returns>The resulting time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.FromHoursSinceMidnight(System.Int32)">
            <summary>
            Factory method for creating a local time from the number of hours which have elapsed since midnight.
            </summary>
            <param name="hours">The number of hours, in the range [0, 23]</param>
            <returns>The resulting time.</returns>
        </member>
        <member name="P:NodaTime.LocalTime.Hour">
            <summary>
            Gets the hour of day of this local time, in the range 0 to 23 inclusive.
            </summary>
            <value>The hour of day of this local time, in the range 0 to 23 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalTime.ClockHourOfHalfDay">
            <summary>
            Gets the hour of the half-day of this local time, in the range 1 to 12 inclusive.
            </summary>
            <value>The hour of the half-day of this local time, in the range 1 to 12 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalTime.Minute">
            <summary>
            Gets the minute of this local time, in the range 0 to 59 inclusive.
            </summary>
            <value>The minute of this local time, in the range 0 to 59 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalTime.Second">
            <summary>
            Gets the second of this local time within the minute, in the range 0 to 59 inclusive.
            </summary>
            <value>The second of this local time within the minute, in the range 0 to 59 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalTime.Millisecond">
            <summary>
            Gets the millisecond of this local time within the second, in the range 0 to 999 inclusive.
            </summary>
            <value>The millisecond of this local time within the second, in the range 0 to 999 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalTime.TickOfSecond">
            <summary>
            Gets the tick of this local time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
            <value>The tick of this local time within the second, in the range 0 to 9,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalTime.TickOfDay">
            <summary>
            Gets the tick of this local time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
            <remarks>
            If the value does not fall on a tick boundary, it will be truncated towards zero.
            </remarks>
            <value>The tick of this local time within the day, in the range 0 to 863,999,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalTime.NanosecondOfSecond">
            <summary>
            Gets the nanosecond of this local time within the second, in the range 0 to 999,999,999 inclusive.
            </summary>
            <value>The nanosecond of this local time within the second, in the range 0 to 999,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.LocalTime.NanosecondOfDay">
            <summary>
            Gets the nanosecond of this local time within the day, in the range 0 to 86,399,999,999,999 inclusive.
            </summary>
            <value>The nanosecond of this local time within the day, in the range 0 to 86,399,999,999,999 inclusive.</value>
        </member>
        <member name="M:NodaTime.LocalTime.op_Addition(NodaTime.LocalTime,NodaTime.Period)">
            <summary>
            Creates a new local time by adding a period to an existing time. The period must not contain
            any date-related units (days etc) with non-zero values.
            </summary>
            <param name="time">The time to add the period to</param>
            <param name="period">The period to add</param>
            <returns>The result of adding the period to the time, wrapping via midnight if necessary</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Add(NodaTime.LocalTime,NodaTime.Period)">
            <summary>
            Adds the specified period to the time. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="time">The time to add the period to</param>
            <param name="period">The period to add. Must not contain any (non-zero) date units.</param>
            <returns>The sum of the given time and period</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Plus(NodaTime.Period)">
            <summary>
            Adds the specified period to this time. Fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="period">The period to add. Must not contain any (non-zero) date units.</param>
            <returns>The sum of this time and the given period</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_Subtraction(NodaTime.LocalTime,NodaTime.Period)">
            <summary>
            Creates a new local time by subtracting a period from an existing time. The period must not contain
            any date-related units (days etc) with non-zero values.
            This is a convenience operator over the <see cref="M:NodaTime.LocalTime.Minus(NodaTime.Period)"/> method.
            </summary>
            <param name="time">The time to subtract the period from</param>
            <param name="period">The period to subtract</param>
            <returns>The result of subtract the period from the time, wrapping via midnight if necessary</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Subtract(NodaTime.LocalTime,NodaTime.Period)">
            <summary>
            Subtracts the specified period from the time. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="time">The time to subtract the period from</param>
            <param name="period">The period to subtract. Must not contain any (non-zero) date units.</param>
            <returns>The result of subtracting the given period from the time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Minus(NodaTime.Period)">
            <summary>
            Subtracts the specified period from this time. Fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="period">The period to subtract. Must not contain any (non-zero) date units.</param>
            <returns>The result of subtracting the given period from this time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_Subtraction(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Subtracts one time from another, returning the result as a <see cref="T:NodaTime.Period"/>.
            </summary>
            <remarks>
            This is simply a convenience operator for calling <see cref="M:NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime)"/>.
            </remarks>
            <param name="lhs">The time to subtract from</param>
            <param name="rhs">The time to subtract</param>
            <returns>The result of subtracting one time from another.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Subtract(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Subtracts one time from another, returning the result as a <see cref="T:NodaTime.Period"/> with units of years, months and days.
            </summary>
            <remarks>
            This is simply a convenience method for calling <see cref="M:NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime)"/>.
            </remarks>
            <param name="lhs">The time to subtract from</param>
            <param name="rhs">The time to subtract</param>
            <returns>The result of subtracting one time from another.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Minus(NodaTime.LocalTime)">
            <summary>
            Subtracts the specified time from this time, returning the result as a <see cref="T:NodaTime.Period"/>.
            Fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="time">The time to subtract from this</param>
            <returns>The difference between the specified time and this one</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_Equality(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two local times for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>True if the two times are the same; false otherwise</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_Inequality(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two local times for inequality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>False if the two times are the same; true otherwise</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_LessThan(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two LocalTime values to see if the left one is strictly earlier than the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is strictly earlier than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_LessThanOrEqual(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two LocalTime values to see if the left one is earlier than or equal to the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is earlier than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_GreaterThan(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two LocalTime values to see if the left one is strictly later than the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is strictly later than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.op_GreaterThanOrEqual(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Compares two LocalTime values to see if the left one is later than or equal to the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <returns>true if the <paramref name="lhs"/> is later than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.CompareTo(NodaTime.LocalTime)">
            <summary>
            Indicates whether this time is earlier, later or the same as another one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="other">The other date/time to compare this one with</param>
            <returns>A value less than zero if this time is earlier than <paramref name="other"/>;
            zero if this time is the same as <paramref name="other"/>; a value greater than zero if this time is
            later than <paramref name="other"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two LocalTimes.
            See the type documentation for a description of ordering semantics.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.LocalTime"/>.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this LocalTime with another one; see <see cref="M:NodaTime.LocalTime.CompareTo(NodaTime.LocalTime)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.LocalTime.GetHashCode">
            <summary>
            Returns a hash code for this local time.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>A hash code for this local time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Equals(NodaTime.LocalTime)">
            <summary>
            Compares this local time with the specified one for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">The other local time to compare this one with</param>
            <returns>True if the specified time is equal to this one; false otherwise</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Equals(System.Object)">
            <summary>
            Compares this local time with the specified reference.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The object to compare this one with</param>
            <returns>True if the specified value is a local time which is equal to this one; false otherwise</returns>
        </member>
        <member name="M:NodaTime.LocalTime.PlusHours(System.Int64)">
            <summary>
            Returns a new LocalTime representing the current value with the given number of hours added.
            </summary>
            <remarks>
            If the value goes past the start or end of the day, it wraps - so 11pm plus two hours is 1am, for example.
            </remarks>
            <param name="hours">The number of hours to add</param>
            <returns>The current value plus the given number of hours.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.PlusMinutes(System.Int64)">
            <summary>
            Returns a new LocalTime representing the current value with the given number of minutes added.
            </summary>
            <remarks>
            If the value goes past the start or end of the day, it wraps - so 11pm plus 120 minutes is 1am, for example.
            </remarks>
            <param name="minutes">The number of minutes to add</param>
            <returns>The current value plus the given number of minutes.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.PlusSeconds(System.Int64)">
            <summary>
            Returns a new LocalTime representing the current value with the given number of seconds added.
            </summary>
            <remarks>
            If the value goes past the start or end of the day, it wraps - so 11:59pm plus 120 seconds is 12:01am, for example.
            </remarks>
            <param name="seconds">The number of seconds to add</param>
            <returns>The current value plus the given number of seconds.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.PlusMilliseconds(System.Int64)">
            <summary>
            Returns a new LocalTime representing the current value with the given number of milliseconds added.
            </summary>
            <param name="milliseconds">The number of milliseconds to add</param>
            <returns>The current value plus the given number of milliseconds.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.PlusTicks(System.Int64)">
            <summary>
            Returns a new LocalTime representing the current value with the given number of ticks added.
            </summary>
            <param name="ticks">The number of ticks to add</param>
            <returns>The current value plus the given number of ticks.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.PlusNanoseconds(System.Int64)">
            <summary>
            Returns a new LocalTime representing the current value with the given number of nanoseconds added.
            </summary>
            <param name="nanoseconds">The number of nanoseconds to add</param>
            <returns>The current value plus the given number of ticks.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.With(System.Func{NodaTime.LocalTime,NodaTime.LocalTime})">
            <summary>
            Returns this time, with the given adjuster applied to it.
            </summary>
            <remarks>
            If the adjuster attempts to construct an invalid time, any exception thrown by
            that construction attempt will be propagated through this method.
            </remarks>
            <param name="adjuster">The adjuster to apply.</param>
            <returns>The adjusted time.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.WithOffset(NodaTime.Offset)">
            <summary>
            Returns an <see cref="T:NodaTime.OffsetTime"/> for this time-of-day with the given offset.
            </summary>
            <remarks>This method is purely a convenient alternative to calling the <see cref="T:NodaTime.OffsetTime"/> constructor directly.</remarks>
            <param name="offset">The offset to apply.</param>
            <returns>The result of this time-of-day offset by the given amount.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.On(NodaTime.LocalDate)">
            <summary>
            Combines this <see cref="T:NodaTime.LocalTime"/> with the given <see cref="T:NodaTime.LocalDate"/>
            into a single <see cref="T:NodaTime.LocalDateTime"/>.
            Fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="date">The date to combine with this time</param>
            <returns>The <see cref="T:NodaTime.LocalDateTime"/> representation of the given time on this date</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Deconstruct(System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Deconstruct this time into its components.
            </summary>
            <param name="hour">The hour of the time.</param>
            <param name="minute">The minute of the hour.</param>
            <param name="second">The second within the minute.</param>
        </member>
        <member name="M:NodaTime.LocalTime.Max(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Returns the later time of the given two.
            </summary>
            <param name="x">The first time to compare.</param>
            <param name="y">The second time to compare.</param>
            <returns>The later instant of <paramref name="x"/> or <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.Min(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Returns the earlier time of the given two.
            </summary>
            <param name="x">The first time to compare.</param>
            <param name="y">The second time to compare.</param>
            <returns>The earlier time of <paramref name="x"/> or <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("T"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.LocalTime.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("T").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.LocalTime.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.LocalTime"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            the <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.LocalTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.NodaConstants">
            <summary>
            Useful constants, mostly along the lines of "number of milliseconds in an hour".
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.NanosecondsPerTick">
            <summary>
            A constant for the number of nanoseconds in a tick. The value of this constant is 100.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.NanosecondsPerMicrosecond">
            <summary>
            A constant for the number of nanoseconds in a microsecond. The value of this constant is 1,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.NanosecondsPerMillisecond">
            <summary>
            A constant for the number of nanoseconds in a millisecond. The value of this constant is 1,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.NanosecondsPerSecond">
            <summary>
            A constant for the number of nanoseconds in a second. The value of this constant is 1,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.NanosecondsPerMinute">
            <summary>
            A constant for the number of nanoseconds in a minute. The value of this constant is 60,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.NanosecondsPerHour">
            <summary>
            A constant for the number of nanoseconds in an hour. The value of this constant is 3,600,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.NanosecondsPerDay">
            <summary>
            A constant for the number of nanoseconds in a standard 24-hour day. The value of this constant is 86,400,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.NanosecondsPerWeek">
            <summary>
            A constant for the number of nanoseconds in a standard week of seven 24-hour days. The value of this constant is 604,800,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerMillisecond">
            <summary>
            A constant for the number of ticks in a millisecond. The value of this constant is 10,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerSecond">
            <summary>
            A constant for the number of ticks in a second. The value of this constant is 10,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerMinute">
            <summary>
            A constant for the number of ticks in a minute. The value of this constant is 600,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerHour">
            <summary>
            A constant for the number of ticks in an hour. The value of this constant is 36,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerDay">
            <summary>
            A constant for the number of ticks in a standard 24-hour day.
            The value of this constant is 864,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.TicksPerWeek">
            <summary>
            A constant for the number of ticks in a standard week of seven 24-hour days.
            The value of this constant is 6,048,000,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MicrosecondsPerSecond">
            <summary>
            A constant for the number of microseconds per second.
            The value of this constant is 1,000,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerSecond">
            <summary>
            A constant for the number of milliseconds per second.
            The value of this constant is 1000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerMinute">
            <summary>
            A constant for the number of milliseconds per minute.
            The value of this constant is 60,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerHour">
            <summary>
            A constant for the number of milliseconds per hour.
            The value of this constant is 3,600,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerDay">
            <summary>
            A constant for the number of milliseconds per standard 24-hour day.
            The value of this constant is 86,400,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MillisecondsPerWeek">
            <summary>
            A constant for the number of milliseconds per standard week of seven 24-hour days.
            The value of this constant is 604,800,000.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.SecondsPerMinute">
            <summary>
            A constant for the number of seconds per minute.
            The value of this constant is 60.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.SecondsPerHour">
            <summary>
            A constant for the number of seconds per hour.
            The value of this constant is 3,600.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.SecondsPerDay">
            <summary>
            A constant for the number of seconds per standard 24-hour day.
            The value of this constant is 86,400.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.SecondsPerWeek">
            <summary>
            A constant for the number of seconds per standard week of seven 24-hour days.
            The value of this constant is 604,800.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MinutesPerHour">
            <summary>
            A constant for the number of minutes per hour.
            The value of this constant is 60.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MinutesPerDay">
            <summary>
            A constant for the number of minutes per standard 24-hour day.
            The value of this constant is 1,440.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.MinutesPerWeek">
            <summary>
            A constant for the number of minutes per standard week of seven 24-hour days.
            The value of this constant is 10,080.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.HoursPerDay">
            <summary>
            A constant for the number of hours in a standard day. Note that the number of hours
            in a day can vary due to daylight saving effects.
            The value of this constant is 24.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.HoursPerWeek">
            <summary>
            A constant for the number of hours in a standard week of seven 24-hour days.
            The value of this constant is 168.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.DaysPerWeek">
            <summary>
            Number of days in a standard Gregorian week.
            The value of this constant is 7.
            </summary>
        </member>
        <member name="P:NodaTime.NodaConstants.UnixEpoch">
            <summary>
            The instant at the Unix epoch of midnight 1st January 1970 UTC.
            </summary>
        </member>
        <member name="P:NodaTime.NodaConstants.BclEpoch">
            <summary>
            The instant at the BCL epoch of midnight 1st January 0001 UTC.
            </summary>
        </member>
        <member name="P:NodaTime.NodaConstants.JulianEpoch">
            <summary>
            The instant at the Julian epoch of noon (UTC) January 1st 4713 BCE in the proleptic
            Julian calendar, or November 24th 4714 BCE in the proleptic Gregorian calendar.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.BclTicksAtUnixEpoch">
            <summary>
            The number of ticks in a BCL DateTime at the Unix epoch.
            </summary>
        </member>
        <member name="F:NodaTime.NodaConstants.BclDaysAtUnixEpoch">
            <summary>
            The number of days in a BCL DateTime at the Unix epoch.
            </summary>
        </member>
        <member name="T:NodaTime.Offset">
            <summary>
            An offset from UTC in seconds. A positive value means that the local time is
            ahead of UTC (e.g. for Europe); a negative value means that the local time is behind
            UTC (e.g. for America).
            </summary>
            <remarks>
            <para>
            Offsets are always in the range of [-18, +18] hours. (Note that the ends are inclusive,
            so an offset of 18 hours can be represented, but an offset of 18 hours and one second cannot.)
            This allows all offsets within TZDB to be represented. The BCL <see cref="T:System.DateTimeOffset"/> type
            only allows offsets up to 14 hours, which means some historical data within TZDB could not be
            represented.
            </para>
            <para>Offsets are represented with a granularity of one second. This allows all offsets within TZDB
            to be represented. It is possible that it could present issues to some other time zone data sources,
            but only in very rare historical cases (or fictional ones).</para>
            <para>Equality and ordering are defined in the natural way by comparing the underlying number
            of seconds. For example, this means that offsets for America are ordered before offsets in Europe.</para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.Offset.Zero">
            <summary>
            An offset of zero seconds - effectively the permanent offset for UTC.
            </summary>
        </member>
        <member name="F:NodaTime.Offset.MinValue">
            <summary>
            The minimum permitted offset; 18 hours before UTC.
            </summary>
        </member>
        <member name="F:NodaTime.Offset.MaxValue">
            <summary>
            The maximum permitted offset; 18 hours after UTC.
            </summary>
        </member>
        <member name="M:NodaTime.Offset.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.Offset" /> struct.
            </summary>
            <param name="seconds">The number of seconds in the offset.</param>
        </member>
        <member name="P:NodaTime.Offset.Seconds">
            <summary>
            Gets the number of seconds represented by this offset, which may be negative.
            </summary>
            <value>The number of seconds represented by this offset, which may be negative.</value>
        </member>
        <member name="P:NodaTime.Offset.Milliseconds">
            <summary>
            Gets the number of milliseconds represented by this offset, which may be negative.
            </summary>
            <remarks>
            Offsets are only accurate to second precision; the number of seconds is simply multiplied
            by 1,000 to give the number of milliseconds.
            </remarks>
            <value>The number of milliseconds represented by this offset, which may be negative.</value>
        </member>
        <member name="P:NodaTime.Offset.Ticks">
            <summary>
            Gets the number of ticks represented by this offset, which may be negative.
            </summary>
            <remarks>
            Offsets are only accurate to second precision; the number of seconds is simply multiplied
            by 10,000,000 to give the number of ticks.
            </remarks>
            <value>The number of ticks.</value>
        </member>
        <member name="P:NodaTime.Offset.Nanoseconds">
            <summary>
            Gets the number of nanoseconds represented by this offset, which may be negative.
            </summary>
            <remarks>
            Offsets are only accurate to second precision; the number of seconds is simply multiplied
            by 1,000,000,000 to give the number of nanoseconds.
            </remarks>
            <value>The number of nanoseconds.</value>
        </member>
        <member name="M:NodaTime.Offset.Max(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the greater offset of the given two, i.e. the one which will give a later local
            time when added to an instant.
            </summary>
            <param name="x">The first offset</param>
            <param name="y">The second offset</param>
            <returns>The greater offset of <paramref name="x"/> and <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.Offset.Min(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the lower offset of the given two, i.e. the one which will give an earlier local
            time when added to an instant.
            </summary>
            <param name="x">The first offset</param>
            <param name="y">The second offset</param>
            <returns>The lower offset of <paramref name="x"/> and <paramref name="y"/>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_UnaryNegation(NodaTime.Offset)">
            <summary>
            Implements the unary operator - (negation).
            </summary>
            <param name="offset">The offset to negate.</param>
            <returns>A new <see cref="T:NodaTime.Offset" /> instance with a negated value.</returns>
        </member>
        <member name="M:NodaTime.Offset.Negate(NodaTime.Offset)">
            <summary>
            Returns the negation of the specified offset. This is the method form of the unary minus operator.
            </summary>
            <param name="offset">The offset to negate.</param>
            <returns>The negation of the specified offset.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_UnaryPlus(NodaTime.Offset)">
            <summary>
            Implements the unary operator + .
            </summary>
            <param name="offset">The operand.</param>
            <remarks>There is no method form of this operator; the <see cref="M:NodaTime.Offset.Plus(NodaTime.Offset)"/> method is an instance
            method for addition, and is more useful than a method form of this would be.</remarks>
            <returns>The same <see cref="T:NodaTime.Offset" /> instance</returns>
        </member>
        <member name="M:NodaTime.Offset.op_Addition(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator + (addition).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
            <returns>A new <see cref="T:NodaTime.Offset" /> representing the sum of the given values.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.Add(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Adds one Offset to another. Friendly alternative to <c>operator+()</c>.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
            <returns>A new <see cref="T:NodaTime.Offset" /> representing the sum of the given values.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.Plus(NodaTime.Offset)">
            <summary>
            Returns the result of adding another Offset to this one, for a fluent alternative to <c>operator+()</c>.
            </summary>
            <param name="other">The offset to add</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
            <returns>The result of adding the other offset to this one.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_Subtraction(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator - (subtraction).
            </summary>
            <param name="minuend">The left hand side of the operator.</param>
            <param name="subtrahend">The right hand side of the operator.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
            <returns>A new <see cref="T:NodaTime.Offset" /> representing the difference of the given values.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.Subtract(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Subtracts one Offset from another. Friendly alternative to <c>operator-()</c>.
            </summary>
            <param name="minuend">The left hand side of the operator.</param>
            <param name="subtrahend">The right hand side of the operator.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
            <returns>A new <see cref="T:NodaTime.Offset" /> representing the difference of the given values.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.Minus(NodaTime.Offset)">
            <summary>
            Returns the result of subtracting another Offset from this one, for a fluent alternative to <c>operator-()</c>.
            </summary>
            <param name="other">The offset to subtract</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
            <returns>The result of subtracting the other offset from this one.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_Equality(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator == (equality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_Inequality(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator != (inequality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_LessThan(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator &lt; (less than).
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_LessThanOrEqual(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator &lt;= (less than or equal).
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is less than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_GreaterThan(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator &gt; (greater than).
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.op_GreaterThanOrEqual(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Implements the operator &gt;= (greater than or equal).
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if the left value is greater than or equal to the right value, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Offset.CompareTo(NodaTime.Offset)">
            <summary>
            Compares the current object with another object of the same type.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
              A 32-bit signed integer that indicates the relative order of the objects being compared.
              The return value has the following meanings:
              <list type = "table">
                <listheader>
                  <term>Value</term>
                  <description>Meaning</description>
                </listheader>
                <item>
                  <term>&lt; 0</term>
                  <description>This object is less than the <paramref name = "other" /> parameter.</description>
                </item>
                <item>
                  <term>0</term>
                  <description>This object is equal to <paramref name = "other" />.</description>
                </item>
                <item>
                  <term>&gt; 0</term>
                  <description>This object is greater than <paramref name = "other" />.</description>
                </item>
              </list>
            </returns>
        </member>
        <member name="M:NodaTime.Offset.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two offsets.
            See the type documentation for a description of ordering semantics.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.Offset"/>.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this instant with another one; see <see cref="M:NodaTime.Offset.CompareTo(NodaTime.Offset)"/> for general details.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.Offset.Equals(NodaTime.Offset)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name = "other" /> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.Offset.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.Offset.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.Offset.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("g"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.Offset.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("g").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.Offset.FromSeconds(System.Int32)">
            <summary>
            Returns an offset for the given seconds value, which may be negative.
            </summary>
            <param name="seconds">The int seconds value.</param>
            <returns>An offset representing the given number of seconds.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified number of seconds is outside the range of
            [-18, +18] hours.</exception>
        </member>
        <member name="M:NodaTime.Offset.FromMilliseconds(System.Int32)">
            <summary>
            Returns an offset for the given milliseconds value, which may be negative.
            </summary>
            <remarks>
            Offsets are only accurate to second precision; the given number of milliseconds is simply divided
            by 1,000 to give the number of seconds - any remainder is truncated.
            </remarks>
            <param name="milliseconds">The int milliseconds value.</param>
            <returns>An offset representing the given number of milliseconds, to the (truncated) second.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified number of milliseconds is outside the range of
            [-18, +18] hours.</exception>
        </member>
        <member name="M:NodaTime.Offset.FromTicks(System.Int64)">
            <summary>
            Returns an offset for the given number of ticks, which may be negative.
            </summary>
            <remarks>
            Offsets are only accurate to second precision; the given number of ticks is simply divided
            by 10,000,000 to give the number of seconds - any remainder is truncated.
            </remarks>
            <param name="ticks">The number of ticks specifying the length of the new offset.</param>
            <returns>An offset representing the given number of ticks, to the (truncated) second.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified number of ticks is outside the range of
            [-18, +18] hours.</exception>
        </member>
        <member name="M:NodaTime.Offset.FromNanoseconds(System.Int64)">
            <summary>
            Returns an offset for the given number of nanoseconds, which may be negative.
            </summary>
            <remarks>
            Offsets are only accurate to second precision; the given number of nanoseconds is simply divided
            by 1,000,000,000 to give the number of seconds - any remainder is truncated towards zero.
            </remarks>
            <param name="nanoseconds">The number of nanoseconds specifying the length of the new offset.</param>
            <returns>An offset representing the given number of nanoseconds, to the (truncated) second.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified number of nanoseconds is outside the range of
            [-18, +18] hours.</exception>
        </member>
        <member name="M:NodaTime.Offset.FromHours(System.Int32)">
            <summary>
            Returns an offset for the specified number of hours, which may be negative.
            </summary>
            <param name="hours">The number of hours to represent in the new offset.</param>
            <returns>An offset representing the given value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified number of hours is outside the range of
            [-18, +18].</exception>
        </member>
        <member name="M:NodaTime.Offset.FromHoursAndMinutes(System.Int32,System.Int32)">
            <summary>
            Returns an offset for the specified number of hours and minutes.
            </summary>
            <remarks>
            The result simply takes the hours and minutes and converts each component into milliseconds
            separately. As a result, a negative offset should usually be obtained by making both arguments
            negative. For example, to obtain "three hours and ten minutes behind UTC" you might call
            <c>Offset.FromHoursAndMinutes(-3, -10)</c>.
            </remarks>
            <param name="hours">The number of hours to represent in the new offset.</param>
            <param name="minutes">The number of minutes to represent in the new offset.</param>
            <returns>An offset representing the given value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The result of the operation is outside the range of Offset.</exception>
        </member>
        <member name="M:NodaTime.Offset.ToTimeSpan">
            <summary>
            Converts this offset to a .NET standard <see cref="T:System.TimeSpan" /> value.
            </summary>
            <returns>An equivalent <see cref="T:System.TimeSpan"/> to this value.</returns>
        </member>
        <member name="M:NodaTime.Offset.FromTimeSpan(System.TimeSpan)">
            <summary>
            Converts the given <see cref="T:System.TimeSpan"/> to an offset, with fractional seconds truncated.
            </summary>
            <param name="timeSpan">The timespan to convert</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The given time span falls outside the range of +/- 18 hours.</exception>
            <returns>An offset for the same time as the given time span.</returns>
        </member>
        <member name="M:NodaTime.Offset.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.Offset"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Offset.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.OffsetDate">
            <summary>
            A combination of a <see cref="T:NodaTime.LocalDate"/> and an <see cref="P:NodaTime.OffsetDate.Offset"/>, to represent
            a date at a specific offset from UTC but without any time-of-day information.
            </summary>
            <remarks>
            <para>
            Equality is defined in a component-wise fashion: two values are the same if they represent equal dates
            (including being in the same calendar) and equal offsets from UTC.
            Ordering between offset dates is not defined.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.OffsetDate.#ctor(NodaTime.LocalDate,NodaTime.Offset)">
            <summary>
            Constructs an instance of the specified date and offset.
            </summary>
            <param name="date">The date part of the value.</param>
            <param name="offset">The offset part of the value.</param>
        </member>
        <member name="P:NodaTime.OffsetDate.Date">
            <summary>
            Gets the local date represented by this value.
            </summary>
            <value>The local date represented by this value.</value>
        </member>
        <member name="P:NodaTime.OffsetDate.Offset">
            <summary>
            Gets the offset from UTC of this value.
            </summary>
            <value>The offset from UTC of this value.</value>
        </member>
        <member name="P:NodaTime.OffsetDate.Calendar">
            <summary>Gets the calendar system associated with this offset date.</summary>
            <value>The calendar system associated with this offset date.</value>
        </member>
        <member name="P:NodaTime.OffsetDate.Year">
            <summary>Gets the year of this offset date.</summary>
            <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
            <value>The year of this offset date.</value>
        </member>
        <member name="P:NodaTime.OffsetDate.Month">
            <summary>Gets the month of this offset date within the year.</summary>
            <value>The month of this offset date within the year.</value>
        </member>
        <member name="P:NodaTime.OffsetDate.Day">
            <summary>Gets the day of this offset date within the month.</summary>
            <value>The day of this offset date within the month.</value>
        </member>
        <member name="P:NodaTime.OffsetDate.DayOfWeek">
            <summary>
            Gets the week day of this offset date expressed as an <see cref="T:NodaTime.IsoDayOfWeek"/> value.
            </summary>
            <value>The week day of this offset date expressed as an <c>IsoDayOfWeek</c>.</value>
        </member>
        <member name="P:NodaTime.OffsetDate.YearOfEra">
            <summary>Gets the year of this offset date within the era.</summary>
            <value>The year of this offset date within the era.</value>
        </member>
        <member name="P:NodaTime.OffsetDate.Era">
            <summary>Gets the era of this offset date.</summary>
            <value>The era of this offset date.</value>
        </member>
        <member name="P:NodaTime.OffsetDate.DayOfYear">
            <summary>Gets the day of this offset date within the year.</summary>
            <value>The day of this offset date within the year.</value>
        </member>
        <member name="M:NodaTime.OffsetDate.WithOffset(NodaTime.Offset)">
            <summary>
            Creates a new <see cref="T:NodaTime.OffsetDate"/> for the same date, but with the specified UTC offset.
            </summary>
            <param name="offset">The new UTC offset.</param>
            <returns>A new <c>OffsetDate</c> for the same date, but with the specified UTC offset.</returns>
        </member>
        <member name="M:NodaTime.OffsetDate.With(System.Func{NodaTime.LocalDate,NodaTime.LocalDate})">
            <summary>
            Returns this offset date, with the given date adjuster applied to it, maintaining the existing offset.
            </summary>
            <remarks>
            If the adjuster attempts to construct an
            invalid date (such as by trying to set a day-of-month of 30 in February), any exception thrown by
            that construction attempt will be propagated through this method.
            </remarks>
            <param name="adjuster">The adjuster to apply.</param>
            <returns>The adjusted offset date.</returns>
        </member>
        <member name="M:NodaTime.OffsetDate.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a new <see cref="T:NodaTime.OffsetDate"/> representing the same physical date and offset, but in a different calendar.
            The returned value is likely to have different date field values to this one.
            For example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.
            </summary>
            <param name="calendar">The calendar system to convert this offset date to.</param>
            <returns>The converted <c>OffsetDate</c>.</returns>
        </member>
        <member name="M:NodaTime.OffsetDate.At(NodaTime.LocalTime)">
            <summary>
            Combines this <see cref="T:NodaTime.OffsetDate"/> with the given <see cref="T:NodaTime.LocalTime"/>
            into an <see cref="T:NodaTime.OffsetDateTime"/>.
            </summary>
            <param name="time">The time to combine with this date.</param>
            <returns>The <see cref="T:NodaTime.OffsetDateTime"/> representation of the given time on this date.</returns>
        </member>
        <member name="M:NodaTime.OffsetDate.GetHashCode">
            <summary>
            Returns a hash code for this offset date.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>A hash code for this offset date.</returns>
        </member>
        <member name="M:NodaTime.OffsetDate.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:NodaTime.OffsetDate"/> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The object to compare this offset date with.</param>
            <returns>True if the given value is another offset date equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.OffsetDate.Equals(NodaTime.OffsetDate)">
            <summary>
            Compares two <see cref="T:NodaTime.OffsetDate"/> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">The value to compare this offset date with.</param>
            <returns>True if the given value is another offset date equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.OffsetDate.op_Equality(NodaTime.OffsetDate,NodaTime.OffsetDate)">
            <summary>
            Implements the operator == (equality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.OffsetDate.op_Inequality(NodaTime.OffsetDate,NodaTime.OffsetDate)">
            <summary>
            Implements the operator != (inequality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.OffsetDate.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("G"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.OffsetDate.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("G").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.OffsetDate.Deconstruct(NodaTime.LocalDate@,NodaTime.Offset@)">
            <summary>
            Deconstruct this value into its components.
            </summary>
            <param name="localDate">The <see cref="T:NodaTime.LocalDate"/> component.</param>
            <param name="offset">The <see cref="P:NodaTime.OffsetDate.Offset"/> component.</param>
        </member>
        <member name="M:NodaTime.OffsetDate.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.OffsetDate"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.OffsetDate.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDate.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDate.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.OffsetDateTime">
            <summary>
            A local date and time in a particular calendar system, combined with an offset from UTC. This is
            broadly similar to <see cref="T:System.DateTimeOffset" /> in the BCL.
            </summary>
            <remarks>
            <para>
            Equality is defined in a component-wise fashion: two values are the same if they represent equal date/time values
            (including being in the same calendar) and equal offsets from UTC.
            Ordering between offset date/time values has no natural definition; see <see cref="T:NodaTime.OffsetDateTime.Comparer"/> for built-in comparers.
            </para>
            <para>
            A value of this type unambiguously represents both a local time and an instant on the timeline,
            but does not have a well-defined time zone. This means you cannot reliably know what the local
            time would be five minutes later, for example. While this doesn't sound terribly useful, it's very common
            in text representations.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.OffsetDateTime.#ctor(NodaTime.Instant,NodaTime.Offset)">
            <summary>
            Optimized conversion from an Instant to an OffsetDateTime in the ISO calendar.
            This is equivalent to <c>new OffsetDateTime(new LocalDateTime(instant.Plus(offset)), offset)</c>
            but with less overhead.
            </summary>
        </member>
        <member name="M:NodaTime.OffsetDateTime.#ctor(NodaTime.Instant,NodaTime.Offset,NodaTime.CalendarSystem)">
            <summary>
            Optimized conversion from an Instant to an OffsetDateTime in the specified calendar.
            This is equivalent to <c>new OffsetDateTime(new LocalDateTime(instant.Plus(offset), calendar), offset)</c>
            but with less overhead.
            </summary>
        </member>
        <member name="M:NodaTime.OffsetDateTime.#ctor(NodaTime.LocalDateTime,NodaTime.Offset)">
            <summary>
            Constructs a new offset date/time with the given local date and time, and the given offset from UTC.
            </summary>
            <param name="localDateTime">Local date and time to represent</param>
            <param name="offset">Offset from UTC</param>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Calendar">
            <summary>Gets the calendar system associated with this offset date and time.</summary>
            <value>The calendar system associated with this offset date and time.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Year">
            <summary>Gets the year of this offset date and time.</summary>
            <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
            <value>The year of this offset date and time.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Month">
            <summary>Gets the month of this offset date and time within the year.</summary>
            <value>The month of this offset date and time within the year.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Day">
            <summary>Gets the day of this offset date and time within the month.</summary>
            <value>The day of this offset date and time within the month.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.DayOfWeek">
            <summary>
            Gets the week day of this offset date and time expressed as an <see cref="T:NodaTime.IsoDayOfWeek"/> value.
            </summary>
            <value>The week day of this offset date and time expressed as an <c>IsoDayOfWeek</c>.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.YearOfEra">
            <summary>Gets the year of this offset date and time within the era.</summary>
            <value>The year of this offset date and time within the era.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Era">
            <summary>Gets the era of this offset date and time.</summary>
            <value>The era of this offset date and time.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.DayOfYear">
            <summary>Gets the day of this offset date and time within the year.</summary>
            <value>The day of this offset date and time within the year.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Hour">
            <summary>
            Gets the hour of day of this offset date and time, in the range 0 to 23 inclusive.
            </summary>
            <value>The hour of day of this offset date and time, in the range 0 to 23 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.ClockHourOfHalfDay">
            <summary>
            Gets the hour of the half-day of this offset date and time, in the range 1 to 12 inclusive.
            </summary>
            <value>The hour of the half-day of this offset date and time, in the range 1 to 12 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Minute">
            <summary>
            Gets the minute of this offset date and time, in the range 0 to 59 inclusive.
            </summary>
            <value>The minute of this offset date and time, in the range 0 to 59 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Second">
            <summary>
            Gets the second of this offset date and time within the minute, in the range 0 to 59 inclusive.
            </summary>
            <value>The second of this offset date and time within the minute, in the range 0 to 59 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Millisecond">
            <summary>
            Gets the millisecond of this offset date and time within the second, in the range 0 to 999 inclusive.
            </summary>
            <value>The millisecond of this offset date and time within the second, in the range 0 to 999 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.TickOfSecond">
            <summary>
            Gets the tick of this offset date and time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
            <value>The tick of this offset date and time within the second, in the range 0 to 9,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.TickOfDay">
            <summary>
            Gets the tick of this offset date and time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
            <value>The tick of this offset date and time within the day, in the range 0 to 863,999,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.NanosecondOfSecond">
            <summary>
            Gets the nanosecond of this offset date and time within the second, in the range 0 to 999,999,999 inclusive.
            </summary>
            <value>The nanosecond of this offset date and time within the second, in the range 0 to 999,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.NanosecondOfDay">
            <summary>
            Gets the nanosecond of this offset date and time within the day, in the range 0 to 86,399,999,999,999 inclusive.
            </summary>
            <value>The nanosecond of this offset date and time within the day, in the range 0 to 86,399,999,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.LocalDateTime">
            <summary>
            Returns the local date and time represented within this offset date and time.
            </summary>
            <value>The local date and time represented within this offset date and time.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Date">
            <summary>
            Gets the local date represented by this offset date and time.
            </summary>
            <remarks>
            The returned <see cref="T:NodaTime.LocalDate"/>
            will have the same calendar system and return the same values for each of the date-based calendar
            properties (Year, MonthOfYear and so on), but will not have any offset information.
            </remarks>
            <value>The local date represented by this offset date and time.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.TimeOfDay">
            <summary>
            Gets the time portion of this offset date and time.
            </summary>
            <remarks>
            The returned <see cref="T:NodaTime.LocalTime"/> will
            return the same values for each of the time-based properties (Hour, Minute and so on), but
            will not have any offset information.
            </remarks>
            <value>The time portion of this offset date and time.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Offset">
            <summary>
            Gets the offset from UTC.
            </summary>
            <value>The offset from UTC.</value>
        </member>
        <member name="M:NodaTime.OffsetDateTime.ToInstant">
            <summary>
            Converts this offset date and time to an instant in time by subtracting the offset from the local date and time.
            </summary>
            <returns>The instant represented by this offset date and time</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.InFixedZone">
            <summary>
            Returns this value as a <see cref="T:NodaTime.ZonedDateTime"/>.
            </summary>
            <remarks>
            <para>
            This method returns a <see cref="T:NodaTime.ZonedDateTime"/> with the same local date and time as this value, using a
            fixed time zone with the same offset as the offset for this value.
            </para>
            <para>
            Note that because the resulting <c>ZonedDateTime</c> has a fixed time zone, it is generally not useful to
            use this result for arithmetic operations, as the zone will not adjust to account for daylight savings.
            </para>
            </remarks>
            <returns>A zoned date/time with the same local time and a fixed time zone using the offset from this value.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.InZone(NodaTime.DateTimeZone)">
            <summary>
            Returns this value in ths specified time zone. This method does not expect
            the offset in the zone to be the same as for the current value; it simply converts
            this value into an <see cref="T:NodaTime.Instant"/> and finds the <see cref="T:NodaTime.ZonedDateTime"/>
            for that instant in the specified zone.
            </summary>
            <param name="zone">The time zone of the new value.</param>
            <returns>The instant represented by this value, in the specified time zone.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.ToDateTimeOffset">
            <summary>
            Returns the BCL <see cref="T:System.DateTimeOffset"/> corresponding to this offset date and time.
            </summary>
            <remarks>
            <para>
            If the date and time is not on a tick boundary (the unit of granularity of DateTime) the value will be truncated
            towards the start of time.
            </para>
            <para>
            If the offset has a non-zero second component, this is truncated as <c>DateTimeOffset</c> has an offset
            granularity of minutes.
            </para>
            <para>
            <see cref="T:System.DateTimeOffset"/> uses the Gregorian calendar by definition, so the value is implicitly converted
            to the Gregorian calendar first. The result will be the same instant in time (potentially truncated as described
            above), but the values returned by the Year/Month/Day properties of the <see cref="T:System.DateTimeOffset"/> may not
            match the Year/Month/Day properties of this value.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The date/time is outside the range of <c>DateTimeOffset</c>,
            or the offset is outside the range of +/-14 hours (the range supported by <c>DateTimeOffset</c>).</exception>
            <returns>A DateTimeOffset with the same local date/time and offset as this. The <see cref="T:System.DateTime"/> part of
            the result always has a "kind" of Unspecified.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.FromDateTimeOffset(System.DateTimeOffset)">
            <summary>
            Builds an <see cref="T:NodaTime.OffsetDateTime"/> from a BCL <see cref="T:System.DateTimeOffset"/> by converting
            the <see cref="T:System.DateTime"/> part to a <see cref="P:NodaTime.OffsetDateTime.LocalDateTime"/>, and the offset part to an <see cref="P:NodaTime.OffsetDateTime.Offset"/>.
            </summary>
            <param name="dateTimeOffset">DateTimeOffset to convert</param>
            <returns>The converted offset date and time</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a new OffsetDateTime representing the same physical date, time and offset, but in a different calendar.
            The returned OffsetDateTime is likely to have different date field values to this one.
            For example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.
            </summary>
            <param name="calendar">The calendar system to convert this offset date and time to.</param>
            <returns>The converted OffsetDateTime.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.With(System.Func{NodaTime.LocalDate,NodaTime.LocalDate})">
            <summary>
            Returns this offset date/time, with the given date adjuster applied to it, maintaining the existing time of day and offset.
            </summary>
            <remarks>
            If the adjuster attempts to construct an
            invalid date (such as by trying to set a day-of-month of 30 in February), any exception thrown by
            that construction attempt will be propagated through this method.
            </remarks>
            <param name="adjuster">The adjuster to apply.</param>
            <returns>The adjusted offset date/time.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.With(System.Func{NodaTime.LocalTime,NodaTime.LocalTime})">
            <summary>
            Returns this date/time, with the given time adjuster applied to it, maintaining the existing date and offset.
            </summary>
            <remarks>
            If the adjuster attempts to construct an invalid time, any exception thrown by
            that construction attempt will be propagated through this method.
            </remarks>
            <param name="adjuster">The adjuster to apply.</param>
            <returns>The adjusted offset date/time.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.WithOffset(NodaTime.Offset)">
            <summary>
            Creates a new OffsetDateTime representing the instant in time in the same calendar,
            but with a different offset. The local date and time is adjusted accordingly.
            </summary>
            <param name="offset">The new offset to use.</param>
            <returns>The converted OffsetDateTime.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.ToOffsetDate">
            <summary>
            Constructs a new <see cref="T:NodaTime.OffsetDate"/> from the date and offset of this value,
            but omitting the time-of-day.
            </summary>
            <returns>A value representing the date and offset aspects of this value.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.ToOffsetTime">
            <summary>
            Constructs a new <see cref="T:NodaTime.OffsetTime"/> from the time and offset of this value,
            but omitting the date.
            </summary>
            <returns>A value representing the time and offset aspects of this value.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.GetHashCode">
            <summary>
            Returns a hash code for this offset date and time.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>A hash code for this offset date and time.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:NodaTime.OffsetDateTime"/> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The object to compare this date with.</param>
            <returns>True if the given value is another offset date/time equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Equals(NodaTime.OffsetDateTime)">
            <summary>
            Compares two <see cref="T:NodaTime.OffsetDateTime"/> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">The value to compare this offset date/time with.</param>
            <returns>True if the given value is another offset date/time equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Deconstruct(NodaTime.LocalDateTime@,NodaTime.Offset@)">
            <summary>
            Deconstruct this <see cref="T:NodaTime.OffsetDateTime"/> into its components.
            </summary>
            <param name="localDateTime">The <see cref="P:NodaTime.OffsetDateTime.LocalDateTime"/> component.</param>
            <param name="offset">The <see cref="P:NodaTime.OffsetDateTime.Offset"/> component.</param>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Deconstruct(NodaTime.LocalDate@,NodaTime.LocalTime@,NodaTime.Offset@)">
            <summary>
            Deconstruct this <see cref="T:NodaTime.OffsetDateTime"/> into its components.
            </summary>
            <param name="localDate">The <see cref="T:NodaTime.LocalDate"/> component.</param>
            <param name="localTime">The <see cref="T:NodaTime.LocalTime"/> component.</param>
            <param name="offset">The <see cref="P:NodaTime.OffsetDateTime.Offset"/> component.</param>
        </member>
        <member name="M:NodaTime.OffsetDateTime.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("G"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("G").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Add(NodaTime.OffsetDateTime,NodaTime.Duration)">
            <summary>
            Adds a duration to an offset date and time.
            </summary>
            <remarks>
            This is an alternative way of calling <see cref="M:NodaTime.OffsetDateTime.op_Addition(NodaTime.OffsetDateTime,NodaTime.Duration)"/>.
            </remarks>
            <param name="offsetDateTime">The value to add the duration to.</param>
            <param name="duration">The duration to add</param>
            <returns>A new value with the time advanced by the given duration, in the same calendar system and with the same offset.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Plus(NodaTime.Duration)">
            <summary>
            Returns the result of adding a duration to this offset date and time.
            </summary>
            <remarks>
            This is an alternative way of calling <see cref="M:NodaTime.OffsetDateTime.op_Addition(NodaTime.OffsetDateTime,NodaTime.Duration)"/>.
            </remarks>
            <param name="duration">The duration to add</param>
            <returns>A new <see cref="T:NodaTime.OffsetDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.PlusHours(System.Int32)">
            <summary>
            Returns the result of adding a increment of hours to this offset date and time
            </summary>
            <param name="hours">The number of hours to add</param>
            <returns>A new <see cref="T:NodaTime.OffsetDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.PlusMinutes(System.Int32)">
            <summary>
            Returns the result of adding an increment of minutes to this offset date and time
            </summary>
            <param name="minutes">The number of minutes to add</param>
            <returns>A new <see cref="T:NodaTime.OffsetDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.PlusSeconds(System.Int64)">
            <summary>
            Returns the result of adding an increment of seconds to this offset date and time
            </summary>
            <param name="seconds">The number of seconds to add</param>
            <returns>A new <see cref="T:NodaTime.OffsetDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.PlusMilliseconds(System.Int64)">
            <summary>
            Returns the result of adding an increment of milliseconds to this offset date and time
            </summary>
            <param name="milliseconds">The number of milliseconds to add</param>
            <returns>A new <see cref="T:NodaTime.OffsetDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.PlusTicks(System.Int64)">
            <summary>
            Returns the result of adding an increment of ticks to this offset date and time
            </summary>
            <param name="ticks">The number of ticks to add</param>
            <returns>A new <see cref="T:NodaTime.OffsetDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.PlusNanoseconds(System.Int64)">
            <summary>
            Returns the result of adding an increment of nanoseconds to this offset date and time
            </summary>
            <param name="nanoseconds">The number of nanoseconds to add</param>
            <returns>A new <see cref="T:NodaTime.OffsetDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.op_Addition(NodaTime.OffsetDateTime,NodaTime.Duration)">
            <summary>
            Returns a new <see cref="T:NodaTime.OffsetDateTime"/> with the time advanced by the given duration.
            </summary>
            <remarks>
            The returned value retains the calendar system and offset of the <paramref name="offsetDateTime"/>.
            </remarks>
            <param name="offsetDateTime">The <see cref="T:NodaTime.OffsetDateTime"/> to add the duration to.</param>
            <param name="duration">The duration to add.</param>
            <returns>A new value with the time advanced by the given duration, in the same calendar system and with the same offset.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Subtract(NodaTime.OffsetDateTime,NodaTime.Duration)">
            <summary>
            Subtracts a duration from an offset date and time.
            </summary>
            <remarks>
            This is an alternative way of calling <see cref="M:NodaTime.OffsetDateTime.op_Subtraction(NodaTime.OffsetDateTime,NodaTime.Duration)"/>.
            </remarks>
            <param name="offsetDateTime">The value to subtract the duration from.</param>
            <param name="duration">The duration to subtract.</param>
            <returns>A new value with the time "rewound" by the given duration, in the same calendar system and with the same offset.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Minus(NodaTime.Duration)">
            <summary>
            Returns the result of subtracting a duration from this offset date and time, for a fluent alternative to
            <see cref="M:NodaTime.OffsetDateTime.op_Subtraction(NodaTime.OffsetDateTime,NodaTime.Duration)"/>
            </summary>
            <param name="duration">The duration to subtract</param>
            <returns>A new <see cref="T:NodaTime.OffsetDateTime" /> representing the result of the subtraction.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.op_Subtraction(NodaTime.OffsetDateTime,NodaTime.Duration)">
            <summary>
            Returns a new <see cref="T:NodaTime.OffsetDateTime"/> with the duration subtracted.
            </summary>
            <remarks>
            The returned value retains the calendar system and offset of the <paramref name="offsetDateTime"/>.
            </remarks>
            <param name="offsetDateTime">The value to subtract the duration from.</param>
            <param name="duration">The duration to subtract.</param>
            <returns>A new value with the time "rewound" by the given duration, in the same calendar system and with the same offset.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Subtract(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <summary>
            Subtracts one offset date and time from another, returning an elapsed duration.
            </summary>
            <remarks>
            This is an alternative way of calling <see cref="M:NodaTime.OffsetDateTime.op_Subtraction(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)"/>.
            </remarks>
            <param name="end">The offset date and time value to subtract from; if this is later than <paramref name="start"/>
            then the result will be positive.</param>
            <param name="start">The offset date and time to subtract from <paramref name="end"/>.</param>
            <returns>The elapsed duration from <paramref name="start"/> to <paramref name="end"/>.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Minus(NodaTime.OffsetDateTime)">
            <summary>
            Returns the result of subtracting another offset date and time from this one, resulting in the elapsed duration
            between the two instants represented in the values.
            </summary>
            <remarks>
            This is an alternative way of calling <see cref="M:NodaTime.OffsetDateTime.op_Subtraction(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)"/>.
            </remarks>
            <param name="other">The offset date and time to subtract from this one.</param>
            <returns>The elapsed duration from <paramref name="other"/> to this value.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.op_Subtraction(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <summary>
            Subtracts one <see cref="T:NodaTime.OffsetDateTime"/> from another, resulting in the elapsed time between
            the two values.
            </summary>
            <remarks>
            This is equivalent to <c>end.ToInstant() - start.ToInstant()</c>; in particular:
            <list type="bullet">
              <item><description>The two values can use different calendar systems</description></item>
              <item><description>The two values can have different UTC offsets</description></item>
            </list>
            </remarks>
            <param name="end">The offset date and time value to subtract from; if this is later than <paramref name="start"/>
            then the result will be positive.</param>
            <param name="start">The offset date and time to subtract from <paramref name="end"/>.</param>
            <returns>The elapsed duration from <paramref name="start"/> to <paramref name="end"/>.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.op_Equality(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <summary>
            Implements the operator == (equality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.op_Inequality(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <summary>
            Implements the operator != (inequality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:NodaTime.OffsetDateTime.Comparer">
            <summary>
            Base class for <see cref="T:NodaTime.OffsetDateTime"/> comparers.
            </summary>
            <remarks>
            Use the static properties of this class to obtain instances. This type is exposed so that the
            same value can be used for both equality and ordering comparisons.
            </remarks>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Comparer.Local">
            <summary>
            Gets a comparer which compares <see cref="T:NodaTime.OffsetDateTime"/> values by their local date/time, without reference to
            the offset. Comparisons between two values of different calendar systems will fail with <see cref="T:System.ArgumentException"/>.
            </summary>
            <remarks>
            <para>For example, this comparer considers 2013-03-04T20:21:00+0100 to be later than 2013-03-04T19:21:00-0700 even though
            the second value represents a later instant in time.</para>
            <para>This property will return a reference to the same instance every time it is called.</para>
            </remarks>
            <value>A comparer which compares values by their local date/time, without reference to the offset.</value>
        </member>
        <member name="P:NodaTime.OffsetDateTime.Comparer.Instant">
            <summary>
            Returns a comparer which compares <see cref="T:NodaTime.OffsetDateTime"/> values by the instant values obtained by applying the offset to
            the local date/time, ignoring the calendar system.
            </summary>
            <remarks>
            <para>For example, this comparer considers 2013-03-04T20:21:00+0100 to be earlier than 2013-03-04T19:21:00-0700 even though
            the second value has a local time which is earlier.</para>
            <para>This property will return a reference to the same instance every time it is called.</para>
            </remarks>
            <value>A comparer which compares values by the instant values obtained by applying the offset to
            the local date/time, ignoring the calendar system.</value>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Comparer.#ctor">
            <summary>
            Internal constructor to prevent external classes from deriving from this.
            (That means we can add more abstract members in the future.)
            </summary>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Comparer.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <summary>
            Compares two <see cref="T:NodaTime.OffsetDateTime"/> values and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <param name="x">The first value to compare.</param>
            <param name="y">The second value to compare.</param>
            <returns>A signed integer that indicates the relative values of <paramref name="x"/> and <paramref name="y"/>, as shown in the following table.
              <list type = "table">
                <listheader>
                  <term>Value</term>
                  <description>Meaning</description>
                </listheader>
                <item>
                  <term>Less than zero</term>
                  <description><paramref name="x"/> is less than <paramref name="y"/>.</description>
                </item>
                <item>
                  <term>Zero</term>
                  <description><paramref name="x"/> is equals to <paramref name="y"/>.</description>
                </item>
                <item>
                  <term>Greater than zero</term>
                  <description><paramref name="x"/> is greater than <paramref name="y"/>.</description>
                </item>
              </list>
            </returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Comparer.Equals(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <summary>
            Determines whether the specified <c>OffsetDateTime</c> values are equal.
            </summary>
            <param name="x">The first <c>OffsetDateTime</c> to compare.</param>
            <param name="y">The second <c>OffsetDateTime</c> to compare.</param>
            <returns><c>true</c> if the specified objects are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.Comparer.GetHashCode(NodaTime.OffsetDateTime)">
            <summary>
            Returns a hash code for the specified <c>OffsetDateTime</c>.
            </summary>
            <param name="obj">The <c>OffsetDateTime</c> for which a hash code is to be returned.</param>
            <returns>A hash code for the specified value.</returns>
        </member>
        <member name="T:NodaTime.OffsetDateTime.LocalComparer">
            <summary>
            Implementation for <see cref="P:NodaTime.OffsetDateTime.Comparer.Local"/>
            </summary>
        </member>
        <member name="M:NodaTime.OffsetDateTime.LocalComparer.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDateTime.LocalComparer.Equals(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDateTime.LocalComparer.GetHashCode(NodaTime.OffsetDateTime)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.OffsetDateTime.InstantComparer">
            <summary>
            Implementation for <see cref="P:NodaTime.OffsetDateTime.Comparer.Instant"/>.
            </summary>
        </member>
        <member name="M:NodaTime.OffsetDateTime.InstantComparer.Compare(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDateTime.InstantComparer.Equals(NodaTime.OffsetDateTime,NodaTime.OffsetDateTime)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDateTime.InstantComparer.GetHashCode(NodaTime.OffsetDateTime)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDateTime.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.OffsetDateTime"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.OffsetTime">
            <summary>
            A combination of a <see cref="T:NodaTime.LocalTime"/> and an <see cref="P:NodaTime.OffsetTime.Offset"/>, to represent
            a time-of-day at a specific offset from UTC but without any date information.
            </summary>
            <para>
            Equality is defined in a component-wise fashion: two values are the same if they represent equal time-of-day values
            and equal offsets from UTC. Ordering between offset time values is not defined.
            </para>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.OffsetTime.#ctor(NodaTime.LocalTime,NodaTime.Offset)">
            <summary>
            Constructs an instance of the specified time and offset.
            </summary>
            <param name="time">The time part of the value.</param>
            <param name="offset">The offset part of the value.</param>
        </member>
        <member name="P:NodaTime.OffsetTime.TimeOfDay">
            <summary>
            Gets the time-of-day represented by this value.
            </summary>
            <value>The time-of-day represented by this value.</value>
        </member>
        <member name="P:NodaTime.OffsetTime.Offset">
            <summary>
            Gets the offset from UTC of this value.
            <value>The offset from UTC of this value.</value>
            </summary>
        </member>
        <member name="P:NodaTime.OffsetTime.OffsetSeconds">
            <summary>
            Returns the number of seconds in the offset, without going via an Offset.
            </summary>
        </member>
        <member name="P:NodaTime.OffsetTime.OffsetNanoseconds">
            <summary>
            Returns the number of nanoseconds in the offset, without going via an Offset.
            </summary>
        </member>
        <member name="P:NodaTime.OffsetTime.Hour">
            <summary>
            Gets the hour of day of this offset time, in the range 0 to 23 inclusive.
            </summary>
            <value>The hour of day of this offset time, in the range 0 to 23 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetTime.ClockHourOfHalfDay">
            <summary>
            Gets the hour of the half-day of this offset time, in the range 1 to 12 inclusive.
            </summary>
            <value>The hour of the half-day of this offset time, in the range 1 to 12 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetTime.Minute">
            <summary>
            Gets the minute of this offset time, in the range 0 to 59 inclusive.
            </summary>
            <value>The minute of this offset time, in the range 0 to 59 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetTime.Second">
            <summary>
            Gets the second of this offset time within the minute, in the range 0 to 59 inclusive.
            </summary>
            <value>The second of this offset time within the minute, in the range 0 to 59 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetTime.Millisecond">
            <summary>
            Gets the millisecond of this offset time within the second, in the range 0 to 999 inclusive.
            </summary>
            <value>The millisecond of this offset time within the second, in the range 0 to 999 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetTime.TickOfSecond">
            <summary>
            Gets the tick of this offset time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
            <value>The tick of this offset time within the second, in the range 0 to 9,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetTime.TickOfDay">
            <summary>
            Gets the tick of this offset time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
            <remarks>
            If the value does not fall on a tick boundary, it will be truncated towards zero.
            </remarks>
            <value>The tick of this offset time within the day, in the range 0 to 863,999,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetTime.NanosecondOfSecond">
            <summary>
            Gets the nanosecond of this offset time within the second, in the range 0 to 999,999,999 inclusive.
            </summary>
            <value>The nanosecond of this offset time within the second, in the range 0 to 999,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.OffsetTime.NanosecondOfDay">
            <summary>
            Gets the nanosecond of this offset time within the day, in the range 0 to 86,399,999,999,999 inclusive.
            </summary>
            <value>The nanosecond of this offset time within the day, in the range 0 to 86,399,999,999,999 inclusive.</value>
        </member>
        <member name="M:NodaTime.OffsetTime.WithOffset(NodaTime.Offset)">
            <summary>
            Creates a new <see cref="T:NodaTime.OffsetTime"/> for the same time-of-day, but with the specified UTC offset.
            </summary>
            <param name="offset">The new UTC offset.</param>
            <returns>A new <c>OffsetTime</c> for the same date, but with the specified UTC offset.</returns>
        </member>
        <member name="M:NodaTime.OffsetTime.With(System.Func{NodaTime.LocalTime,NodaTime.LocalTime})">
            <summary>
            Returns this offset time-of-day, with the given date adjuster applied to it, maintaining the existing offset.
            </summary>
            <remarks>
            If the adjuster attempts to construct an invalid time-of-day, any exception thrown by
            that construction attempt will be propagated through this method.
            </remarks>
            <param name="adjuster">The adjuster to apply.</param>
            <returns>The adjusted offset date.</returns>
        </member>
        <member name="M:NodaTime.OffsetTime.On(NodaTime.LocalDate)">
            <summary>
            Combines this <see cref="T:NodaTime.OffsetTime"/> with the given <see cref="T:NodaTime.LocalDate"/>
            into an <see cref="T:NodaTime.OffsetDateTime"/>.
            </summary>
            <param name="date">The date to combine with this time-of-day.</param>
            <returns>The <see cref="T:NodaTime.OffsetDateTime"/> representation of this time-of-day on the given date.</returns>
        </member>
        <member name="M:NodaTime.OffsetTime.GetHashCode">
            <summary>
            Returns a hash code for this offset time.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>A hash code for this offset time.</returns>
        </member>
        <member name="M:NodaTime.OffsetTime.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:NodaTime.OffsetTime"/> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The object to compare this offset time with.</param>
            <returns>True if the given value is another offset time equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.OffsetTime.Equals(NodaTime.OffsetTime)">
            <summary>
            Compares two <see cref="T:NodaTime.OffsetTime"/> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">The value to compare this offset time with.</param>
            <returns>True if the given value is another offset time equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.OffsetTime.op_Equality(NodaTime.OffsetTime,NodaTime.OffsetTime)">
            <summary>
            Implements the operator == (equality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.OffsetTime.op_Inequality(NodaTime.OffsetTime,NodaTime.OffsetTime)">
            <summary>
            Implements the operator != (inequality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.OffsetTime.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("G"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.OffsetTime.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("G").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.OffsetTime.Deconstruct(NodaTime.LocalTime@,NodaTime.Offset@)">
            <summary>
             Deconstruct this value into its components.
             </summary>
             <param name="localTime">
             The <see cref="T:NodaTime.LocalTime"/> component.
             </param>
             <param name="offset">
             The <see cref="P:NodaTime.OffsetTime.Offset"/> component.
             </param>
        </member>
        <member name="M:NodaTime.OffsetTime.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.OffsetTime"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.OffsetTime.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.OffsetTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.Period">
            <summary>
            Represents a period of time expressed in human chronological terms: hours, days,
            weeks, months and so on.
            </summary>
            <remarks>
            <para>
            A <see cref="T:NodaTime.Period"/> contains a set of properties such as <see cref="P:NodaTime.Period.Years"/>, <see cref="P:NodaTime.Period.Months"/>, and so on
            that return the number of each unit contained within this period. Note that these properties are not normalized in
            any way by default, and so a <see cref="T:NodaTime.Period"/> may contain values such as "2 hours and 90 minutes". The
            <see cref="M:NodaTime.Period.Normalize"/> method will convert equivalent periods into a standard representation.
            </para>
            <para>
            Periods can contain negative units as well as positive units ("+2 hours, -43 minutes, +10 seconds"), but do not
            differentiate between properties that are zero and those that are absent (i.e. a period created as "10 years"
            and one created as "10 years, zero months" are equal periods; the <see cref="P:NodaTime.Period.Months"/> property returns zero in
            both cases).
            </para>
            <para>
            <see cref="T:NodaTime.Period"/> equality is implemented by comparing each property's values individually, without any normalization.
            (For example, a period of "24 hours" is not considered equal to a period of "1 day".) The static
            <see cref="P:NodaTime.Period.NormalizingEqualityComparer"/> comparer provides an equality comparer which performs normalization before comparisons.
            </para>
            <para>
            There is no natural ordering for periods, but <see cref="M:NodaTime.Period.CreateComparer(NodaTime.LocalDateTime)"/> can be used to create a
            comparer which orders periods according to a reference date, by adding each period to that date and comparing the results.
            </para>
            <para>
            Periods operate on calendar-related types such as
            <see cref="T:NodaTime.LocalDateTime" /> whereas <see cref="T:NodaTime.Duration"/> operates on instants
            on the time line. (Note that although <see cref="T:NodaTime.ZonedDateTime" /> includes both concepts, it only supports
            duration-based arithmetic.)
            </para>
            <para>
            The complexity of each method in this type is hard to document precisely, and often depends on the calendar system
            involved in performing the actual calculations. Operations do not depend on the magnitude of the units in the period,
            other than for optimizations for values of zero or occasionally for particularly small values. For example,
            adding 10,000 days to a date does not require greater algorithmic complexity than adding 1,000 days to the same date.
            </para>
            </remarks>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.Period.Zero">
            <summary>
            A period containing only zero-valued properties.
            </summary>
            <value>A period containing only zero-valued properties.</value>
        </member>
        <member name="P:NodaTime.Period.NormalizingEqualityComparer">
            <summary>
            Returns an equality comparer which compares periods by first normalizing them - so 24 hours is deemed equal to 1 day, and so on.
            Note that as per the <see cref="M:NodaTime.Period.Normalize"/> method, years and months are unchanged by normalization - so 12 months does not
            equal 1 year.
            </summary>
            <value>An equality comparer which compares periods by first normalizing them.</value>
        </member>
        <member name="P:NodaTime.Period.Nanoseconds">
            <summary>
            Gets the number of nanoseconds within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
            <value>The number of nanoseconds within this period.</value>
        </member>
        <member name="P:NodaTime.Period.Ticks">
            <summary>
            Gets the number of ticks within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
            <value>The number of ticks within this period.</value>
        </member>
        <member name="P:NodaTime.Period.Milliseconds">
            <summary>
            Gets the number of milliseconds within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
            <value>The number of milliseconds within this period.</value>
        </member>
        <member name="P:NodaTime.Period.Seconds">
            <summary>
            Gets the number of seconds within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
            <value>The number of seconds within this period.</value>
        </member>
        <member name="P:NodaTime.Period.Minutes">
            <summary>
            Gets the number of minutes within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
            <value>The number of minutes within this period.</value>
        </member>
        <member name="P:NodaTime.Period.Hours">
            <summary>
            Gets the number of hours within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
            <value>The number of hours within this period.</value>
        </member>
        <member name="P:NodaTime.Period.Days">
            <summary>
            Gets the number of days within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
            <value>The number of days within this period.</value>
        </member>
        <member name="P:NodaTime.Period.Weeks">
            <summary>
            Gets the number of weeks within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
            <value>The number of weeks within this period.</value>
        </member>
        <member name="P:NodaTime.Period.Months">
            <summary>
            Gets the number of months within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
            <value>The number of months within this period.</value>
        </member>
        <member name="P:NodaTime.Period.Years">
            <summary>
            Gets the number of years within this period.
            </summary>
            <remarks>
            This property returns zero both when the property has been explicitly set to zero and when the period does not
            contain this property.
            </remarks>
            <value>The number of years within this period.</value>
        </member>
        <member name="M:NodaTime.Period.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a period with the given date values.
            </summary>
        </member>
        <member name="M:NodaTime.Period.#ctor(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a period with the given time values.
            </summary>
        </member>
        <member name="M:NodaTime.Period.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Creates a new period from the given values.
            </summary>
        </member>
        <member name="M:NodaTime.Period.FromYears(System.Int32)">
            <summary>
            Creates a period representing the specified number of years.
            </summary>
            <param name="years">The number of years in the new period</param>
            <returns>A period consisting of the given number of years.</returns>
        </member>
        <member name="M:NodaTime.Period.FromMonths(System.Int32)">
            <summary>
            Creates a period representing the specified number of months.
            </summary>
            <param name="months">The number of months in the new period</param>
            <returns>A period consisting of the given number of months.</returns>
        </member>
        <member name="M:NodaTime.Period.FromWeeks(System.Int32)">
            <summary>
            Creates a period representing the specified number of weeks.
            </summary>
            <param name="weeks">The number of weeks in the new period</param>
            <returns>A period consisting of the given number of weeks.</returns>
        </member>
        <member name="M:NodaTime.Period.FromDays(System.Int32)">
            <summary>
            Creates a period representing the specified number of days.
            </summary>
            <param name="days">The number of days in the new period</param>
            <returns>A period consisting of the given number of days.</returns>
        </member>
        <member name="M:NodaTime.Period.FromHours(System.Int64)">
            <summary>
            Creates a period representing the specified number of hours.
            </summary>
            <param name="hours">The number of hours in the new period</param>
            <returns>A period consisting of the given number of hours.</returns>
        </member>
        <member name="M:NodaTime.Period.FromMinutes(System.Int64)">
            <summary>
            Creates a period representing the specified number of minutes.
            </summary>
            <param name="minutes">The number of minutes in the new period</param>
            <returns>A period consisting of the given number of minutes.</returns>
        </member>
        <member name="M:NodaTime.Period.FromSeconds(System.Int64)">
            <summary>
            Creates a period representing the specified number of seconds.
            </summary>
            <param name="seconds">The number of seconds in the new period</param>
            <returns>A period consisting of the given number of seconds.</returns>
        </member>
        <member name="M:NodaTime.Period.FromMilliseconds(System.Int64)">
            <summary>
            Creates a period representing the specified number of milliseconds.
            </summary>
            <param name="milliseconds">The number of milliseconds in the new period</param>
            <returns>A period consisting of the given number of milliseconds.</returns>
        </member>
        <member name="M:NodaTime.Period.FromTicks(System.Int64)">
            <summary>
            Creates a period representing the specified number of ticks.
            </summary>
            <param name="ticks">The number of ticks in the new period</param>
            <returns>A period consisting of the given number of ticks.</returns>
        </member>
        <member name="M:NodaTime.Period.FromNanoseconds(System.Int64)">
            <summary>
            Creates a period representing the specified number of nanoseconds.
            </summary>
            <param name="nanoseconds">The number of nanoseconds in the new period</param>
            <returns>A period consisting of the given number of nanoseconds.</returns>
        </member>
        <member name="M:NodaTime.Period.op_Addition(NodaTime.Period,NodaTime.Period)">
            <summary>
            Adds two periods together, by simply adding the values for each property.
            </summary>
            <param name="left">The first period to add</param>
            <param name="right">The second period to add</param>
            <returns>The sum of the two periods. The units of the result will be the union of those in both
            periods.</returns>
        </member>
        <member name="M:NodaTime.Period.Add(NodaTime.Period,NodaTime.Period)">
            <summary>
            Adds two periods together, by simply adding the values for each property.
            </summary>
            <param name="left">The first period to add</param>
            <param name="right">The second period to add</param>
            <returns>The sum of the two periods. The units of the result will be the union of those in both
            periods.</returns>
        </member>
        <member name="M:NodaTime.Period.CreateComparer(NodaTime.LocalDateTime)">
            <summary>
            Creates an <see cref="T:System.Collections.Generic.IComparer`1"/> for periods, using the given "base" local date/time.
            </summary>
            <remarks>
            Certain periods can't naturally be compared without more context - how "one month" compares to
            "30 days" depends on where you start. In order to compare two periods, the returned comparer
            effectively adds both periods to the "base" specified by <paramref name="baseDateTime"/> and compares
            the results. In some cases this arithmetic isn't actually required - when two periods can be
            converted to durations, the comparer uses that conversion for efficiency.
            </remarks>
            <param name="baseDateTime">The base local date/time to use for comparisons.</param>
            <returns>The new comparer.</returns>
        </member>
        <member name="M:NodaTime.Period.op_Subtraction(NodaTime.Period,NodaTime.Period)">
            <summary>
            Subtracts one period from another, by simply subtracting each property value.
            </summary>
            <param name="minuend">The period to subtract the second operand from</param>
            <param name="subtrahend">The period to subtract the first operand from</param>
            <returns>The result of subtracting all the values in the second operand from the values in the first. The
            units of the result will be the union of both periods, even if the subtraction caused some properties to
            become zero (so "2 weeks, 1 days" minus "2 weeks" is "zero weeks, 1 days", not "1 days").</returns>
        </member>
        <member name="M:NodaTime.Period.Subtract(NodaTime.Period,NodaTime.Period)">
            <summary>
            Subtracts one period from another, by simply subtracting each property value.
            </summary>
            <param name="minuend">The period to subtract the second operand from</param>
            <param name="subtrahend">The period to subtract the first operand from</param>
            <returns>The result of subtracting all the values in the second operand from the values in the first. The
            units of the result will be the union of both periods, even if the subtraction caused some properties to
            become zero (so "2 weeks, 1 days" minus "2 weeks" is "zero weeks, 1 days", not "1 days").</returns>
        </member>
        <member name="M:NodaTime.Period.DaysBetween(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Returns the number of days between two <see cref="T:NodaTime.LocalDate"/> objects.
            </summary>
            <param name="start">Start date/time</param>
            <param name="end">End date/time</param> 
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and <paramref name="end"/> use different calendars.</exception>
            <returns>The number of days between the given dates.</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime,NodaTime.PeriodUnits)">
            <summary>
            Returns the period between a start and an end date/time, using only the given units.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative. If the given set of units cannot exactly reach the end point (e.g. finding
            the difference between 1am and 3:15am in hours) the result will be such that adding it to <paramref name="start"/>
            will give a value between <paramref name="start"/> and <paramref name="end"/>. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
            <param name="start">Start date/time</param>
            <param name="end">End date/time</param>
            <param name="units">Units to use for calculations</param>
            <exception cref="T:System.ArgumentException"><paramref name="units"/> is empty or contained unknown values.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and <paramref name="end"/> use different calendars.</exception>
            <returns>The period between the given date/times, using the given units.</returns>
        </member>
        <member name="M:NodaTime.Period.DateComponentsBetween(NodaTime.LocalDate,NodaTime.LocalDate,NodaTime.PeriodUnits,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Common code to perform the date parts of the Between methods.
            </summary>
            <param name="start">Start date</param>
            <param name="end">End date</param>
            <param name="units">Units to compute</param>
            <param name="years">(Out) Year component of result</param>
            <param name="months">(Out) Months component of result</param>
            <param name="weeks">(Out) Weeks component of result</param>
            <param name="days">(Out) Days component of result</param>
            <returns>The resulting date after adding the result components to <paramref name="start"/> (to
            allow further computations to be made)</returns>
        </member>
        <member name="M:NodaTime.Period.TimeComponentsBetween(System.Int64,NodaTime.PeriodUnits,System.Int64@,System.Int64@,System.Int64@,System.Int64@,System.Int64@,System.Int64@)">
            <summary>
            Common code to perform the time parts of the Between methods for long-representable nanos.
            </summary>
            <param name="totalNanoseconds">Number of nanoseconds to compute the units of</param>
            <param name="units">Units to compute</param>
            <param name="hours">(Out) Hours component of result</param>
            <param name="minutes">(Out) Minutes component of result</param>
            <param name="seconds">(Out) Seconds component of result</param>
            <param name="milliseconds">(Out) Milliseconds component of result</param>
            <param name="ticks">(Out) Ticks component of result</param>
            <param name="nanoseconds">(Out) Nanoseconds component of result</param>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalDateTime,NodaTime.LocalDateTime)">
            <summary>
            Returns the exact difference between two date/times.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative.
            </remarks>
            <param name="start">Start date/time</param>
            <param name="end">End date/time</param>
            <returns>The period between the two date and time values, using all units.</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate,NodaTime.PeriodUnits)">
            <summary>
            Returns the period between a start and an end date, using only the given units.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative. If the given set of units cannot exactly reach the end point (e.g. finding
            the difference between 12th February and 15th March in months) the result will be such that adding it to <paramref name="start"/>
            will give a value between <paramref name="start"/> and <paramref name="end"/>. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
            <param name="start">Start date</param>
            <param name="end">End date</param>
            <param name="units">Units to use for calculations</param>
            <exception cref="T:System.ArgumentException"><paramref name="units"/> contains time units, is empty or contains unknown values.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and <paramref name="end"/> use different calendars.</exception>
            <returns>The period between the given dates, using the given units.</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Returns the exact difference between two dates.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative.
            The calendar systems of the two dates must be the same; an exception will be thrown otherwise.
            </remarks>
            <param name="start">Start date</param>
            <param name="end">End date</param>
            <returns>The period between the two dates, using year, month and day units.</returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="start"/> and <paramref name="end"/> are not in the same calendar system.
            </exception>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime,NodaTime.PeriodUnits)">
            <summary>
            Returns the period between a start and an end time, using only the given units.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative. If the given set of units cannot exactly reach the end point (e.g. finding
            the difference between 3am and 4.30am in hours) the result will be such that adding it to <paramref name="start"/>
            will give a value between <paramref name="start"/> and <paramref name="end"/>. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
            <param name="start">Start time</param>
            <param name="end">End time</param>
            <param name="units">Units to use for calculations</param>
            <exception cref="T:System.ArgumentException"><paramref name="units"/> contains date units, is empty or contains unknown values.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and <paramref name="end"/> use different calendars.</exception>
            <returns>The period between the given times, using the given units.</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.LocalTime,NodaTime.LocalTime)">
            <summary>
            Returns the exact difference between two times.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative.
            </remarks>
            <param name="start">Start time</param>
            <param name="end">End time</param>
            <returns>The period between the two times, using the time period units.</returns>
        </member>
        <member name="M:NodaTime.Period.InternalDaysBetween(NodaTime.LocalDate,NodaTime.LocalDate)">
            <summary>
            Returns the number of days between two dates. This allows optimizations in DateInterval,
            and for date calculations which just use days - we don't need state or a virtual method invocation.
            </summary>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.YearMonth,NodaTime.YearMonth,NodaTime.PeriodUnits)">
            <summary>
            Returns the period between a start and an end <see cref="T:NodaTime.YearMonth"/>, using only the given units.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative. If the given set of units cannot exactly reach the end point (e.g. finding
            the difference between February 2010 and March 2012 in years) the result will be such that adding it to <paramref name="start"/>
            will give a value between <paramref name="start"/> and <paramref name="end"/>. In other words,
            any rounding is "towards start"; this is true whether the resulting period is negative or positive.
            </remarks>
            <param name="start">Start year and month</param>
            <param name="end">End year and month</param>
            <param name="units">Units to use for calculations</param>
            <exception cref="T:System.ArgumentException"><paramref name="units"/> is empty or contains anything other than than PeriodUnits.Years
            and/or PeriodUnits.Months.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="start"/> and <paramref name="end"/> use different calendars.</exception>
            <returns>The period between the given YearMonths, using the given units.</returns>
        </member>
        <member name="M:NodaTime.Period.Between(NodaTime.YearMonth,NodaTime.YearMonth)">
            <summary>
            Returns the exact difference between two <see cref="T:NodaTime.YearMonth"/>.
            </summary>
            <remarks>
            If <paramref name="end"/> is before <paramref name="start" />, each property in the returned period
            will be negative.
            The calendar systems of the two dates must be the same; an exception will be thrown otherwise.
            </remarks>
            <param name="start">Start year and month</param>
            <param name="end">End year and month</param>
            <returns>The period between the two YearMonths, using year and month units.</returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="start"/> and <paramref name="end"/> are not in the same calendar system.
            </exception>
        </member>
        <member name="P:NodaTime.Period.HasTimeComponent">
            <summary>
            Returns whether or not this period contains any non-zero-valued time-based properties (hours or lower).
            </summary>
            <value>true if the period contains any non-zero-valued time-based properties (hours or lower); false otherwise.</value>
        </member>
        <member name="P:NodaTime.Period.HasDateComponent">
            <summary>
            Returns whether or not this period contains any non-zero date-based properties (days or higher).
            </summary>
            <value>true if this period contains any non-zero date-based properties (days or higher); false otherwise.</value>
        </member>
        <member name="M:NodaTime.Period.ToDuration">
            <summary>
            For periods that do not contain a non-zero number of years or months, returns a duration for this period
            assuming a standard 7-day week, 24-hour day, 60-minute hour etc.
            </summary>
            <exception cref="T:System.InvalidOperationException">The month or year property in the period is non-zero.</exception>
            <exception cref="T:System.OverflowException">The period doesn't have years or months, but the calculation
            overflows the bounds of <see cref="T:NodaTime.Duration"/>. In some cases this may occur even though the theoretical
            result would be valid due to balancing positive and negative values, but for simplicity there is
            no attempt to work around this - in realistic periods, it shouldn't be a problem.</exception>
            <returns>The duration of the period.</returns>
        </member>
        <member name="P:NodaTime.Period.TotalNanoseconds">
            <summary>
            Gets the total number of nanoseconds duration for the 'standard' properties (all bar years and months).
            </summary>
            <value>The total number of nanoseconds duration for the 'standard' properties (all bar years and months).</value>
        </member>
        <member name="M:NodaTime.Period.ToBuilder">
            <summary>
            Creates a <see cref="T:NodaTime.PeriodBuilder"/> from this instance. The new builder
            is populated with the values from this period, but is then detached from it:
            changes made to the builder are not reflected in this period.
            </summary>
            <returns>A builder with the same values and units as this period.</returns>
        </member>
        <member name="M:NodaTime.Period.Normalize">
            <summary>
            Returns a normalized version of this period, such that equivalent (but potentially non-equal) periods are
            changed to the same representation.
            </summary>
            <remarks>
            Months and years are unchanged
            (as they can vary in length), but weeks are multiplied by 7 and added to the
            Days property, and all time properties are normalized to their natural range.
            Subsecond values are normalized to millisecond and "nanosecond within millisecond" values.
            So for example, a period of 25 hours becomes a period of 1 day
            and 1 hour. A period of 1,500,750,000 nanoseconds becomes 1 second, 500 milliseconds and
            750,000 nanoseconds. Aside from months and years, either all the properties
            end up positive, or they all end up negative. "Week" and "tick" units in the returned period are always 0.
            </remarks>
            <exception cref="T:System.OverflowException">The period doesn't have years or months, but it contains more than
            <see cref="F:System.Int64.MaxValue"/> nanoseconds when the combined weeks/days/time portions are considered. This is
            over 292 years, so unlikely to be a problem in normal usage.
            In some cases this may occur even though the theoretical result would be valid due to balancing positive and
            negative values, but for simplicity there is no attempt to work around this.</exception>
            <returns>The normalized period.</returns>
            <seealso cref="P:NodaTime.Period.NormalizingEqualityComparer"/>
        </member>
        <member name="M:NodaTime.Period.ToString">
            <summary>
            Returns this string formatted according to the <see cref="P:NodaTime.Text.PeriodPattern.Roundtrip"/>.
            </summary>
            <returns>A formatted representation of this period.</returns>
        </member>
        <member name="M:NodaTime.Period.Equals(System.Object)">
            <summary>
            Compares the given object for equality with this one, as per <see cref="M:NodaTime.Period.Equals(NodaTime.Period)"/>.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">The value to compare this one with.</param>
            <returns>true if the other object is a period equal to this one, consistent with <see cref="M:NodaTime.Period.Equals(NodaTime.Period)"/></returns>
        </member>
        <member name="M:NodaTime.Period.GetHashCode">
            <summary>
            Returns the hash code for this period, consistent with <see cref="M:NodaTime.Period.Equals(NodaTime.Period)"/>.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>The hash code for this period.</returns>
        </member>
        <member name="M:NodaTime.Period.Equals(NodaTime.Period)">
            <summary>
            Compares the given period for equality with this one.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">The period to compare this one with.</param>
            <returns>True if this period has the same values for the same properties as the one specified.</returns>
        </member>
        <member name="M:NodaTime.Period.op_Equality(NodaTime.Period,NodaTime.Period)">
            <summary>
            Implements the operator == (equality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.Period.op_Inequality(NodaTime.Period,NodaTime.Period)">
            <summary>
            Implements the operator != (inequality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="T:NodaTime.Period.NormalizingPeriodEqualityComparer">
            <summary>
            Equality comparer which simply normalizes periods before comparing them.
            </summary>
        </member>
        <member name="T:NodaTime.PeriodBuilder">
            <summary>
            A mutable builder class for <see cref="T:NodaTime.Period"/> values. Each property can
            be set independently, and then a Period can be created from the result
            using the <see cref="M:NodaTime.PeriodBuilder.Build"/> method.
            </summary>
            <threadsafety>
            This type is not thread-safe without extra synchronization, but has no
            thread affinity.
            </threadsafety>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Years">
            <summary>
            Gets or sets the number of years within the period.
            </summary>
            <value>The number of years within the period.</value>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Months">
            <summary>
            Gets or sets the number of months within the period.
            </summary>
            <value>The number of months within the period.</value>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Weeks">
            <summary>
            Gets or sets the number of weeks within the period.
            </summary>
            <value>The number of weeks within the period.</value>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Days">
            <summary>
            Gets or sets the number of days within the period.
            </summary>
            <value>The number of days within the period.</value>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Hours">
            <summary>
            Gets or sets the number of hours within the period.
            </summary>
            <value>The number of hours within the period.</value>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Minutes">
            <summary>
            Gets or sets the number of minutes within the period.
            </summary>
            <value>The number of minutes within the period.</value>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Seconds">
            <summary>
            Gets or sets the number of seconds within the period.
            </summary>
            <value>The number of seconds within the period.</value>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Milliseconds">
            <summary>
            Gets or sets the number of milliseconds within the period.
            </summary>
            <value>The number of milliseconds within the period.</value>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Ticks">
            <summary>
            Gets or sets the number of ticks within the period.
            </summary>
            <value>The number of ticks within the period.</value>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Nanoseconds">
            <summary>
            Gets or sets the number of nanoseconds within the period.
            </summary>
            <value>The number of nanoseconds within the period.</value>
        </member>
        <member name="M:NodaTime.PeriodBuilder.#ctor">
            <summary>
            Creates a new period builder with an initially zero period.
            </summary>
        </member>
        <member name="M:NodaTime.PeriodBuilder.#ctor(NodaTime.Period)">
            <summary>
            Creates a new period builder with the values from an existing
            period. Calling this constructor instead of <see cref="M:NodaTime.Period.ToBuilder"/>
            allows object initializers to be used.
            </summary>
            <param name="period">An existing period to copy values from.</param>
        </member>
        <member name="P:NodaTime.PeriodBuilder.Item(NodaTime.PeriodUnits)">
            <summary>
            Gets or sets the value of a single unit.
            </summary>
            <remarks>
            <para>
            The type of this indexer is <see cref="T:System.Int64"/> for uniformity, but any date unit (year, month, week, day) will only ever have a value
            in the range of <see cref="T:System.Int32"/>.
            </para>
            <para>
            For the <see cref="F:NodaTime.PeriodUnits.Nanoseconds"/> unit, the value is converted to <c>Int64</c> when reading from the indexer, causing it to
            fail if the value is out of range (around 250 years). To access the values of very large numbers of nanoseconds, use the <see cref="P:NodaTime.PeriodBuilder.Nanoseconds"/>
            property directly.
            </para>
            </remarks>
            <param name="unit">A single value within the <see cref="T:NodaTime.PeriodUnits"/> enumeration.</param>
            <value>The value of the given unit within this period builder, or zero if the unit is unset.</value>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="unit"/> is not a single unit, or a value is provided for a date unit which is outside the range of <see cref="T:System.Int32"/>.</exception>
        </member>
        <member name="M:NodaTime.PeriodBuilder.Build">
            <summary>
            Builds a period from the properties in this builder.
            </summary>
            <returns>A period containing the values from this builder.</returns>
        </member>
        <member name="M:NodaTime.PeriodBuilder.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.PeriodBuilder"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.PeriodBuilder.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.PeriodUnits">
            <summary>
            The units within a <see cref="T:NodaTime.Period"/>. When a period is created to find the difference between two local values,
            the caller may specify which units are required - for example, you can ask for the difference between two dates
            in "years and weeks". Units are always applied largest-first in arithmetic.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.None">
            <summary>
            Value indicating no units - an empty period.
            </summary>        
        </member>
        <member name="F:NodaTime.PeriodUnits.Years">
            <summary>
            Years element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Months">
            <summary>
            Months element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Weeks">
            <summary>
            Weeks element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Days">
            <summary>
            Days element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.AllDateUnits">
            <summary>
            Compound value representing the combination of <see cref="F:NodaTime.PeriodUnits.Years"/>, <see cref="F:NodaTime.PeriodUnits.Months"/>, <see cref="F:NodaTime.PeriodUnits.Weeks"/> and <see cref="F:NodaTime.PeriodUnits.Days"/>.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.YearMonthDay">
            <summary>
            Compound value representing the combination of <see cref="F:NodaTime.PeriodUnits.Years"/>, <see cref="F:NodaTime.PeriodUnits.Months"/> and <see cref="F:NodaTime.PeriodUnits.Days"/>.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Hours">
            <summary>
            Hours element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Minutes">
            <summary>
            Minutes element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Seconds">
            <summary>
            Seconds element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Milliseconds">
            <summary>
            Milliseconds element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Ticks">
            <summary>
            Tick element within a <see cref="T:NodaTime.Period" />
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.Nanoseconds">
            <summary>
            Nanoseconds element within a <see cref="T:NodaTime.Period" />.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.HourMinuteSecond">
            <summary>
            Compound value representing the combination of <see cref="F:NodaTime.PeriodUnits.Hours"/>, <see cref="F:NodaTime.PeriodUnits.Minutes"/> and <see cref="F:NodaTime.PeriodUnits.Seconds"/>.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.AllTimeUnits">
            <summary>
            Compound value representing the combination of all time elements.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.DateAndTime">
            <summary>
            Compound value representing the combination of all possible elements except weeks.
            </summary>
        </member>
        <member name="F:NodaTime.PeriodUnits.AllUnits">
            <summary>
            Compound value representing the combination of all possible elements.
            </summary>
        </member>
        <member name="T:NodaTime.SkippedTimeException">
            <summary>
            Exception thrown to indicate that the specified local time doesn't
            exist in a particular time zone due to daylight saving time changes.    
            </summary>
            <remarks>
            <para>
            This normally occurs for spring transitions, where the clock goes forward
            (usually by an hour). For example, suppose the time zone goes forward
            at 2am, so the second after 01:59:59 becomes 03:00:00. In that case,
            local times such as 02:30:00 never occur.
            </para>
            <para>
            This exception is used to indicate such problems, as they're usually
            not the same as other <see cref="T:System.ArgumentOutOfRangeException" /> causes,
            such as entering "15" for a month number.
            </para>
            <para>
            Note that it is possible (though extremely rare) for a whole day to be skipped due to a time zone transition,
            so this exception may also be thrown in cases where no local time is valid for a particular local date. (For
            example, Samoa skipped December 30th 2011 entirely, transitioning from UTC-10 to UTC+14 at midnight.)
            </para>
            </remarks>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="P:NodaTime.SkippedTimeException.LocalDateTime">
            <summary>
            Gets the local date/time which is invalid in the time zone, prompting this exception.
            </summary>
            <value>The local date/time which is invalid in the time zone.</value>
        </member>
        <member name="P:NodaTime.SkippedTimeException.Zone">
            <summary>
            Gets the time zone in which the local date/time is invalid.
            </summary>
            <value>The time zone in which the local date/time is invalid</value>
        </member>
        <member name="M:NodaTime.SkippedTimeException.#ctor(NodaTime.LocalDateTime,NodaTime.DateTimeZone)">
            <summary>
            Creates a new instance for the given local date/time and time zone.
            </summary>
            <remarks>
            User code is unlikely to need to deliberately call this constructor except
            possibly for testing.
            </remarks>
            <param name="localDateTime">The local date/time which is skipped in the specified time zone.</param>
            <param name="zone">The time zone in which the local date/time does not exist.</param>
        </member>
        <member name="T:NodaTime.SystemClock">
            <summary>
            Singleton implementation of <see cref="T:NodaTime.IClock"/> which reads the current system time.
            It is recommended that for anything other than throwaway code, this is only referenced
            in a single place in your code: where you provide a value to inject into the rest of
            your application, which should only depend on the interface.
            </summary>
            <threadsafety>This type has no state, and is thread-safe. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.SystemClock.Instance">
            <summary>
            The singleton instance of <see cref="T:NodaTime.SystemClock"/>.
            </summary>
            <value>The singleton instance of <see cref="T:NodaTime.SystemClock"/>.</value>
        </member>
        <member name="M:NodaTime.SystemClock.#ctor">
            <summary>
            Constructor present to prevent external construction.
            </summary>
        </member>
        <member name="M:NodaTime.SystemClock.GetCurrentInstant">
            <summary>
            Gets the current time as an <see cref="T:NodaTime.Instant"/>.
            </summary>
            <returns>The current time in ticks as an <see cref="T:NodaTime.Instant"/>.</returns>
        </member>
        <member name="T:NodaTime.Text.AnnualDatePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.AnnualDate"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.AnnualDatePattern.Iso">
            <summary>
            Gets an invariant annual date pattern which is compatible with the month/day part of ISO-8601.
            This corresponds to the text pattern "MM'-'dd".
            </summary>
            <value>An invariant annual date pattern which is compatible with the month/day part of ISO-8601.</value>
        </member>
        <member name="T:NodaTime.Text.AnnualDatePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.AnnualDatePattern.UnderlyingPattern">
            <summary>
            Returns the pattern that this object delegates to. Mostly useful to avoid this public class
            implementing an internal interface.
            </summary>
        </member>
        <member name="P:NodaTime.Text.AnnualDatePattern.PatternText">
            <summary>
            Gets the pattern text for this pattern, as supplied on creation.
            </summary>
            <value>The pattern text for this pattern, as supplied on creation.</value>
        </member>
        <member name="P:NodaTime.Text.AnnualDatePattern.FormatInfo">
            <summary>
            Returns the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.AnnualDatePattern.TemplateValue">
            <summary>
            Gets the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
            <value>The value used as a template for parsing.</value>
        </member>
        <member name="M:NodaTime.Text.AnnualDatePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.AnnualDatePattern.Format(NodaTime.AnnualDate)">
            <summary>
            Formats the given annual date as text according to the rules of this pattern.
            </summary>
            <param name="value">The annual date to format.</param>
            <returns>The annual date formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.AnnualDatePattern.AppendFormat(NodaTime.AnnualDate,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="M:NodaTime.Text.AnnualDatePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.AnnualDate)">
            <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting annual dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.AnnualDatePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.AnnualDate)">
            <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting annual dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.AnnualDatePattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture, with a template value of 2000-01-01.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting annual dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.AnnualDatePattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting annual dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.AnnualDatePattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting annual dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.AnnualDatePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="formatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.AnnualDatePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.AnnualDatePattern.WithTemplateValue(NodaTime.AnnualDate)">
            <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
            <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="T:NodaTime.Text.AnnualDatePatternParser">
            <summary>
            Parser for patterns of <see cref="T:NodaTime.AnnualDate"/> values.
            </summary>
        </member>
        <member name="T:NodaTime.Text.AnnualDatePatternParser.AnnualDateParseBucket">
            <summary>
            Bucket to put parsed values in, ready for later result calculation. This type is also used
            by AnnualDateTimePattern to store and calculate values.
            </summary>
        </member>
        <member name="T:NodaTime.Text.CompositePatternBuilder`1">
            <summary>
            A builder for composite patterns.
            </summary>
            <remarks>
            A composite pattern is a combination of multiple patterns. When parsing, these are checked
            in the order in which they are added to the builder with the <see cref="M:NodaTime.Text.CompositePatternBuilder`1.Add(NodaTime.Text.IPattern{`0},System.Func{`0,System.Boolean})"/>
            method, by trying to parse and seeing if the result is a successful one. When formatting,
            the patterns are checked in the reverse order, using the predicate provided along with the pattern
            when calling <c>Add</c>. The intention is that patterns are added in "most precise first" order,
            and the predicate should indicate whether it can fully represent the given value - so the "less precise"
            (and therefore usually shorter) pattern can be used first.
            </remarks>
            <typeparam name="T">The type of value to be parsed or formatted by the resulting pattern.</typeparam>
            <threadsafety>
            This type is mutable, and should not be used between multiple threads. The patterns created
            by the <see cref="M:NodaTime.Text.CompositePatternBuilder`1.Build"/> method are immutable and can be used between multiple threads, assuming
            that each component (both pattern and predicate) is also immutable.
            </threadsafety>
        </member>
        <member name="M:NodaTime.Text.CompositePatternBuilder`1.#ctor">
            <summary>
            Constructs a new instance which initially has no component patterns. At least one component
            pattern must be added before <see cref="M:NodaTime.Text.CompositePatternBuilder`1.Build"/> is called.
            </summary>
        </member>
        <member name="M:NodaTime.Text.CompositePatternBuilder`1.Add(NodaTime.Text.IPattern{`0},System.Func{`0,System.Boolean})">
            <summary>
            Adds a component pattern to this builder.
            </summary>
            <param name="pattern">The component pattern to use as part of the eventual composite pattern.</param>
            <param name="formatPredicate">A predicate to determine whether or not this pattern is suitable for
            formatting the given value.</param>
        </member>
        <member name="M:NodaTime.Text.CompositePatternBuilder`1.Build">
            <summary>
            Builds a composite pattern from this builder. Further changes to this builder
            will have no impact on the returned pattern.
            </summary>
            <exception cref="T:System.InvalidOperationException">No component patterns have been added.</exception>
            <returns>A pattern using the patterns added to this builder.</returns>
        </member>
        <member name="T:NodaTime.Text.DurationPattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.Duration"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.DurationPattern.Roundtrip">
            <summary>
            Gets the general pattern for durations using the invariant culture, with a format string of "-D:hh:mm:ss.FFFFFFFFF".
            This pattern round-trips. This corresponds to the "o" standard pattern.
            </summary>
            <value>The general pattern for durations using the invariant culture.</value>
        </member>
        <member name="P:NodaTime.Text.DurationPattern.JsonRoundtrip">
            <summary>
            Gets a pattern for durations using the invariant culture, with a format string of "-H:mm:ss.FFFFFFFFF".
            This pattern round-trips, and is the pattern that NodaTime.Serialization.JsonNet uses by default.
            This corresponds to the "j" standard pattern.
            </summary>
            <value>The pattern for durations using the invariant culture. This is the pattern that NodaTime.Serialization.JsonNet uses by default.</value>
        </member>
        <member name="P:NodaTime.Text.DurationPattern.PatternText">
            <summary>
            Gets the pattern text for this pattern, as supplied on creation.
            </summary>
            <value>The pattern text for this pattern, as supplied on creation.</value>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.Format(NodaTime.Duration)">
            <summary>
            Formats the given duration as text according to the rules of this pattern.
            </summary>
            <param name="value">The duration to format.</param>
            <returns>The duration formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.AppendFormat(NodaTime.Duration,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the given pattern text and format info.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">Localization information</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.DurationPattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="T:NodaTime.Text.DurationPatternParser.DurationParseBucket">
            <summary>
            Provides a container for the interim parsed pieces of an <see cref="T:NodaTime.Offset" /> value.
            </summary>
        </member>
        <member name="M:NodaTime.Text.DurationPatternParser.DurationParseBucket.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)">
            <summary>
            Calculates the value from the parsed pieces.
            </summary>
        </member>
        <member name="T:NodaTime.Text.FixedFormatInfoPatternParser`1">
            <summary>
            A pattern parser for a single format info, which caches patterns by text/style.
            </summary>
        </member>
        <member name="T:NodaTime.Text.FormatHelper">
            <summary>
              Provides helper methods for formatting values using pattern strings.
            </summary>
        </member>
        <member name="F:NodaTime.Text.FormatHelper.MaximumPaddingLength">
            <summary>
            The maximum number of characters allowed for padded values.
            </summary>
        </member>
        <member name="F:NodaTime.Text.FormatHelper.MaximumInt64Length">
            <summary>
            Maximum number of digits in a (positive) long.
            </summary>
        </member>
        <member name="M:NodaTime.Text.FormatHelper.Format2DigitsNonNegative(System.Int32,System.Text.StringBuilder)">
            <summary>
            Formats the given value to two digits, left-padding with '0' if necessary.
            It is assumed that the value is in the range [0, 100). This is usually
            used for month, day-of-month, hour, minute, second and year-of-century values.
            </summary>
        </member>
        <member name="M:NodaTime.Text.FormatHelper.Format4DigitsValueFits(System.Int32,System.Text.StringBuilder)">
            <summary>
            Formats the given value to two digits, left-padding with '0' if necessary.
            It is assumed that the value is in the range [-9999, 10000). This is usually
            used for year values. If the value is negative, a '-' character is prepended.
            </summary>
        </member>
        <member name="M:NodaTime.Text.FormatHelper.LeftPad(System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Formats the given value left padded with zeros.
            </summary>
            <remarks>
            Left pads with zeros the value into a field of <paramref name = "length" /> characters. If the value
            is longer than <paramref name = "length" />, the entire value is formatted. If the value is negative,
            it is preceded by "-" but this does not count against the length.
            </remarks>
            <param name="value">The value to format.</param>
            <param name="length">The length to fill.</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
        </member>
        <member name="M:NodaTime.Text.FormatHelper.LeftPadNonNegative(System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Formats the given value left padded with zeros. The value is assumed to be non-negative.
            </summary>
            <remarks>
            Left pads with zeros the value into a field of <paramref name = "length" /> characters. If the value
            is longer than <paramref name = "length" />, the entire value is formatted. If the value is negative,
            it is preceded by "-" but this does not count against the length.
            </remarks>
            <param name="value">The value to format.</param>
            <param name="length">The length to fill.</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
        </member>
        <member name="M:NodaTime.Text.FormatHelper.LeftPadNonNegativeInt64(System.Int64,System.Int32,System.Text.StringBuilder)">
            <summary>
            Formats the given Int64 value left padded with zeros. The value is assumed to be non-negative.
            </summary>
            <remarks>
            Left pads with zeros the value into a field of <paramref name = "length" /> characters. If the value
            is longer than <paramref name = "length" />, the entire value is formatted. If the value is negative,
            it is preceded by "-" but this does not count against the length.
            </remarks>
            <param name="value">The value to format.</param>
            <param name="length">The length to fill.</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
        </member>
        <member name="M:NodaTime.Text.FormatHelper.AppendFraction(System.Int32,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Formats the given value, which is an integer representation of a fraction.
            Note: current usage means this never has to cope with negative numbers.
            </summary>
            <example>
            <c>AppendFraction(1200, 4, 5, builder)</c> will result in "0120" being
            appended to the builder. The value is treated as effectively 0.01200 because
            the scale is 5, but only 4 digits are formatted.
            </example>
            <param name="value">The value to format.</param>
            <param name="length">The length to fill. Must be at most <paramref name="scale"/>.</param>
            <param name="scale">The scale of the value i.e. the number of significant digits is the range of the value. Must be in the range [1, 7].</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
        </member>
        <member name="M:NodaTime.Text.FormatHelper.AppendFractionTruncate(System.Int32,System.Int32,System.Int32,System.Text.StringBuilder)">
            <summary>
            Formats the given value, which is an integer representation of a fraction,
            truncating any right-most zero digits.
            If the entire value is truncated then the preceding decimal separator is also removed.
            Note: current usage means this never has to cope with negative numbers.
            </summary>
            <example>
            <c>AppendFractionTruncate(1200, 4, 5, builder)</c> will result in "001" being
            appended to the builder. The value is treated as effectively 0.01200 because
            the scale is 5; only 4 digits are formatted (leaving "0120") and then the rightmost
            0 digit is truncated.
            </example>
            <param name="value">The value to format.</param>
            <param name="length">The length to fill. Must be at most <paramref name="scale"/>.</param>
            <param name="scale">The scale of the value i.e. the number of significant digits is the range of the value. Must be in the range [1, 7].</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
        </member>
        <member name="M:NodaTime.Text.FormatHelper.FormatInvariant(System.Int64,System.Text.StringBuilder)">
            <summary>
            Formats the given value using the invariant culture, with no truncation or padding.
            </summary>
            <param name="value">The value to format.</param>
            <param name="outputBuffer">The output buffer to add the digits to.</param>
        </member>
        <member name="T:NodaTime.Text.InstantPattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.Instant"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.InstantPattern.General">
            <summary>
            Gets the general pattern, which always uses an invariant culture. The general pattern represents
            an instant as a UTC date/time in ISO-8601 style "uuuu-MM-ddTHH:mm:ss'Z'".
            </summary>
            <value>The general pattern, which always uses an invariant culture.</value>
        </member>
        <member name="P:NodaTime.Text.InstantPattern.ExtendedIso">
            <summary>
            Gets an invariant instant pattern which is ISO-8601 compatible, providing up to 9 decimal places
            of sub-second accuracy. (These digits are omitted when unnecessary.)
            This corresponds to the text pattern "uuuu'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFFF'Z'".
            </summary>
            <value>An invariant instant pattern which is ISO-8601 compatible, providing up to 9 decimal places
            of sub-second accuracy.</value>
        </member>
        <member name="T:NodaTime.Text.InstantPattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.InstantPattern.PatternText">
            <summary>
            Gets the pattern text for this pattern, as supplied on creation.
            </summary>
            <value>The pattern text for this pattern, as supplied on creation.</value>
        </member>
        <member name="P:NodaTime.Text.InstantPattern.TemplateValue">
            <summary>
            Gets the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
            <value>The value used as a template for parsing.</value>
        </member>
        <member name="P:NodaTime.Text.InstantPattern.FormatInfo">
            <summary>
            Gets the localization information used in this pattern.
            </summary>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.Format(NodaTime.Instant)">
            <summary>
            Formats the given instant as text according to the rules of this pattern.
            </summary>
            <param name="value">The instant to format.</param>
            <returns>The instant formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.AppendFormat(NodaTime.Instant,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.Instant)">
            <summary>
            Creates a pattern for the given pattern text and format info.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">The template value to use in the pattern</param>
            <returns>A pattern for parsing and formatting instants.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting instants.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting instants.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting instants.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="formatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.InstantPattern.WithTemplateValue(NodaTime.Instant)">
            <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
            <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="T:NodaTime.Text.InstantPatternParser">
            <summary>
            Pattern parsing support for <see cref="T:NodaTime.Instant" />.
            </summary>
            <remarks>
            Supported standard patterns:
            <list type="bullet">
              <item><description>g: general; the UTC ISO-8601 instant in the style uuuu-MM-ddTHH:mm:ssZ</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:NodaTime.Text.InvalidPatternException">
            <summary>
            Exception thrown to indicate that the format pattern provided for either formatting or parsing is invalid.
            </summary>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.Text.InvalidPatternException.#ctor">
            <summary>
            Creates a new InvalidPatternException with the default FormatException message.
            </summary>
        </member>
        <member name="M:NodaTime.Text.InvalidPatternException.#ctor(System.String)">
            <summary>
            Creates a new InvalidPatternException with the given message.
            </summary>
            <param name="message">A message describing the nature of the failure</param>
        </member>
        <member name="M:NodaTime.Text.InvalidPatternException.#ctor(System.String,System.Object[])">
            <summary>
            Creates a new InvalidPatternException by formatting the given format string with
            the specified parameters, in the current culture.
            </summary>
            <param name="formatString">Format string to use in order to create the final message</param>
            <param name="parameters">Format string parameters</param>
        </member>
        <member name="T:NodaTime.Text.IPartialPattern`1">
            <summary>
            Internal interface supporting partial parsing and formatting. This is used
            when one pattern is embedded within another.
            </summary>
            <typeparam name="T">The type of value to be parsed or formatted.</typeparam>
        </member>
        <member name="M:NodaTime.Text.IPartialPattern`1.ParsePartial(NodaTime.Text.ValueCursor)">
            <summary>
            Parses a value from the current position in the cursor. This will
            not fail if the pattern ends before the cursor does - that's expected
            in most cases.
            </summary>
            <param name="cursor">The cursor to parse from.</param>
            <returns>The result of parsing from the cursor.</returns>
        </member>
        <member name="T:NodaTime.Text.IPattern`1">
            <summary>
            Generic interface supporting parsing and formatting. Parsing always results in a 
            <see cref="T:NodaTime.Text.ParseResult`1"/> which can represent success or failure.
            </summary>
            <remarks>
            Idiomatic text handling in Noda Time involves creating a pattern once and reusing it multiple
            times, rather than specifying the pattern text repeatedly. All patterns are immutable and thread-safe,
            and include the culture used for localization purposes.
            </remarks>
            <typeparam name="T">Type of value to parse or format.</typeparam>
        </member>
        <member name="M:NodaTime.Text.IPattern`1.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.IPattern`1.Format(`0)">
            <summary>
            Formats the given value as text according to the rules of this pattern.
            </summary>
            <param name="value">The value to format.</param>
            <returns>The value formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.IPattern`1.AppendFormat(`0,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="T:NodaTime.Text.LocalDatePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.LocalDate"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.LocalDatePattern.Iso">
            <summary>
            Gets an invariant local date pattern which is ISO-8601 compatible and which round trips values, but doesn't include the calendar system.
            This corresponds to the text pattern "uuuu'-'MM'-'dd".
            </summary>
            <remarks>
            This pattern corresponds to the 'R' standard pattern.
            </remarks>
            <value>An invariant local date pattern which is ISO-8601 compatible.</value>
        </member>
        <member name="P:NodaTime.Text.LocalDatePattern.FullRoundtrip">
            <summary>
            Gets an invariant local date pattern which round trips values including the calendar system.
            This corresponds to the text pattern "uuuu'-'MM'-'dd '('c')'".
            </summary>
            <remarks>
            This pattern corresponds to the 'r' standard pattern.
            </remarks>
            <value>An invariant local date pattern which round trips values including the calendar system.</value>
        </member>
        <member name="T:NodaTime.Text.LocalDatePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDatePattern.UnderlyingPattern">
            <summary>
            Returns the pattern that this object delegates to. Mostly useful to avoid this public class
            implementing an internal interface.
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDatePattern.PatternText">
            <summary>
            Gets the pattern text for this pattern, as supplied on creation.
            </summary>
            <value>The pattern text for this pattern, as supplied on creation.</value>
        </member>
        <member name="P:NodaTime.Text.LocalDatePattern.FormatInfo">
            <summary>
            Returns the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDatePattern.TemplateValue">
            <summary>
            Gets the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
            <value>The value used as a template for parsing.</value>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.Format(NodaTime.LocalDate)">
            <summary>
            Formats the given local date as text according to the rules of this pattern.
            </summary>
            <param name="value">The local date to format.</param>
            <returns>The local date formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.AppendFormat(NodaTime.LocalDate,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.LocalDate)">
            <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalDate)">
            <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture, with a template value of 2000-01-01.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="formatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.WithTemplateValue(NodaTime.LocalDate)">
            <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
            <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDatePattern.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a pattern like this one, but with the template value modified to use
            the specified calendar system.
            </summary>
            <remarks>
            <para>
            Care should be taken in two (relatively rare) scenarios. Although the default template value
            is supported by all Noda Time calendar systems, if a pattern is created with a different
            template value and then this method is called with a calendar system which doesn't support that
            date, an exception will be thrown. Additionally, if the pattern only specifies some date fields,
            it's possible that the new template value will not be suitable for all values.
            </para>
            </remarks>
            <param name="calendar">The calendar system to convert the template value into.</param>
            <returns>A new pattern with a template value in the specified calendar system.</returns>
        </member>
        <member name="T:NodaTime.Text.LocalDatePatternParser">
            <summary>
            Parser for patterns of <see cref="T:NodaTime.LocalDate"/> values.
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalDatePatternParser.TwoDigitYearMax">
            <summary>
            Maximum two-digit-year in the template to treat as the current century.
            (One day we may want to make this configurable, but it feels very low
            priority.)
            </summary>
        </member>
        <member name="T:NodaTime.Text.LocalDatePatternParser.LocalDateParseBucket">
            <summary>
            Bucket to put parsed values in, ready for later result calculation. This type is also used
            by LocalDateTimePattern to store and calculate values.
            </summary>
        </member>
        <member name="M:NodaTime.Text.LocalDatePatternParser.LocalDateParseBucket.CalculateSimpleIsoValue(System.String)">
            <summary>
            Optimized computation for a pattern with an ISO calendar template value,
            and year/month/day fields.
            </summary>
        </member>
        <member name="M:NodaTime.Text.LocalDatePatternParser.LocalDateParseBucket.DetermineYear(NodaTime.Text.Patterns.PatternFields,System.String,System.Type)">
            <summary>
            Work out the year, based on fields of:
            - Year
            - YearOfEra
            - YearTwoDigits (implies YearOfEra)
            - Era
            
            If the year is specified, that trumps everything else - any other fields
            are just used for checking.
            
            If nothing is specified, the year of the template value is used.
            
            If just the era is specified, the year of the template value is used,
            and the specified era is checked against it. (Hopefully no-one will
            expect to get useful information from a format string with era but no year...)
            
            Otherwise, we have the year of era (possibly only two digits) and possibly the
            era. If the era isn't specified, take it from the template value.
            Finally, if we only have two digits, then use either the century of the template
            value or the previous century if the year-of-era is greater than TwoDigitYearMax...
            and if the template value isn't in the first century already.
            
            Phew.
            </summary>
        </member>
        <member name="T:NodaTime.Text.LocalDateTimePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.LocalDateTime"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.GeneralIso">
            <summary>
            Gets an invariant local date/time pattern which is ISO-8601 compatible, down to the second.
            This corresponds to the text pattern "uuuu'-'MM'-'dd'T'HH':'mm':'ss".
            </summary>
            <remarks>
            This pattern corresponds to the 's' standard pattern ("shorter sortable").
            </remarks>
            <value>An invariant local date/time pattern which is ISO-8601 compatible, down to the second.</value>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.ExtendedIso">
            <summary>
            Gets an invariant local date/time pattern which is ISO-8601 compatible, providing up to 9 decimal places
            of sub-second accuracy. (These digits are omitted when unnecessary.)
            This corresponds to the text pattern "uuuu'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFFF".
            </summary>
            <remarks>
            This pattern corresponds to the 'S' standard pattern ("longer sortable").
            </remarks>
            <value>An invariant local date/time pattern which is ISO-8601 compatible, providing up to 9 decimal places
            of sub-second accuracy.</value>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.BclRoundtrip">
            <summary>
            Gets an invariant local date/time pattern which is ISO-8601 compatible, providing up to 7 decimal places
            of sub-second accuracy which are always present (including trailing zeroes). This is compatible with the
            BCL round-trip formatting of <see cref="T:System.DateTime"/> values with a kind of "unspecified".
            This corresponds to the text pattern "uuuu'-'MM'-'dd'T'HH':'mm':'ss'.'fffffff". It does not necessarily
            round-trip all <c>LocalDateTime</c> values as it will lose sub-tick information. Use
            <see cref="P:NodaTime.Text.LocalDateTimePattern.FullRoundtripWithoutCalendar"/>
            </summary>
            <remarks>
            This pattern corresponds to the 'o' and 'O' standard patterns.
            </remarks>
            <value>An invariant local date/time pattern which is ISO-8601 compatible, providing up to 7 decimal places
            of sub-second accuracy which are always present (including trailing zeroes).</value>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.FullRoundtripWithoutCalendar">
            <summary>
            Gets an invariant local date/time pattern which round trips values, but doesn't include the calendar system.
            It provides up to 9 decimal places of sub-second accuracy which are always present (including trailing zeroes).
            This corresponds to the text pattern "uuuu'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffff". It will
            round-trip all <see cref="T:NodaTime.LocalDateTime"/> values if the calendar system of the template value is the same
            as the calendar system of the original value.
            </summary>
            <remarks>
            This pattern corresponds to the 'r' standard pattern.
            </remarks>
            <value>An invariant local date/time pattern which is ISO-8601 compatible, providing up to 7 decimal places
            of sub-second accuracy which are always present (including trailing zeroes).</value>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.FullRoundtrip">
            <summary>
            Gets an invariant local date/time pattern which round trips values including the calendar system.
            This corresponds to the text pattern "uuuu'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffff '('c')'".
            </summary>
            <remarks>
            This pattern corresponds to the 'R' standard pattern.
            </remarks>
            <value>An invariant local date/time pattern which round trips values including the calendar system.</value>
        </member>
        <member name="T:NodaTime.Text.LocalDateTimePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.PatternText">
            <summary>
            Gets the pattern text for this pattern, as supplied on creation.
            </summary>
            <value>The pattern text for this pattern, as supplied on creation.</value>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.FormatInfo">
            <summary>
            Gets the localization information used in this pattern.
            </summary>
            <value>The localization information used in this pattern.</value>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.TemplateValue">
            <summary>
            Get the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
            <value>The value used as a template for parsing.</value>
        </member>
        <member name="P:NodaTime.Text.LocalDateTimePattern.UnderlyingPattern">
            <summary>
            Returns the pattern that this object delegates to. Mostly useful to avoid this public class
            implementing an internal interface.
            </summary>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.Format(NodaTime.LocalDateTime)">
            <summary>
            Formats the given local date/time as text according to the rules of this pattern.
            </summary>
            <param name="value">The local date/time to format.</param>
            <returns>The local date/time formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.AppendFormat(NodaTime.LocalDateTime,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.LocalDateTime)">
            <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalDateTime)">
            <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture, with a template value of midnight on 2000-01-01.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="formatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.WithTemplateValue(NodaTime.LocalDateTime)">
            <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
            <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePattern.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a pattern like this one, but with the template value modified to use
            the specified calendar system.
            </summary>
            <remarks>
            <para>
            Care should be taken in two (relatively rare) scenarios. Although the default template value
            is supported by all Noda Time calendar systems, if a pattern is created with a different
            template value and then this method is called with a calendar system which doesn't support that
            date, an exception will be thrown. Additionally, if the pattern only specifies some date fields,
            it's possible that the new template value will not be suitable for all values.
            </para>
            </remarks>
            <param name="calendar">The calendar system to convert the template value into.</param>
            <returns>A new pattern with a template value in the specified calendar system.</returns>
        </member>
        <member name="T:NodaTime.Text.LocalDateTimePatternParser">
            <summary>
            Parser for patterns of <see cref="T:NodaTime.LocalDateTime"/> values.
            </summary>
        </member>
        <member name="M:NodaTime.Text.LocalDateTimePatternParser.LocalDateTimeParseBucket.CombineBuckets(NodaTime.Text.Patterns.PatternFields,NodaTime.Text.LocalDatePatternParser.LocalDateParseBucket,NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket,System.String)">
            <summary>
            Combines the values in a date bucket with the values in a time bucket.
            </summary>
            <remarks>
            This would normally be the <see cref="M:NodaTime.Text.LocalDateTimePatternParser.LocalDateTimeParseBucket.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)"/> method, but we want
            to be able to use the same logic when parsing an <see cref="T:NodaTime.OffsetDateTime"/>
            and <see cref="T:NodaTime.ZonedDateTime"/>.
            </remarks>
        </member>
        <member name="T:NodaTime.Text.LocalTimePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.LocalTime"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.LocalTimePattern.ExtendedIso">
            <summary>
            Gets an invariant local time pattern which is ISO-8601 compatible, providing up to 9 decimal places.
            (These digits are omitted when unnecessary.)
            This corresponds to the text pattern "HH':'mm':'ss;FFFFFFFFF".
            </summary>
            <remarks>
            This pattern corresponds to the 'o' standard pattern.
            </remarks>
            <value>An invariant local time pattern which is ISO-8601 compatible, providing up to 9 decimal places.</value>
        </member>
        <member name="P:NodaTime.Text.LocalTimePattern.LongExtendedIso">
            <summary>
            Gets an invariant local time pattern which is ISO-8601 compatible, providing exactly 9 decimal places.
            This corresponds to the text pattern "HH':'mm':'ss;fffffffff".
            </summary>
            <remarks>
            This pattern corresponds to the 'O' standard pattern.
            </remarks>
            <value>An invariant local time pattern which is ISO-8601 compatible, providing exactly 9 decimal places.</value>
        </member>
        <member name="P:NodaTime.Text.LocalTimePattern.GeneralIso">
            <summary>
            Gets an invariant local time pattern which is ISO-8601 compatible, with precision of just seconds.
            This corresponds to the text pattern "HH':'mm':'ss".
            </summary>
            <value>An invariant local time pattern which is ISO-8601 compatible, with no sub-second precision.</value>
        </member>
        <member name="T:NodaTime.Text.LocalTimePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalTimePattern.UnderlyingPattern">
            <summary>
            Returns the pattern that this object delegates to. Mostly useful to avoid this public class
            implementing an internal interface.
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalTimePattern.PatternText">
            <summary>
            Gets the pattern text for this pattern, as supplied on creation.
            </summary>
            <value>The pattern text for this pattern, as supplied on creation.</value>
        </member>
        <member name="P:NodaTime.Text.LocalTimePattern.FormatInfo">
            <summary>
            Gets the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.LocalTimePattern.TemplateValue">
            <summary>
            Gets the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
            <value>The value used as a template for parsing.</value>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.Format(NodaTime.LocalTime)">
            <summary>
            Formats the given local time as text according to the rules of this pattern.
            </summary>
            <param name="value">The local time to format.</param>
            <returns>The local time formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.AppendFormat(NodaTime.LocalTime,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.LocalTime)">
            <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.LocalTime)">
            <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture, with a template value of midnight.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="formatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.LocalTimePattern.WithTemplateValue(NodaTime.LocalTime)">
            <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
            <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="T:NodaTime.Text.LocalTimePatternParser">
            <summary>
            Pattern parser for <see cref="T:NodaTime.LocalTime"/> values.
            </summary>
        </member>
        <member name="T:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket">
            <summary>
            Bucket to put parsed values in, ready for later result calculation. This type is also used
            by LocalDateTimePattern to store and calculate values.
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.FractionalSeconds">
            <summary>
            The fractions of a second in nanoseconds, in the range [0, 999999999]
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.Hours24">
            <summary>
            The hours in the range [0, 23].
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.Hours12">
            <summary>
            The hours in the range [1, 12].
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.Minutes">
            <summary>
            The minutes in the range [0, 59].
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.Seconds">
            <summary>
            The seconds in the range [0, 59].
            </summary>
        </member>
        <member name="F:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.AmPm">
            <summary>
            AM (0) or PM (1) - or "take from the template" (2). The latter is used in situations
            where we're parsing but there is no AM or PM designator.
            </summary>
        </member>
        <member name="M:NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)">
            <summary>
            Calculates the value from the parsed pieces.
            </summary>            
        </member>
        <member name="T:NodaTime.Text.OffsetDatePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.OffsetDate"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.OffsetDatePattern.GeneralIso">
            <summary>
            Gets an invariant offset date pattern based on ISO-8601, including offset from UTC.
            </summary>
            <remarks>
            The calendar system is not parsed or formatted as part of this pattern. It corresponds to a custom pattern of
            "uuuu'-'MM'-'ddo&lt;G&gt;". This pattern is available as the "G" standard pattern (even though it is invariant).
            </remarks>
            <value>An invariant offset date pattern based on ISO-8601 (down to the second), including offset from UTC.</value>
        </member>
        <member name="P:NodaTime.Text.OffsetDatePattern.FullRoundtrip">
            <summary>
            Gets an invariant offset date pattern based on ISO-8601
            including offset from UTC and calendar ID.
            </summary>
            <remarks>
            The returned pattern corresponds to a custom pattern of
            "uuuu'-'MM'-'dd'o&lt;G&gt; '('c')'". This will round-trip any value in any calendar,
            and is available as the "r" standard pattern.
            </remarks>
            <value>An invariant offset date pattern based on ISO-8601 (down to the nanosecond)
            including offset from UTC and calendar ID.</value>
        </member>
        <member name="T:NodaTime.Text.OffsetDatePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetDatePattern.PatternText">
            <summary>
            Gets the pattern text for this pattern, as supplied on creation.
            </summary>
            <value>The pattern text for this pattern, as supplied on creation.</value>
        </member>
        <member name="P:NodaTime.Text.OffsetDatePattern.FormatInfo">
            <summary>
            Gets the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetDatePattern.TemplateValue">
            <summary>
            Gets the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
            <value>The value used as a template for parsing.</value>
        </member>
        <member name="M:NodaTime.Text.OffsetDatePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDatePattern.Format(NodaTime.OffsetDate)">
            <summary>
            Formats the given offset date as text according to the rules of this pattern.
            </summary>
            <param name="value">The offset date to format.</param>
            <returns>The offset date formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDatePattern.AppendFormat(NodaTime.OffsetDate,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDatePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.OffsetDate)">
            <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting offset dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetDatePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.OffsetDate)">
            <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetDatePattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture, using the default
            template value of midnight January 1st 2000 at an offset of 0.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetDatePattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current culture, using the default
            template value of midnight January 1st 2000 at an offset of 0.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local dates.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetDatePattern.WithPatternText(System.String)">
            <summary>
            Creates a pattern for the same original localization information as this pattern, but with the specified
            pattern text.
            </summary>
            <param name="patternText">The pattern text to use in the new pattern.</param>
            <returns>A new pattern with the given pattern text.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDatePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="formatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDatePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDatePattern.WithTemplateValue(NodaTime.OffsetDate)">
            <summary>
            Creates a pattern for the same original pattern text and culture as this pattern, but with
            the specified template value.
            </summary>
            <param name="newTemplateValue">The template value to use in the new pattern.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDatePattern.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a pattern like this one, but with the template value modified to use
            the specified calendar system.
            </summary>
            <remarks>
            <para>
            Care should be taken in two (relatively rare) scenarios. Although the default template value
            is supported by all Noda Time calendar systems, if a pattern is created with a different
            template value and then this method is called with a calendar system which doesn't support that
            date, an exception will be thrown. Additionally, if the pattern only specifies some date fields,
            it's possible that the new template value will not be suitable for all values.
            </para>
            </remarks>
            <param name="calendar">The calendar system to convert the template value into.</param>
            <returns>A new pattern with a template value in the specified calendar system.</returns>
        </member>
        <member name="T:NodaTime.Text.OffsetDateTimePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.OffsetDateTime"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.GeneralIso">
            <summary>
            Gets an invariant offset date/time pattern based on ISO-8601 (down to the second), including offset from UTC.
            </summary>
            <remarks>
            The calendar system is not parsed or formatted as part of this pattern. It corresponds to a custom pattern of
            "uuuu'-'MM'-'dd'T'HH':'mm':'sso&lt;G&gt;". This pattern is available as the "G"
            standard pattern (even though it is invariant).
            </remarks>
            <value>An invariant offset date/time pattern based on ISO-8601 (down to the second), including offset from UTC.</value>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.ExtendedIso">
            <summary>
            Gets an invariant offset date/time pattern based on ISO-8601 (down to the nanosecond), including offset from UTC.
            </summary>
            <remarks>
            The calendar system is not parsed or formatted as part of this pattern. It corresponds to a custom pattern of
            "uuuu'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFFFo&lt;G&gt;". This will round-trip any values
            in the ISO calendar, and is available as the "o" standard pattern.
            </remarks>
            <value>An invariant offset date/time pattern based on ISO-8601 (down to the nanosecond), including offset from UTC.</value>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.Rfc3339">
            <summary>
            Gets an invariant offset date/time pattern based on RFC 3339 (down to the nanosecond), including offset from UTC
            as hours and minutes only.
            </summary>
            <remarks>
            The minutes part of the offset is always included, but any sub-minute component
            of the offset is lost. An offset of zero is formatted as 'Z', but all of 'Z', '+00:00' and '-00:00' are parsed
            the same way. The RFC 3339 meaning of '-00:00' is not supported by Noda Time.
            Note that parsing is case-sensitive (so 'T' and 'Z' must be upper case).
            The calendar system is not parsed or formatted as part of this pattern. It corresponds to a custom pattern of
            "uuuu'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFFFo&lt;Z+HH:mm&gt;".
            </remarks>
            <value>An invariant offset date/time pattern based on RFC 3339 (down to the nanosecond), including offset from UTC
            as hours and minutes only.</value>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.FullRoundtrip">
            <summary>
            Gets an invariant offset date/time pattern based on ISO-8601 (down to the nanosecond)
            including offset from UTC and calendar ID.
            </summary>
            <remarks>
            The returned pattern corresponds to a custom pattern of
            "uuuu'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFFFo&lt;G&gt; '('c')'". This will round-trip any value in any calendar,
            and is available as the "r" standard pattern.
            </remarks>
            <value>An invariant offset date/time pattern based on ISO-8601 (down to the nanosecond)
            including offset from UTC and calendar ID.</value>
        </member>
        <member name="T:NodaTime.Text.OffsetDateTimePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.PatternText">
            <summary>
            Gets the pattern text for this pattern, as supplied on creation.
            </summary>
            <value>The pattern text for this pattern, as supplied on creation.</value>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.FormatInfo">
            <summary>
            Gets the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetDateTimePattern.TemplateValue">
            <summary>
            Gets the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
            <value>The value used as a template for parsing.</value>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.Format(NodaTime.OffsetDateTime)">
            <summary>
            Formats the given offset date/time as text according to the rules of this pattern.
            </summary>
            <param name="value">The offset date/time to format.</param>
            <returns>The offset date/time formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.AppendFormat(NodaTime.OffsetDateTime,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.OffsetDateTime)">
            <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting offset date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.OffsetDateTime)">
            <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture, using the default
            template value of midnight January 1st 2000 at an offset of 0.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current culture, using the default
            template value of midnight January 1st 2000 at an offset of 0.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.WithPatternText(System.String)">
            <summary>
            Creates a pattern for the same original localization information as this pattern, but with the specified
            pattern text.
            </summary>
            <param name="patternText">The pattern text to use in the new pattern.</param>
            <returns>A new pattern with the given pattern text.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="formatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.WithTemplateValue(NodaTime.OffsetDateTime)">
            <summary>
            Creates a pattern for the same original pattern text and culture as this pattern, but with
            the specified template value.
            </summary>
            <param name="newTemplateValue">The template value to use in the new pattern.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetDateTimePattern.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a pattern like this one, but with the template value modified to use
            the specified calendar system.
            </summary>
            <remarks>
            <para>
            Care should be taken in two (relatively rare) scenarios. Although the default template value
            is supported by all Noda Time calendar systems, if a pattern is created with a different
            template value and then this method is called with a calendar system which doesn't support that
            date, an exception will be thrown. Additionally, if the pattern only specifies some date fields,
            it's possible that the new template value will not be suitable for all values.
            </para>
            </remarks>
            <param name="calendar">The calendar system to convert the template value into.</param>
            <returns>A new pattern with a template value in the specified calendar system.</returns>
        </member>
        <member name="T:NodaTime.Text.OffsetPattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.Offset"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.OffsetPattern.GeneralInvariant">
            <summary>
            The "general" offset pattern (e.g. +HH, +HH:mm, +HH:mm:ss, +HH:mm:ss.fff) for the invariant culture.
            </summary>
            <value>The "general" offset pattern for the invariant culture.</value>
        </member>
        <member name="P:NodaTime.Text.OffsetPattern.GeneralInvariantWithZ">
            <summary>
            The "general" offset pattern (e.g. +HH, +HH:mm, +HH:mm:ss, +HH:mm:ss.fff) for the invariant culture,
            but producing (and allowing) Z as a value for a zero offset.
            </summary>
            <value>The "general" offset pattern for the invariant culture but producing (and allowing) Z as a value for a zero offset.</value>
        </member>
        <member name="P:NodaTime.Text.OffsetPattern.PatternText">
            <summary>
            Gets the pattern text for this pattern, as supplied on creation.
            </summary>
            <value>The pattern text for this pattern, as supplied on creation.</value>
        </member>
        <member name="P:NodaTime.Text.OffsetPattern.UnderlyingPattern">
            <summary>
            Returns the pattern that this object delegates to. Mostly useful to avoid this public class
            implementing an internal interface.
            </summary>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.Format(NodaTime.Offset)">
            <summary>
            Formats the given offset as text according to the rules of this pattern.
            </summary>
            <param name="value">The offset to format.</param>
            <returns>The offset formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.AppendFormat(NodaTime.Offset,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the given pattern text and format info.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">Localization information</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting offsets.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetPattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetPatternParser.HasZeroSeconds(NodaTime.Offset)">
            <summary>
            Returns true if the offset is representable just in hours and minutes (no seconds).
            </summary>
        </member>
        <member name="M:NodaTime.Text.OffsetPatternParser.HasZeroSecondsAndMinutes(NodaTime.Offset)">
            <summary>
            Returns true if the offset is representable just in hours (no minutes or seconds).
            </summary>
        </member>
        <member name="T:NodaTime.Text.OffsetPatternParser.ZPrefixPattern">
            <summary>
            Pattern which optionally delegates to another, but both parses and formats Offset.Zero as "Z".
            </summary>
        </member>
        <member name="T:NodaTime.Text.OffsetPatternParser.OffsetParseBucket">
            <summary>
            Provides a container for the interim parsed pieces of an <see cref="T:NodaTime.Offset" /> value.
            </summary>
        </member>
        <member name="F:NodaTime.Text.OffsetPatternParser.OffsetParseBucket.Hours">
            <summary>
            The hours in the range [0, 23].
            </summary>
        </member>
        <member name="F:NodaTime.Text.OffsetPatternParser.OffsetParseBucket.Minutes">
            <summary>
            The minutes in the range [0, 59].
            </summary>
        </member>
        <member name="F:NodaTime.Text.OffsetPatternParser.OffsetParseBucket.Seconds">
            <summary>
            The seconds in the range [0, 59].
            </summary>
        </member>
        <member name="F:NodaTime.Text.OffsetPatternParser.OffsetParseBucket.IsNegative">
            <summary>
            Gets a value indicating whether this instance is negative.
            </summary>
            <value>
            <c>true</c> if this instance is negative; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="M:NodaTime.Text.OffsetPatternParser.OffsetParseBucket.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)">
            <summary>
            Calculates the value from the parsed pieces.
            </summary>
        </member>
        <member name="T:NodaTime.Text.OffsetTimePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.OffsetTime"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.OffsetTimePattern.GeneralIso">
            <summary>
            Gets an invariant offset time pattern based on ISO-8601 (down to the second), including offset from UTC.
            </summary>
            <remarks>
            This corresponds to a custom pattern of "HH':'mm':'sso&lt;G&gt;". It is available as the "G"
            standard pattern (even though it is invariant).
            </remarks>
            <value>An invariant offset time pattern based on ISO-8601 (down to the second), including offset from UTC.</value>
        </member>
        <member name="P:NodaTime.Text.OffsetTimePattern.ExtendedIso">
            <summary>
            Gets an invariant offset time pattern based on ISO-8601 (down to the nanosecond), including offset from UTC.
            </summary>
            <remarks>
            This corresponds to a custom pattern of "HH':'mm':'ss;FFFFFFFFFo&lt;G&gt;".
            This will round-trip all values, and is available as the "o" standard pattern.
            </remarks>
            <value>An invariant offset time pattern based on ISO-8601 (down to the nanosecond), including offset from UTC.</value>
        </member>
        <member name="P:NodaTime.Text.OffsetTimePattern.Rfc3339">
            <summary>
            Gets an invariant offset time pattern based on RFC 3339 (down to the nanosecond), including offset from UTC
            as hours and minutes only.
            </summary>
            <remarks>
            The minutes part of the offset is always included, but any sub-minute component
            of the offset is lost. An offset of zero is formatted as 'Z', but all of 'Z', '+00:00' and '-00:00' are parsed
            the same way. The RFC 3339 meaning of '-00:00' is not supported by Noda Time.
            Note that parsing is case-sensitive (so 'T' and 'Z' must be upper case).
            This pattern corresponds to a custom pattern of
            "HH':'mm':'ss;FFFFFFFFFo&lt;Z+HH:mm&gt;".
            </remarks>
            <value>An invariant offset time pattern based on RFC 3339 (down to the nanosecond), including offset from UTC
            as hours and minutes only.</value>
        </member>
        <member name="T:NodaTime.Text.OffsetTimePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetTimePattern.PatternText">
            <summary>
            Gets the pattern text for this pattern, as supplied on creation.
            </summary>
            <value>The pattern text for this pattern, as supplied on creation.</value>
        </member>
        <member name="P:NodaTime.Text.OffsetTimePattern.FormatInfo">
            <summary>
            Gets the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.OffsetTimePattern.TemplateValue">
            <summary>
            Gets the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
            <value>The value used as a template for parsing.</value>
        </member>
        <member name="M:NodaTime.Text.OffsetTimePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetTimePattern.Format(NodaTime.OffsetTime)">
            <summary>
            Formats the given offset time as text according to the rules of this pattern.
            </summary>
            <param name="value">The offset time to format.</param>
            <returns>The offset time formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetTimePattern.AppendFormat(NodaTime.OffsetTime,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.OffsetTime)">
            <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting offset times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.OffsetTime)">
            <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetTimePattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture, using the default
            template value of midnight January 1st 2000 at an offset of 0.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetTimePattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current culture, using the default
            template value of midnight January 1st 2000 at an offset of 0.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting local times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.OffsetTimePattern.WithPatternText(System.String)">
            <summary>
            Creates a pattern for the same original localization information as this pattern, but with the specified
            pattern text.
            </summary>
            <param name="patternText">The pattern text to use in the new pattern.</param>
            <returns>A new pattern with the given pattern text.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="formatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetTimePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.OffsetTimePattern.WithTemplateValue(NodaTime.OffsetTime)">
            <summary>
            Creates a pattern for the same original pattern text and culture as this pattern, but with
            the specified template value.
            </summary>
            <param name="newTemplateValue">The template value to use in the new pattern.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="T:NodaTime.Text.ParseBucket`1">
            <summary>
            Base class for "buckets" of parse data - as field values are parsed, they are stored in a bucket,
            then the final value is calculated at the end.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ParseBucket`1.CalculateValue(NodaTime.Text.Patterns.PatternFields,System.String)">
            <summary>
            Performs the final conversion from fields to a value. The parse can still fail here, if there
            are incompatible field values.
            </summary>
            <param name="usedFields">Indicates which fields were part of the original text pattern.</param>
            <param name="value">Complete value being parsed</param>
        </member>
        <member name="T:NodaTime.Text.ParseResult`1">
            <summary>
            The result of a parse operation.
            </summary>
            <typeparam name="T">The type which was parsed, such as a <see cref="T:NodaTime.LocalDateTime"/>.</typeparam>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.Text.ParseResult`1.Value">
            <summary>
            Gets the value from the parse operation if it was successful, or throws an exception indicating the parse failure
            otherwise.
            </summary>
            <remarks>
            This method is exactly equivalent to calling the <see cref="M:NodaTime.Text.ParseResult`1.GetValueOrThrow"/> method, but is terser if the code is
            already clear that it will throw if the parse failed.
            </remarks>
            <value>The result of the parsing operation if it was successful.</value>
        </member>
        <member name="P:NodaTime.Text.ParseResult`1.Exception">
            <summary>
            Gets an exception indicating the cause of the parse failure.
            </summary>
            <remarks>This property is typically used to wrap parse failures in higher level exceptions.</remarks>
            <value>The exception indicating the cause of the parse failure.</value>
            <exception cref="T:System.InvalidOperationException">The parse operation succeeded.</exception>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.GetValueOrThrow">
            <summary>
            Gets the value from the parse operation if it was successful, or throws an exception indicating the parse failure
            otherwise.
            </summary>
            <remarks>
            This method is exactly equivalent to fetching the <see cref="P:NodaTime.Text.ParseResult`1.Value"/> property, but more explicit in terms of throwing
            an exception on failure.
            </remarks>
            <returns>The result of the parsing operation if it was successful.</returns>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.TryGetValue(`0,`0@)">
            <summary>
            Returns the success value, and sets the out parameter to either
            the specified failure value of T or the successful parse result value.
            </summary>
            <param name="failureValue">The "default" value to set in <paramref name="result"/> if parsing failed.</param>
            <param name="result">The parameter to store the parsed value in on success.</param>
            <returns>True if this parse result was successful, or false otherwise.</returns>
        </member>
        <member name="P:NodaTime.Text.ParseResult`1.Success">
            <summary>
            Indicates whether the parse operation was successful.
            </summary>
            <remarks>
            This returns True if and only if fetching the value with the <see cref="P:NodaTime.Text.ParseResult`1.Value"/> property will return with no exception.
            </remarks>
            <value>true if the parse operation was successful; otherwise false.</value>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.Convert``1(System.Func{`0,``0})">
            <summary>
            Converts this result to a new target type, either by executing the given projection
            for a success result, or propagating the exception provider for failure.
            </summary>
            <typeparam name="TTarget">The target type of the conversion.</typeparam>
            <param name="projection">The projection to apply for the value of this result,
            if it's a success result.</param>
            <returns>A ParseResult for the target type, either with a value obtained by applying the specified
            projection to the value in this result, or with the same error as this result.</returns>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.ConvertError``1">
            <summary>
            Converts this result to a new target type by propagating the exception provider.
            This parse result must already be an error result.
            </summary>
            <returns>A ParseResult for the target type, with the same error as this result.</returns>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.ForValue(`0)">
            <summary>
            Produces a ParseResult which represents a successful parse operation.
            </summary>
            <remarks>When T is a reference type, <paramref name="value"/> should not be null,
            but this isn't currently checked.</remarks>
            <param name="value">The successfully parsed value.</param>
            <returns>A ParseResult representing a successful parsing operation.</returns>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.ForException(System.Func{System.Exception})">
            <summary>
            Produces a ParseResult which represents a failed parsing operation.
            </summary>
            <remarks>This method accepts a delegate rather than the exception itself, as creating an
            exception can be relatively slow: if the client doesn't need the actual exception, just the information
            that the parse failed, there's no point in creating the exception.</remarks>
            <param name="exceptionProvider">A delegate that produces the exception representing the error that
            caused the parse to fail.</param>
            <returns>A ParseResult representing a failed parsing operation.</returns>
        </member>
        <member name="F:NodaTime.Text.ParseResult`1.FormatOnlyPattern">
            <summary>
            This isn't really an issue with the value so much as the pattern... but the result is the same.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.InconsistentValues(System.String,System.Char,System.Char,System.Type)">
            <summary>
            Two fields (e.g. "hour of day" and "hour of half day") were mutually inconsistent.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.InconsistentMonthValues(System.String)">
            <summary>
            The month of year is inconsistent between the text and numeric specifications.
            We can't use InconsistentValues for this as the pattern character is the same in both cases.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.InconsistentDayOfWeekTextValue(System.String)">
            <summary>
            The day of month is inconsistent with the day of week value.
            We can't use InconsistentValues for this as the pattern character is the same in both cases.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ParseResult`1.ExpectedEndOfString(NodaTime.Text.ValueCursor)">
            <summary>
            We'd expected to get to the end of the string now, but we haven't.
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.DatePatternHelper">
            <summary>
            Common methods used when parsing dates - these are used from both LocalDateTimePatternParser
            and LocalDatePatternParser.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateYearOfEraHandler``2(System.Func{``0,System.Int32},System.Action{``1,System.Int32})">
            <summary>
            Creates a character handler for the year-of-era specifier (y).
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateMonthOfYearHandler``2(System.Func{``0,System.Int32},System.Action{``1,System.Int32},System.Action{``1,System.Int32})">
            <summary>
            Creates a character handler for the month-of-year specifier (M).
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateDayHandler``2(System.Func{``0,System.Int32},System.Func{``0,System.Int32},System.Action{``1,System.Int32},System.Action{``1,System.Int32})">
            <summary>
            Creates a character handler for the day specifier (d).
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateEraHandler``2(System.Func{``0,NodaTime.Calendars.Era},System.Func{``1,NodaTime.Text.LocalDatePatternParser.LocalDateParseBucket})">
            <summary>
            Creates a character handler for the era specifier (g).
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.DatePatternHelper.CreateCalendarHandler``2(System.Func{``0,NodaTime.CalendarSystem},System.Action{``1,NodaTime.CalendarSystem})">
            <summary>
            Creates a character handler for the calendar specifier (c).
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.IPatternParser`1">
            <summary>
            Internal interface used by FixedFormatInfoPatternParser. Unfortunately
            even though this is internal, implementations must either use public methods
            or explicit interface implementation.
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.PatternBclSupport`1">
            <summary>
            Class providing simple support for the various Parse/TryParse/ParseExact/TryParseExact/Format overloads 
            provided by individual types.
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.PatternCursor">
            <summary>
            Extends <see cref="T:NodaTime.Text.TextCursor"/> to simplify parsing patterns such as "uuuu-MM-dd".
            </summary>
        </member>
        <member name="F:NodaTime.Text.Patterns.PatternCursor.EmbeddedPatternStart">
            <summary>
            The character signifying the start of an embedded pattern.
            </summary>
        </member>
        <member name="F:NodaTime.Text.Patterns.PatternCursor.EmbeddedPatternEnd">
            <summary>
            The character signifying the end of an embedded pattern.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.PatternCursor.GetQuotedString(System.Char)">
            <summary>
            Gets the quoted string.
            </summary>
            <remarks>The cursor is left positioned at the end of the quoted region.</remarks>
            <param name="closeQuote">The close quote character to match for the end of the quoted string.</param>
            <returns>The quoted string sans open and close quotes. This can be an empty string but will not be null.</returns>
        </member>
        <member name="M:NodaTime.Text.Patterns.PatternCursor.GetRepeatCount(System.Int32)">
            <summary>
            Gets the pattern repeat count. The cursor is left on the final character of the
            repeated sequence.
            </summary>
            <param name="maximumCount">The maximum number of repetitions allowed.</param>
            <returns>The repetition count which is always at least <c>1</c>.</returns>
        </member>
        <member name="M:NodaTime.Text.Patterns.PatternCursor.GetEmbeddedPattern">
            <summary>
            Returns a string containing the embedded pattern within this one.
            </summary>
            <remarks>
            <para>
            The cursor is expected to be positioned immediately before the <see cref="F:NodaTime.Text.Patterns.PatternCursor.EmbeddedPatternStart"/> character (<c>&lt;</c>),
            and on success the cursor will be positioned on the <see cref="F:NodaTime.Text.Patterns.PatternCursor.EmbeddedPatternEnd" /> character (<c>&gt;</c>).
            </para>
            <para>Quote characters (' and ") and escaped characters (escaped with a backslash) are handled
            but not unescaped: the resulting pattern should be ready for parsing as normal. It is assumed that the
            embedded pattern will itself handle embedded patterns, so if the input is on the first <c>&lt;</c>
            of <c>"before &lt;outer1 &lt;inner&gt; outer2&gt; after"</c>
            this method will return <c>"outer1 &lt;inner&gt; outer2"</c> and the cursor will be positioned
            on the final <c>&gt;</c> afterwards.
            </para>
            </remarks>
            <returns>The embedded pattern, not including the start/end pattern characters.</returns>
        </member>
        <member name="T:NodaTime.Text.Patterns.PatternFields">
            <summary>
            Enum representing the fields available within patterns. This single enum is shared
            by all parser types for simplicity, although most fields aren't used by most parsers.
            Pattern fields don't necessarily have corresponding duration or date/time fields,
            due to concepts such as "sign".
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.PatternFieldsExtensions">
            <summary>
            Extension methods on PatternFields; nothing PatternFields-specific here, but we
            can't write this generically due to limitations in C#. (See Unconstrained Melody for details...)
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.PatternFieldsExtensions.HasAny(NodaTime.Text.Patterns.PatternFields,NodaTime.Text.Patterns.PatternFields)">
            <summary>
            Returns true if the given set of fields contains any of the target fields.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.PatternFieldsExtensions.HasAll(NodaTime.Text.Patterns.PatternFields,NodaTime.Text.Patterns.PatternFields)">
            <summary>
            Returns true if the given set of fields contains all of the target fields.
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.SteppedPatternBuilder`2">
            <summary>
            Builder for a pattern which implements parsing and formatting as a sequence of steps applied
            in turn.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.CreateSampleBucket">
            <summary>
            Calls the bucket provider and returns a sample bucket. This means that any values
            normally propagated via the bucket can also be used when building the pattern.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.SetFormatOnly">
            <summary>
            Sets this pattern to only be capable of formatting; any attempt to parse using the
            built pattern will fail immediately.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.ParseCustomPattern(System.String,System.Collections.Generic.Dictionary{System.Char,NodaTime.Text.CharacterHandler{`0,`1}})">
            <summary>
            Performs common parsing operations: start with a parse action to move the
            value cursor onto the first character, then call a character handler for each
            character in the pattern to build up the steps. If any handler fails,
            that failure is returned - otherwise the return value is null.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.ValidateUsedFields">
            <summary>
            Validates the combination of fields used.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.Build(`0)">
            <summary>
            Returns a built pattern. This is mostly to keep the API for the builder separate from that of the pattern,
            and for thread safety (publishing a new object, thus leading to a memory barrier).
            Note that this builder *must not* be used after the result has been built.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddField(NodaTime.Text.Patterns.PatternFields,System.Char)">
            <summary>
            Registers that a pattern field has been used in this pattern, and throws a suitable error
            result if it's already been used.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddParseInt64ValueAction(System.Int32,System.Int32,System.Char,System.Int64,System.Int64,System.Action{`1,System.Int64})">
            <summary>
            Equivalent of <see cref="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddParseValueAction(System.Int32,System.Int32,System.Char,System.Int32,System.Int32,System.Action{`1,System.Int32})"/> but for 64-bit integers. Currently only
            positive values are supported.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddLiteral(System.String,System.Func{NodaTime.Text.ValueCursor,NodaTime.Text.ParseResult{`0}})">
            <summary>
            Adds text which must be matched exactly when parsing, and appended directly when formatting.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.HandlePercent(NodaTime.Text.Patterns.PatternCursor,NodaTime.Text.Patterns.SteppedPatternBuilder{`0,`1})">
            <summary>
            Handle a leading "%" which acts as a pseudo-escape - it's mostly used to allow format strings such as "%H" to mean
            "use a custom format string consisting of H instead of a standard pattern H".
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.HandlePaddedField(System.Int32,NodaTime.Text.Patterns.PatternFields,System.Int32,System.Int32,System.Func{`0,System.Int32},System.Action{`1,System.Int32})">
            <summary>
            Returns a handler for a zero-padded purely-numeric field specifier, such as "seconds", "minutes", "24-hour", "12-hour" etc.
            </summary>
            <param name="maxCount">Maximum permissible count (usually two)</param>
            <param name="field">Field to remember that we've seen</param>
            <param name="minValue">Minimum valid value for the field (inclusive)</param>
            <param name="maxValue">Maximum value value for the field (inclusive)</param>
            <param name="getter">Delegate to retrieve the field value when formatting</param>
            <param name="setter">Delegate to set the field value into a bucket when parsing</param>
            <returns>The pattern parsing failure, or null on success.</returns>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddLiteral(System.Char,System.Func{NodaTime.Text.ValueCursor,System.Char,NodaTime.Text.ParseResult{`0}})">
            <summary>
            Adds a character which must be matched exactly when parsing, and appended directly when formatting.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddParseLongestTextAction(System.Char,System.Action{`1,System.Int32},System.Globalization.CompareInfo,System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            Adds parse actions for a list of strings, such as days of the week or month names.
            The parsing is performed case-insensitively. All candidates are tested, and only the longest
            match is used.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddParseLongestTextAction(System.Char,System.Action{`1,System.Int32},System.Globalization.CompareInfo,System.Collections.Generic.IReadOnlyList{System.String},System.Collections.Generic.IReadOnlyList{System.String})">
            <summary>
            Adds parse actions for two list of strings, such as non-genitive and genitive month names.
            The parsing is performed case-insensitively. All candidates are tested, and only the longest
            match is used.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.FindLongestMatch(System.Globalization.CompareInfo,NodaTime.Text.ValueCursor,System.Collections.Generic.IReadOnlyList{System.String},System.Int32@,System.Int32@)">
            <summary>
            Find the longest match from a given set of candidate strings, updating the index/length of the best value
            accordingly.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddRequiredSign(System.Action{`1,System.Boolean},System.Func{`0,System.Boolean})">
            <summary>
            Adds parse and format actions for a mandatory positive/negative sign.
            </summary>
            <param name="signSetter">Action to take when to set the given sign within the bucket</param>
            <param name="nonNegativePredicate">Predicate to detect whether the value being formatted is non-negative</param>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddNegativeOnlySign(System.Action{`1,System.Boolean},System.Func{`0,System.Boolean})">
            <summary>
            Adds parse and format actions for an "negative only" sign.
            </summary>
            <param name="signSetter">Action to take when to set the given sign within the bucket</param>
            <param name="nonNegativePredicate">Predicate to detect whether the value being formatted is non-negative</param>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddFormatLeftPad(System.Int32,System.Func{`0,System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Adds an action to pad a selected value to a given minimum length.
            </summary>
            <param name="count">The minimum length to pad to</param>
            <param name="selector">The selector function to apply to obtain a value to format</param>
            <param name="assumeNonNegative">Whether it is safe to assume the value will be non-negative</param>
            <param name="assumeFitsInCount">Whether it is safe to assume the value will not exceed the specified length</param>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddEmbeddedLocalPartial(NodaTime.Text.Patterns.PatternCursor,System.Func{`1,NodaTime.Text.LocalDatePatternParser.LocalDateParseBucket},System.Func{`1,NodaTime.Text.LocalTimePatternParser.LocalTimeParseBucket},System.Func{`0,NodaTime.LocalDate},System.Func{`0,NodaTime.LocalTime},System.Func{`0,NodaTime.LocalDateTime})">
            <summary>
            Handles date, time and date/time embedded patterns. 
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.SteppedPatternBuilder`2.AddEmbeddedPattern``1(NodaTime.Text.IPartialPattern{``0},System.Action{`1,``0},System.Func{`0,``0})">
            <summary>
            Adds parsing/formatting of an embedded pattern, e.g. an offset within a ZonedDateTime/OffsetDateTime.
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.SteppedPatternBuilder`2.IPostPatternParseFormatAction">
            <summary>
            Hack to handle genitive month names - we only know what we need to do *after* we've parsed the whole pattern.
            </summary>
        </member>
        <member name="T:NodaTime.Text.Patterns.TimePatternHelper">
            <summary>
            Common methods used when parsing dates - these are used from LocalDateTimePatternParser,
            OffsetPatternParser and LocalTimePatternParser.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.TimePatternHelper.CreatePeriodHandler``2(System.Int32,System.Func{``0,System.Int32},System.Action{``1,System.Int32})">
            <summary>
            Creates a character handler for a dot (period). This is *not* culture sensitive - it is
            always treated as a literal, but with the additional behaviour that if it's followed by an 'F' pattern,
            that makes the period optional.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.TimePatternHelper.CreateCommaDotHandler``2(System.Int32,System.Func{``0,System.Int32},System.Action{``1,System.Int32})">
            <summary>
            Creates a character handler for a dot (period) or comma, which have the same meaning.
            Formatting always uses a dot, but parsing will allow a comma instead, to conform with
            ISO-8601. This is *not* culture sensitive.
            </summary>
        </member>
        <member name="M:NodaTime.Text.Patterns.TimePatternHelper.CreateFractionHandler``2(System.Int32,System.Func{``0,System.Int32},System.Action{``1,System.Int32})">
            <summary>
            Creates a character handler to handle the "fraction of a second" specifier (f or F).
            </summary>
        </member>
        <member name="T:NodaTime.Text.PeriodPattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.Period"/> values.
            </summary>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.Text.PeriodPattern.Roundtrip">
            <summary>
            Pattern which uses the normal ISO format for all the supported ISO
            fields, but extends the time part with "s" for milliseconds, "t" for ticks and "n" for nanoseconds.
            No normalization is carried out, and a period may contain weeks as well as years, months and days.
            Each element may also be negative, independently of other elements. This pattern round-trips its
            values: a parse/format cycle will produce an identical period, including units.
            </summary>
            <value>
            Pattern which uses the normal ISO format for all the supported ISO
            fields, but extends the time part with "s" for milliseconds, "t" for ticks and "n" for nanoseconds.
            </value>
        </member>
        <member name="P:NodaTime.Text.PeriodPattern.NormalizingIso">
            <summary>
            A "normalizing" pattern which abides by the ISO-8601 duration format as far as possible.
            Weeks are added to the number of days (after multiplying by 7). Time units are normalized
            (extending into days where necessary), and fractions of seconds are represented within the
            seconds part. Unlike ISO-8601, which pattern allows for negative values within a period.
            </summary>
            <remarks>
            Note that normalizing the period when formatting will cause an <see cref="T:System.OverflowException"/>
            if the period contains more than <see cref="F:System.Int64.MaxValue"/> ticks when the
            combined weeks/days/time portions are considered. Such a period could never
            be useful anyway, however.
            </remarks>
            <value>A "normalizing" pattern which abides by the ISO-8601 duration format as far as possible.</value>
        </member>
        <member name="M:NodaTime.Text.PeriodPattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.PeriodPattern.Format(NodaTime.Period)">
            <summary>
            Formats the given period as text according to the rules of this pattern.
            </summary>
            <param name="value">The period to format.</param>
            <returns>The period formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.PeriodPattern.AppendFormat(NodaTime.Period,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="T:NodaTime.Text.TextCursor">
            <summary>
            Provides a cursor over text being parsed. None of the methods in this class throw exceptions (unless
            there is a bug in Noda Time, in which case an exception is appropriate) and none of the methods
            have ref parameters indicating failures, unlike subclasses. This class is used as the basis for both
            value and pattern parsing, so can make no judgement about what's wrong (i.e. it wouldn't know what
            type of failure to indicate). Instead, methods return Boolean values to indicate success or failure.
            </summary>
        </member>
        <member name="P:NodaTime.Text.TextCursor.Length">
            <summary>
            Gets the length of the string being parsed.
            </summary>
        </member>
        <member name="P:NodaTime.Text.TextCursor.Value">
            <summary>
            Gets the string being parsed.
            </summary>
        </member>
        <member name="F:NodaTime.Text.TextCursor.Nul">
            <summary>
            A nul character. This character is not allowed in any parsable string and is used to
            indicate that the current character is not set.
            </summary>
        </member>
        <member name="M:NodaTime.Text.TextCursor.#ctor(System.String)">
            <summary>
            Initializes a new instance to parse the given value.
            </summary>
        </member>
        <member name="P:NodaTime.Text.TextCursor.Current">
            <summary>
            Gets the current character.
            </summary>
        </member>
        <member name="P:NodaTime.Text.TextCursor.HasMoreCharacters">
            <summary>
            Gets a value indicating whether this instance has more characters.
            </summary>
            <value>
            <c>true</c> if this instance has more characters; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:NodaTime.Text.TextCursor.Index">
            <summary>
            Gets the current index into the string being parsed.
            </summary>
        </member>
        <member name="P:NodaTime.Text.TextCursor.Remainder">
            <summary>
            Gets the remainder the string that has not been parsed yet.
            </summary>
        </member>
        <member name="M:NodaTime.Text.TextCursor.ToString">
            <summary>
              Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
              A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:NodaTime.Text.TextCursor.PeekNext">
            <summary>
            Returns the next character if there is one or <see cref="F:NodaTime.Text.TextCursor.Nul" /> if there isn't.
            </summary>
            <returns></returns>
        </member>
        <member name="M:NodaTime.Text.TextCursor.Move(System.Int32)">
            <summary>
            Moves the specified target index. If the new index is out of range of the valid indices
            for this string then the index is set to the beginning or the end of the string whichever
            is nearest the requested index.
            </summary>
            <param name="targetIndex">Index of the target.</param>
            <returns><c>true</c> if the requested index is in range.</returns>
        </member>
        <member name="M:NodaTime.Text.TextCursor.MoveNext">
            <summary>
            Moves to the next character.
            </summary>
            <returns><c>true</c> if the requested index is in range.</returns>
        </member>
        <member name="M:NodaTime.Text.TextCursor.MovePrevious">
            <summary>
            Moves to the previous character.
            </summary>
            <returns><c>true</c> if the requested index is in range.</returns>
        </member>
        <member name="T:NodaTime.Text.TextErrorMessages">
            <summary>
            Centralized location for error messages around text handling.
            </summary>
        </member>
        <member name="T:NodaTime.Text.TypeConverterBase`1">
            <summary>
            Provides conversion and parsing for <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="F:NodaTime.Text.TypeConverterBase`1.pattern">
            <summary>
            The pattern used to parse and serialize values of <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:NodaTime.Text.TypeConverterBase`1.#ctor(NodaTime.Text.IPattern{`0})">
            <summary>
            Constructs a <see cref="T:System.ComponentModel.TypeConverter"/> for <typeparamref name="T"/> based on the provided <see cref="T:NodaTime.Text.IPattern`1"/>.
            </summary>
            <param name="pattern">The pattern used to parse and serialize <typeparamref name="T"/>.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pattern"/></exception>
        </member>
        <member name="M:NodaTime.Text.TypeConverterBase`1.CanConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Type)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Text.TypeConverterBase`1.ConvertFrom(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.Text.TypeConverterBase`1.ConvertTo(System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.Object,System.Type)">
            <inheritdoc />
        </member>
        <member name="F:NodaTime.Text.ZonedDateTimeTypeConverter.cachedPattern">
            <summary>
            Cached pattern based on <see cref="P:NodaTime.Text.TypeConverterSettings.DateTimeZoneProvider"/>.
            This avoids us creating more patterns than we need, but still allows changes in
            <see cref="P:NodaTime.Text.TypeConverterSettings.DateTimeZoneProvider"/> to be reflected appropriately.
            </summary>
        </member>
        <member name="T:NodaTime.Text.TypeConverterSettings">
            <summary>
            Ambient settings applied for the default type converters. There's no simple context
            to express this information in a more elegant way, although users can create their
            own type converters to apply if they wish to.
            </summary>
        </member>
        <member name="P:NodaTime.Text.TypeConverterSettings.DateTimeZoneProvider">
            <summary>
            Gets the <see cref="T:NodaTime.IDateTimeZoneProvider"/> to use to interpret a time zone ID read as part of
            a TypeConverter operation for a <see cref="T:NodaTime.ZonedDateTime"/>.
            Note that if a value other than <see cref="P:NodaTime.DateTimeZoneProviders.Tzdb"/> is required, it should be set on
            application startup, before any type converters are used. Type converters are cached internally by the framework,
            so changes to this property after the first type converter for <see cref="T:NodaTime.ZonedDateTime"/> is created will
            not generally be visible.
            </summary>
            <remarks>
            This property defaults to <see cref="P:NodaTime.DateTimeZoneProviders.Tzdb"/>.
            </remarks>
            <value>The <c>IDateTimeZoneProvider</c> to use to interpret a time zone ID read as part of
            XML serialization.</value>
        </member>
        <member name="T:NodaTime.Text.UnparsableValueException">
            <summary>
            Exception thrown to indicate that the specified value could not be parsed.
            </summary>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.Text.UnparsableValueException.#ctor">
            <summary>
            Creates a new UnparsableValueException with no message.
            </summary>
        </member>
        <member name="M:NodaTime.Text.UnparsableValueException.#ctor(System.String)">
            <summary>
            Creates a new UnparsableValueException with the given message.
            </summary>
            <param name="message">The failure message</param>
        </member>
        <member name="M:NodaTime.Text.UnparsableValueException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new UnparsableValueException with the given message and inner exception
            </summary>
            <param name="message">The failure message</param>
            <param name="innerException">The inner exception</param>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref="T:NodaTime.Text.ValueCursor" /> class.
            </summary>
            <param name="value">The string to parse.</param>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.Match(System.Char)">
            <summary>
              Attempts to match the specified character with the current character of the string. If the
              character matches then the index is moved passed the character.
            </summary>
            <param name="character">The character to match.</param>
            <returns><c>true</c> if the character matches.</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.Match(System.String)">
            <summary>
            Attempts to match the specified string with the current point in the string. If the
            character matches then the index is moved past the string.
            </summary>
            <param name="match">The string to match.</param>
            <returns><c>true</c> if the string matches.</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.MatchCaseInsensitive(System.String,System.Globalization.CompareInfo,System.Boolean)">
            <summary>
            Attempts to match the specified string with the current point in the string in a case-insensitive
            manner, according to the given comparison info. The cursor is optionally updated to the end of the match.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.CompareOrdinal(System.String)">
            <summary>
            Compares the value from the current cursor position with the given match. If the
            given match string is longer than the remaining length, the comparison still goes
            ahead but the result is never 0: if the result of comparing to the end of the
            value returns 0, the result is -1 to indicate that the value is earlier than the given match.
            Conversely, if the remaining value is longer than the match string, the comparison only
            goes as far as the end of the match. So "xabcd" with the cursor at "a" will return 0 when
            matched with "abc".
            </summary>
            <returns>A negative number if the value (from the current cursor position) is lexicographically
            earlier than the given match string; 0 if they are equal (as far as the end of the match) and
            a positive number if the value is lexicographically later than the given match string.</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.ParseInt64``1(System.Int64@)">
            <summary>
            Parses digits at the current point in the string as a signed 64-bit integer value.
            Currently this method only supports cultures whose negative sign is "-" (and
            using ASCII digits).
            </summary>
            <param name="result">The result integer value. The value of this is not guaranteed
            to be anything specific if the return value is non-null.</param>
            <returns>null if the digits were parsed, or the appropriate parse failure</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.ParseInt64Digits(System.Int32,System.Int32,System.Int64@)">
            <summary>
            Parses digits at the current point in the string, as an <see cref="T:System.Int64"/> value.
            If the minimum required
            digits are not present then the index is unchanged. If there are more digits than
            the maximum allowed they are ignored.
            </summary>
            <param name="minimumDigits">The minimum allowed digits.</param>
            <param name="maximumDigits">The maximum allowed digits.</param>
            <param name="result">The result integer value. The value of this is not guaranteed
            to be anything specific if the return value is false.</param>
            <returns><c>true</c> if the digits were parsed.</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.ParseDigits(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Parses digits at the current point in the string. If the minimum required
            digits are not present then the index is unchanged. If there are more digits than
            the maximum allowed they are ignored.
            </summary>
            <param name="minimumDigits">The minimum allowed digits.</param>
            <param name="maximumDigits">The maximum allowed digits.</param>
            <param name="result">The result integer value. The value of this is not guaranteed
            to be anything specific if the return value is false.</param>
            <returns><c>true</c> if the digits were parsed.</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.ParseFraction(System.Int32,System.Int32,System.Int32@,System.Int32)">
            <summary>
            Parses digits at the current point in the string as a fractional value.
            </summary>
            <param name="maximumDigits">The maximum allowed digits. Trusted to be less than or equal to scale.</param>
            <param name="scale">The scale of the fractional value.</param>
            <param name="result">The result value scaled by scale. The value of this is not guaranteed
            to be anything specific if the return value is false.</param>
            <param name="minimumDigits">The minimum number of digits that must be specified in the value.</param>
            <returns><c>true</c> if the digits were parsed.</returns>
        </member>
        <member name="M:NodaTime.Text.ValueCursor.GetDigit">
            <summary>
            Gets the integer value of the current digit character, or -1 for "not a digit".
            </summary>
            <remarks>
            This currently only handles ASCII digits, which is all we have to parse to stay in line with the BCL.
            </remarks>
        </member>
        <member name="T:NodaTime.Text.YearMonthPattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.YearMonth"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.YearMonthPattern.Iso">
            <summary>
            Gets an invariant year/month pattern which is ISO-8601 compatible.
            This corresponds to the text pattern "uuuu'-'MM".
            </summary>
            <remarks>
            This pattern corresponds to the 'g' standard pattern.
            </remarks>
            <value>An invariant year/month pattern which is ISO-8601 compatible.</value>
        </member>
        <member name="T:NodaTime.Text.YearMonthPattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.YearMonthPattern.UnderlyingPattern">
            <summary>
            Returns the pattern that this object delegates to. Mostly useful to avoid this public class
            implementing an internal interface.
            </summary>
        </member>
        <member name="P:NodaTime.Text.YearMonthPattern.PatternText">
            <summary>
            Gets the pattern text for this pattern, as supplied on creation.
            </summary>
            <value>The pattern text for this pattern, as supplied on creation.</value>
        </member>
        <member name="P:NodaTime.Text.YearMonthPattern.FormatInfo">
            <summary>
            Returns the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.YearMonthPattern.TemplateValue">
            <summary>
            Gets the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
            <value>The value used as a template for parsing.</value>
        </member>
        <member name="M:NodaTime.Text.YearMonthPattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.YearMonthPattern.Format(NodaTime.YearMonth)">
            <summary>
            Formats the given year/month as text according to the rules of this pattern.
            </summary>
            <param name="value">The value to format.</param>
            <returns>The year/month formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.YearMonthPattern.AppendFormat(NodaTime.YearMonth,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="M:NodaTime.Text.YearMonthPattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.YearMonth)">
            <summary>
            Creates a pattern for the given pattern text, format info, and template value.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting year/month values.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.YearMonthPattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.YearMonth)">
            <summary>
            Creates a pattern for the given pattern text, culture, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting year/months.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.YearMonthPattern.Create(System.String,System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the given pattern text and culture, with a template value of 2000-01.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <returns>A pattern for parsing and formatting year/months.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.YearMonthPattern.CreateWithCurrentCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the current thread's current culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options. Note that the current culture
            is captured at the time this method is called - it is not captured at the point of parsing
            or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting year/month values.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.YearMonthPattern.CreateWithInvariantCulture(System.String)">
            <summary>
            Creates a pattern for the given pattern text in the invariant culture.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <returns>A pattern for parsing and formatting year/month values.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.YearMonthPattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="formatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.YearMonthPattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.YearMonthPattern.WithTemplateValue(NodaTime.YearMonth)">
            <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
            <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="T:NodaTime.Text.YearMonthPatternParser">
            <summary>
            Parser for patterns of <see cref="T:NodaTime.YearMonth"/> values.
            </summary>
        </member>
        <member name="T:NodaTime.Text.YearMonthPatternParser.YearMonthParseBucket">
            <summary>
            Bucket to put parsed values in, ready for later result calculation.
            Actually just delegates to a LocalDateParseBucket.
            </summary>
        </member>
        <member name="T:NodaTime.Text.ZonedDateTimePattern">
            <summary>
            Represents a pattern for parsing and formatting <see cref="T:NodaTime.ZonedDateTime"/> values.
            </summary>
            <threadsafety>
            When used with a read-only <see cref="T:System.Globalization.CultureInfo" />, this type is immutable and instances
            may be shared freely between threads. We recommend only using read-only cultures for patterns, although this is
            not currently enforced.
            </threadsafety>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.GeneralFormatOnlyIso">
            <summary>
            Gets an zoned local date/time pattern based on ISO-8601 (down to the second) including offset from UTC and zone ID.
            It corresponds to a custom pattern of "uuuu'-'MM'-'dd'T'HH':'mm':'ss z '('o&lt;g&gt;')'" and is available
            as the 'G' standard pattern.
            </summary>
            <remarks>
            The calendar system is not formatted as part of this pattern, and it cannot be used for parsing as no time zone
            provider is included. Call <see cref="M:NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)"/> on the value of this property to obtain a
            pattern which can be used for parsing.
            </remarks>
            <value>An zoned local date/time pattern based on ISO-8601 (down to the second) including offset from UTC and zone ID.</value>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.ExtendedFormatOnlyIso">
            <summary>
            Returns an invariant zoned date/time pattern based on ISO-8601 (down to the nanosecond) including offset from UTC and zone ID.
            It corresponds to a custom pattern of "uuuu'-'MM'-'dd'T'HH':'mm':'ss;FFFFFFFFF z '('o&lt;g&gt;')'" and is available
            as the 'F' standard pattern.
            </summary>
            <remarks>
            The calendar system is not formatted as part of this pattern, and it cannot be used for parsing as no time zone
            provider is included. Call <see cref="M:NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)"/> on the value of this property to obtain a
            pattern which can be used for parsing.
            </remarks>
            <value>An invariant zoned date/time pattern based on ISO-8601 (down to the nanosecond) including offset from UTC and zone ID.</value>
        </member>
        <member name="T:NodaTime.Text.ZonedDateTimePattern.Patterns">
            <summary>
            Class whose existence is solely to avoid type initialization order issues, most of which stem
            from needing NodaFormatInfo.InvariantInfo...
            </summary>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.PatternText">
            <summary>
            Gets the pattern text for this pattern, as supplied on creation.
            </summary>
            <value>The pattern text for this pattern, as supplied on creation.</value>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.FormatInfo">
            <summary>
            Gets the localization information used in this pattern.
            </summary>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.TemplateValue">
            <summary>
            Gets the value used as a template for parsing: any field values unspecified
            in the pattern are taken from the template.
            </summary>
            <value>The value used as a template for parsing.</value>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.Resolver">
            <summary>
            Gets the resolver which is used to map local date/times to zoned date/times,
            handling skipped and ambiguous times appropriately (where the offset isn't specified in the pattern).
            This may be null, in which case the pattern can only be used for formatting (not parsing).
            </summary>
            <value>The resolver which is used to map local date/times to zoned date/times.</value>
        </member>
        <member name="P:NodaTime.Text.ZonedDateTimePattern.ZoneProvider">
            <summary>
            Gets the provider which is used to look up time zones when parsing a pattern
            which contains a time zone identifier. This may be null, in which case the pattern can
            only be used for formatting (not parsing).
            </summary>
            <value>The provider which is used to look up time zones when parsing a pattern
            which contains a time zone identifier.</value>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.Parse(System.String)">
            <summary>
            Parses the given text value according to the rules of this pattern.
            </summary>
            <remarks>
            This method never throws an exception (barring a bug in Noda Time itself). Even errors such as
            the argument being null are wrapped in a parse result.
            </remarks>
            <param name="text">The text value to parse.</param>
            <returns>The result of parsing, which may be successful or unsuccessful.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.Format(NodaTime.ZonedDateTime)">
            <summary>
            Formats the given zoned date/time as text according to the rules of this pattern.
            </summary>
            <param name="value">The zoned date/time to format.</param>
            <returns>The zoned date/time formatted according to this pattern.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.AppendFormat(NodaTime.ZonedDateTime,System.Text.StringBuilder)">
            <summary>
            Formats the given value as text according to the rules of this pattern,
            appending to the given <see cref="T:System.Text.StringBuilder"/>.
            </summary>
            <param name="value">The value to format.</param>
            <param name="builder">The <c>StringBuilder</c> to append to.</param>
            <returns>The builder passed in as <paramref name="builder"/>.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.Create(System.String,NodaTime.Globalization.NodaFormatInfo,NodaTime.TimeZones.ZoneLocalMappingResolver,NodaTime.IDateTimeZoneProvider,NodaTime.ZonedDateTime)">
            <summary>
            Creates a pattern for the given pattern text, format info, template value, mapping resolver and time zone provider.
            </summary>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="formatInfo">The format info to use in the pattern</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <param name="resolver">Resolver to apply when mapping local date/time values into the zone.</param>
            <param name="zoneProvider">Time zone provider, used when parsing text which contains a time zone identifier.</param>
            <returns>A pattern for parsing and formatting zoned date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.Create(System.String,System.Globalization.CultureInfo,NodaTime.TimeZones.ZoneLocalMappingResolver,NodaTime.IDateTimeZoneProvider,NodaTime.ZonedDateTime)">
            <summary>
            Creates a pattern for the given pattern text, culture, resolver, time zone provider, and template value.
            </summary>
            <remarks>
            See the user guide for the available pattern text options.
            If <paramref name="zoneProvider"/> is null, the resulting pattern can be used for formatting
            but not parsing.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="cultureInfo">The culture to use in the pattern</param>
            <param name="resolver">Resolver to apply when mapping local date/time values into the zone.</param>
            <param name="zoneProvider">Time zone provider, used when parsing text which contains a time zone identifier.</param>
            <param name="templateValue">Template value to use for unspecified fields</param>
            <returns>A pattern for parsing and formatting zoned date/times.</returns>
            <exception cref="T:NodaTime.Text.InvalidPatternException">The pattern text was invalid.</exception>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.CreateWithInvariantCulture(System.String,NodaTime.IDateTimeZoneProvider)">
            <summary>
            Creates a pattern for the given pattern text and time zone provider, using a strict resolver, the invariant
            culture, and a default template value of midnight January 1st 2000 UTC.
            </summary>
            <remarks>
            The resolver is only used if the pattern text doesn't include an offset.
            If <paramref name="zoneProvider"/> is null, the resulting pattern can be used for formatting
            but not parsing.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="zoneProvider">Time zone provider, used when parsing text which contains a time zone identifier.</param>
            <returns>A pattern for parsing and formatting zoned date/times.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.CreateWithCurrentCulture(System.String,NodaTime.IDateTimeZoneProvider)">
            <summary>
            Creates a pattern for the given pattern text and time zone provider, using a strict resolver, the current
            culture, and a default template value of midnight January 1st 2000 UTC.
            </summary>
            <remarks>
            The resolver is only used if the pattern text doesn't include an offset.
            If <paramref name="zoneProvider"/> is null, the resulting pattern can be used for formatting
            but not parsing. Note that the current culture is captured at the time this method is called
            - it is not captured at the point of parsing or formatting values.
            </remarks>
            <param name="patternText">Pattern text to create the pattern for</param>
            <param name="zoneProvider">Time zone provider, used when parsing text which contains a time zone identifier.</param>
            <returns>A pattern for parsing and formatting zoned date/times.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithPatternText(System.String)">
            <summary>
            Creates a pattern for the same original localization information as this pattern, but with the specified
            pattern text.
            </summary>
            <param name="patternText">The pattern text to use in the new pattern.</param>
            <returns>A new pattern with the given pattern text.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithFormatInfo(NodaTime.Globalization.NodaFormatInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            localization information.
            </summary>
            <param name="formatInfo">The localization information to use in the new pattern.</param>
            <returns>A new pattern with the given localization information.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithCulture(System.Globalization.CultureInfo)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            culture.
            </summary>
            <param name="cultureInfo">The culture to use in the new pattern.</param>
            <returns>A new pattern with the given culture.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithResolver(NodaTime.TimeZones.ZoneLocalMappingResolver)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            resolver.
            </summary>
            <param name="resolver">The new local mapping resolver to use.</param>
            <returns>A new pattern with the given resolver.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithZoneProvider(NodaTime.IDateTimeZoneProvider)">
            <summary>
            Creates a pattern for the same original pattern text as this pattern, but with the specified
            time zone provider.
            </summary>
            <remarks>
            If <paramref name="newZoneProvider"/> is null, the resulting pattern can be used for formatting
            but not parsing.
            </remarks>
            <param name="newZoneProvider">The new time zone provider to use.</param>
            <returns>A new pattern with the given time zone provider.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithTemplateValue(NodaTime.ZonedDateTime)">
            <summary>
            Creates a pattern like this one, but with the specified template value.
            </summary>
            <param name="newTemplateValue">The template value for the new pattern, used to fill in unspecified fields.</param>
            <returns>A new pattern with the given template value.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePattern.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a pattern like this one, but with the template value modified to use
            the specified calendar system.
            </summary>
            <remarks>
            <para>
            Care should be taken in two (relatively rare) scenarios. Although the default template value
            is supported by all Noda Time calendar systems, if a pattern is created with a different
            template value and then this method is called with a calendar system which doesn't support that
            date, an exception will be thrown. Additionally, if the pattern only specifies some date fields,
            it's possible that the new template value will not be suitable for all values.
            </para>
            </remarks>
            <param name="calendar">The calendar system to convert the template value into.</param>
            <returns>A new pattern with a template value in the specified calendar system.</returns>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePatternParser.ZonedDateTimeParseBucket.TryParseFixedZone(NodaTime.Text.ValueCursor)">
            <summary>
            Attempts to parse a fixed time zone from "UTC" with an optional
            offset, expressed as +HH, +HH:mm, +HH:mm:ss or +HH:mm:ss.fff - i.e. the
            general format. If it manages, it will move the cursor and return the
            zone. Otherwise, it will return null and the cursor will remain where
            it was.
            </summary>
        </member>
        <member name="M:NodaTime.Text.ZonedDateTimePatternParser.ZonedDateTimeParseBucket.TryParseProviderZone(NodaTime.Text.ValueCursor)">
            <summary>
            Tries to parse a time zone ID from the provider. Returns the zone
            on success (after moving the cursor to the end of the ID) or null on failure
            (leaving the cursor where it was).
            </summary>
        </member>
        <member name="T:NodaTime.TimeAdjusters">
            <summary>
            Factory class for time adjusters: functions from <see cref="T:NodaTime.LocalTime"/> to <c>LocalTime</c>,
            which can be applied to <see cref="T:NodaTime.LocalTime"/>, <see cref="T:NodaTime.LocalDateTime"/>, and <see cref="T:NodaTime.OffsetDateTime"/>.
            </summary>
        </member>
        <member name="P:NodaTime.TimeAdjusters.TruncateToSecond">
            <summary>
            Gets a time adjuster to truncate the time to the second, discarding fractional seconds.
            </summary>
            <value>A time adjuster to truncate the time to the second, discarding fractional seconds.</value>
        </member>
        <member name="P:NodaTime.TimeAdjusters.TruncateToMinute">
            <summary>
            Gets a time adjuster to truncate the time to the minute, discarding fractional minutes.
            </summary>
            <value>A time adjuster to truncate the time to the minute, discarding fractional minutes.</value>
        </member>
        <member name="P:NodaTime.TimeAdjusters.TruncateToHour">
            <summary>
            Get a time adjuster to truncate the time to the hour, discarding fractional hours.
            </summary>
            <value>A time adjuster to truncate the time to the hour, discarding fractional hours.</value>
        </member>
        <member name="T:NodaTime.TimeZones.BclDateTimeZone">
            <summary>
            Representation of a time zone converted from a <see cref="T:System.TimeZoneInfo"/> from the Base Class Library.
            </summary>
            <remarks>
            <para>
            Two instances of this class are deemed equal if and only if they refer to the exact same
            <see cref="T:System.TimeZoneInfo"/> object.
            </para>
            <para>
            This implementation does not always give the same results as <c>TimeZoneInfo</c>, in that it doesn't replicate
            the bugs in the BCL interpretation of the data. These bugs are described in
            <a href="https://codeblog.jonskeet.uk/2014/09/30/the-mysteries-of-bcl-time-zone-data/">a blog post</a>, but we're
            not expecting them to be fixed any time soon. Being bug-for-bug compatible would not only be tricky, but would be painful
            if the BCL were ever to be fixed. As far as we are aware, there are only discrepancies around new year where the zone
            changes from observing one rule to observing another.
            </para>
            <para>
            As of version 3.0, a new "incompatible but doing the right thing" category of differences has been implemented,
            for time zones which have a transition at 24:00. The Windows time zone data represents this as a transition at 23:59:59.999,
            and that's faithfully represented by TimeZoneInfo (and BclDateTimeZone in version 2.x). As of 3.0, this is spotted
            and converted to a midnight-on-the-following-day transition.
            </para>
            </remarks>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.TimeZones.BclDateTimeZone.systemDefault">
            <summary>
            This is used to cache the last result of a call to <see cref="M:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault"/>, but it doesn't
            matter if it's out of date - we'll just create another wrapper if necessary. It's not *that* expensive to make
            a few more wrappers than we need.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZone.OriginalZone">
            <summary>
            Gets the original <see cref="T:System.TimeZoneInfo"/> from which this was created.
            </summary>
            <value>The original <see cref="T:System.TimeZoneInfo"/> from which this was created.</value>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZone.DisplayName">
            <summary>
            Gets the display name associated with the time zone, as provided by the Base Class Library.
            </summary>
            <value>The display name associated with the time zone, as provided by the Base Class Library.</value>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZone.FromTimeZoneInfo(System.TimeZoneInfo)">
            <summary>
            Creates a new <see cref="T:NodaTime.TimeZones.BclDateTimeZone" /> from a <see cref="T:System.TimeZoneInfo"/> from the Base Class Library.
            </summary>
            <param name="bclZone">The original time zone to take information from.</param>
            <returns>A <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/> wrapping the given <c>TimeZoneInfo</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZone.AreWindowsStyleRules(System.TimeZoneInfo.AdjustmentRule[])">
            <summary>
            .NET Core on Unix adjustment rules can't currently be treated like regular Windows ones.
            Instead of dividing time into periods by year, the rules are read from TZIF files, so are like
            our PrecalculatedDateTimeZone. This is only visible for testing purposes.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZone.FixUnixTransitions(NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule[])">
            <summary>
            The Unix rules are sometimes either slightly disjoint, or overlap. Ideally, we should be able to remove
            (or at least understand the need for) this code, but until then, it seems to make all the tests pass.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule">
            <summary>
            Just a mapping of a TimeZoneInfo.AdjustmentRule into Noda Time types. Very little cleverness here.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule.Start">
            <summary>
            Instant on which this rule starts.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule.End">
            <summary>
            Instant on which this rule ends.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule.Savings">
            <summary>
            Daylight savings, when applicable within this rule.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule.StandardOffset">
            <summary>
            The standard offset for the duration of this rule.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule.DaylightFakingZoneIntervalMap">
            <summary>
            An implementation of IZoneIntervalMap that delegates to an original map, except for where the result of a
            ZoneInterval lookup has the given daylight name. In that case, a new ZoneInterval is built with the same
            wall offset (and start/end instants etc), but with a savings of 1 hour. This is only used to work around TimeZoneInfo
            adjustment rules with a daylight saving of 0 which are really trying to fake a more comprehensive solution.
            (This is currently only seen on Mono on Linux...)
            This addresses https://github.com/nodatime/nodatime/issues/746.
            If TimeZoneInfo had sufficient flexibility to use different names for different periods of time, we'd have
            another problem, as some "daylight names" don't always mean daylight - e.g. "BST" = British Summer Time and British Standard Time.
            In this case, the limited nature of TimeZoneInfo works in our favour.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZone.BclAdjustmentRule.IsStandardOffsetOnlyRule(System.TimeZoneInfo.AdjustmentRule)">
            <summary>
            The BCL represents "standard-only" rules using two fixed date January 1st transitions.
            Currently the time-of-day used for the DST end transition is at one millisecond past midnight... we'll
            be slightly more lenient, accepting anything up to 12:01...
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZone.ForSystemDefault">
            <summary>
            Returns a time zone converted from the BCL representation of the system local time zone.
            </summary>
            <remarks>
            <para>
            This method is approximately equivalent to calling <see cref="M:NodaTime.IDateTimeZoneProvider.GetSystemDefault"/> with
            an implementation that wraps <see cref="T:NodaTime.TimeZones.BclDateTimeZoneSource"/> (e.g.
            <see cref="P:NodaTime.DateTimeZoneProviders.Bcl"/>), with the exception that it will succeed even if the current local
            time zone was not one of the set of system time zones captured when the source was created (which, while
            highly unlikely, might occur either because the local time zone is not a system time zone, or because the
            system time zones have themselves changed).
            </para>
            <para>
            This method will retain a reference to the returned <c>BclDateTimeZone</c>, and will attempt to return it if
            called repeatedly (assuming that the local time zone has not changed) rather than creating a new instance,
            though this behaviour is not guaranteed.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The system does not provide a time zone.</exception>
            <returns>A <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/> wrapping the "local" (system) time zone as returned by
            <see cref="P:System.TimeZoneInfo.Local"/>.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.BclDateTimeZoneSource">
            <summary>
            Provides an implementation of <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource" /> that loads data from the BCL
            <see cref="T:System.TimeZoneInfo"/> class.
            </summary>
            <remarks>
            <para>
            All calls to <see cref="M:NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)"/> return instances of <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/>, including for fixed-offset IDs
            (i.e. "UTC" and "UTC+/-Offset").
            </para>
            <para>
            In Noda Time 1.x and 2.x, this class is only available on the .NET Framework builds of Noda Time, and not the
            PCL (Noda Time 1.x) or .NET Standard 1.3 (Noda Time 2.x) builds.
            </para>
            </remarks>
            <threadsafety>This type maintains no state, and all members are thread-safe. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.#ctor">
            <summary>
            Constructs a new instance. This is rarely useful in application code, as this class has no state of its own.
            Most application code should use <see cref="P:NodaTime.DateTimeZoneProviders.Bcl"/>.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.GetIds">
            <summary>
            Returns the IDs of all system time zones.
            </summary>
            <returns>The IDs available from this source.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.GetTimeZoneInfoLocalIdOrEmpty">
            <summary>
            Returns an enumerable containing a singleton element of the Id of the local time zone
            (<c>TimeZoneInfo.Local.Id</c>), unless the local time zone is not available, or not a system time zone, in
            which case returns an empty enumerable.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.BclDateTimeZoneSource.VersionId">
            <inheritdoc />
            <remarks>
            This source returns a string such as "TimeZoneInfo: 3.5.0.0" corresponding to the version of the assembly
            containing <see cref="T:System.TimeZoneInfo"/>.
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.NodaTime#TimeZones#IDateTimeZoneSource#ForId(System.String)">
            <summary>
            Creates a new instance of <see cref="T:NodaTime.TimeZones.BclDateTimeZone" /> from the <see cref="T:System.TimeZoneInfo"/> with the given
            ID. The ID must be a known system time zone ID.
            </summary>
            <remarks>
            This method explicitly implements <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)"/> by delegating to the
            <see cref="M:NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)"/> method which has a return type of <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/>, ensuring that all
            zones returned by this implementation are instances of <see cref="T:NodaTime.TimeZones.BclDateTimeZone"/> (rather than the built-in
            fixed offset zones).
            </remarks>        
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.ForId(System.String)">
            <summary>
            Creates a new instance of <see cref="T:NodaTime.TimeZones.BclDateTimeZone" /> from the <see cref="T:System.TimeZoneInfo"/> with the given
            ID. The ID must be a known system time zone ID.
            </summary>
            <param name="id">The ID of the system time zone to convert</param>
            <exception cref="T:System.ArgumentException">The given zone doesn't exist.</exception>
            <returns>The Noda Time representation of the given BCL time zone</returns>
        </member>
        <member name="M:NodaTime.TimeZones.BclDateTimeZoneSource.GetSystemDefaultId">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.TimeZones.CachedDateTimeZone">
            <summary>
             Provides a <see cref="T:NodaTime.DateTimeZone"/> wrapper class that implements a simple cache to
             speed up the lookup of transitions.
            </summary>
            <remarks>
            <para>
            The cache supports multiple caching strategies which are implemented in nested subclasses of
            this one. Until we have a better sense of what the usage behavior is, we cannot tune the
            cache. It is possible that we may support multiple strategies selectable at runtime so the
            user can tune the performance based on their knowledge of how they are using the system.
            </para>
            <para>
            In fact, only one cache type is currently implemented: an MRU cache existed before
            the GetZoneIntervalPair call was created in DateTimeZone, but as it wasn't being used, it
            was more effort than it was worth to update. The mechanism is still available for future
            expansion though.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.CachedDateTimeZone.TimeZone">
            <summary>
            Gets the cached time zone.
            </summary>
            <value>The time zone.</value>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.#ctor(NodaTime.DateTimeZone,NodaTime.TimeZones.IZoneIntervalMap)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.CachedDateTimeZone"/> class.
            </summary>
            <param name="timeZone">The time zone to cache.</param>
            <param name="map">The caching map</param>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.ForZone(NodaTime.DateTimeZone)">
            <summary>
            Returns a cached time zone for the given time zone.
            </summary>
            <remarks>
            If the time zone is already cached or it is fixed then it is returned unchanged.
            </remarks>
            <param name="timeZone">The time zone to cache.</param>
            <returns>The cached time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.CachedDateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Delegates fetching a zone interval to the caching map.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.CachingZoneIntervalMap">
            <summary>
            Helper methods for creating IZoneIntervalMaps which cache results.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.CachingZoneIntervalMap.CacheMap(NodaTime.TimeZones.IZoneIntervalMap)">
            <summary>
            Returns a caching map for the given input map.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache">
            <summary>
            This provides a simple cache based on two hash tables (one for local instants, another
            for instants).
            </summary>
            <remarks>
            Each hash table entry is either entry or contains a node with enough
            information for a particular "period" of 32 days - so multiple calls for time
            zone information within the same few years are likely to hit the cache. Note that
            a single "period" may include a daylight saving change (or conceivably more than one);
            a node therefore has to contain enough intervals to completely represent that period.
            
            If another call is made which maps to the same cache entry number but is for a different
            period, the existing hash entry is simply overridden.
            </remarks>
        </member>
        <member name="F:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.PeriodShift">
            <summary>
            Defines the number of bits to shift an instant's "days since epoch" to get the period. This
            converts an instant into a number of 32 day periods.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone offset period for the given instant. Null is returned if no period is
            defined by the time zone for the given instant.
            </summary>
            <param name="instant">The Instant to test.</param>
            <returns>The defined ZoneOffsetPeriod or null.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode.CreateNode(System.Int32,NodaTime.TimeZones.IZoneIntervalMap)">
            <summary>
            Creates a hash table node with all the information for this period.
            We start off by finding the interval for the start of the period, and
            then repeatedly check whether that interval ends after the end of the
            period - at which point we're done. If not, find the next interval, create
            a new node referring to that interval and the previous interval, and keep going.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode.#ctor(NodaTime.TimeZones.ZoneInterval,System.Int32,NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode"/> class.
            </summary>
            <param name="interval">The zone interval.</param>
            <param name="period"></param>
            <param name="previous">The previous <see cref="T:NodaTime.TimeZones.CachingZoneIntervalMap.HashArrayCache.HashCacheNode"/> node.</param>
        </member>
        <member name="T:NodaTime.TimeZones.Cldr.MapZone">
            <summary>
            Represents a single <c>&lt;mapZone&gt;</c> element in the CLDR Windows zone mapping file. 
            </summary>
            <remarks>
            <para>
            Equality is defined in a component-wise fashion. When comparing two values for equality, the <see cref="P:NodaTime.TimeZones.Cldr.MapZone.TzdbIds"/> properties
            must return the same IDs in the same order for the values to be considered equal.
            </para>
            </remarks>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory">
            <summary>
            Identifier used for the primary territory of each Windows time zone. A zone mapping with
            this territory will always have a single entry. The value of this constant is "001".
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.Cldr.MapZone.FixedOffsetTerritory">
            <summary>
            Identifier used for the "fixed offset" territory. A zone mapping with
            this territory will always have a single entry. The value of this constant is "ZZ".
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.MapZone.WindowsId">
            <summary>
            Gets the Windows system time zone identifier for this mapping, such as "Central Standard Time".
            </summary>
            <remarks>
            <para>
            Most Windows system time zone identifiers use the name for the "standard" part of the zone as
            the overall identifier. Don't be fooled: just because a time zone includes "standard" in its identifier
            doesn't mean that it doesn't observe daylight saving time.
            </para>
            </remarks>
            <value>The Windows system time zone identifier for this mapping, such as "Central Standard Time".</value>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.MapZone.Territory">
            <summary>
            Gets the territory code for this mapping.
            </summary>
            <remarks>
            This is typically either "001" to indicate that it's the primary territory for this ID, or
            "ZZ" to indicate a fixed-offset ID, or a different two-character capitalized code
            which indicates the geographical territory.
            </remarks>
            <value>The territory code for this mapping.</value>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.MapZone.TzdbIds">
            <summary>
            Gets a read-only non-empty collection of TZDB zone identifiers for this mapping, such as
            "America/Chicago" and "America/Matamoros" (both of which are TZDB zones associated with the "Central Standard Time"
            Windows system time zone).
            </summary>
            <remarks>
            For the primary and fixed-offset territory IDs ("001" and "ZZ") this always
            contains exactly one time zone ID. The IDs returned are not necessarily canonical in TZDB.
            </remarks>
            <value>A read-only non-empty collection of TZDB zone identifiers for this mapping.</value>
        </member>
        <member name="M:NodaTime.TimeZones.Cldr.MapZone.#ctor(System.String,System.String,System.Collections.Generic.IList{System.String})">
            <summary>
            Creates a new mapping entry.
            </summary>
            <remarks>
            This constructor is only public for the sake of testability.
            </remarks>
            <param name="windowsId">Windows system time zone identifier. Must not be null.</param>
            <param name="territory">Territory code. Must not be null.</param>
            <param name="tzdbIds">List of territory codes. Must not be null, and must not
            contains null values.</param>
        </member>
        <member name="M:NodaTime.TimeZones.Cldr.MapZone.#ctor(System.String,System.String,System.Collections.ObjectModel.ReadOnlyCollection{System.String})">
            <summary>
            Private constructor to avoid unnecessary list copying (and validation) when deserializing.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.Cldr.MapZone.Read(NodaTime.TimeZones.IO.IDateTimeZoneReader)">
            <summary>
            Reads a mapping from a reader.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.Cldr.MapZone.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
            <summary>
            Writes this mapping to a writer.
            </summary>
            <param name="writer"></param>
        </member>
        <member name="M:NodaTime.TimeZones.Cldr.MapZone.Equals(NodaTime.TimeZones.Cldr.MapZone)">
            <summary>
            Compares two <see cref="T:NodaTime.TimeZones.Cldr.MapZone"/> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">The value to compare this map zone with.</param>
            <returns>True if the given value is another map zone equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.Cldr.MapZone.GetHashCode">
            <summary>
            Returns a hash code for this map zone.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>A hash code for this map zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.Cldr.MapZone.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:NodaTime.TimeZones.Cldr.MapZone"/> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The value to compare this map zone with.</param>
            <returns>True if the given value is another map zone equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.Cldr.MapZone.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance, for diagnostic purposes.
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.Cldr.WindowsZones">
            <summary>
            Representation of the <c>&lt;windowsZones&gt;</c> element of CLDR supplemental data.
            </summary>
            <remarks>
            See <a href="http://cldr.unicode.org/development/development-process/design-proposals/extended-windows-olson-zid-mapping">the CLDR design proposal</a>
            for more details of the structure of the file from which data is taken.
            </remarks>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.Version">
            <summary>
            Gets the version of the Windows zones mapping data read from the original file.
            </summary>
            <remarks>
            As with other IDs, this should largely be treated as an opaque string, but the current method for
            generating this from the mapping file extracts a number from an element such as <c>&lt;version number="$Revision: 7825 $"/&gt;</c>.
            This is a Subversion revision number, but that association should only be used for diagnostic curiosity, and never
            assumed in code.
            </remarks>
            <value>The version of the Windows zones mapping data read from the original file.</value>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.TzdbVersion">
            <summary>
            Gets the TZDB version this Windows zone mapping data was created from.
            </summary>
            <remarks>
            The CLDR mapping file usually lags behind the TZDB file somewhat - partly because the
            mappings themselves don't always change when the time zone data does. For example, it's entirely
            reasonable for a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/> with a <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion">TzdbVersion</see> of
            "2013b" to be supply a <c>WindowsZones</c> object with a <c>TzdbVersion</c> of "2012f".
            </remarks>
            <value>The TZDB version this Windows zone mapping data was created from.</value>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.WindowsVersion">
            <summary>
            Gets the Windows time zone database version this Windows zone mapping data was created from.
            </summary>
            <remarks>
            At the time of this writing, this is populated (by CLDR) from the registry key
            HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones\TzVersion,
            so "7dc0101" for example.
            </remarks>
            <value>The Windows time zone database version this Windows zone mapping data was created from.</value>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.MapZones">
            <summary>
            Gets an immutable collection of mappings from Windows system time zones to
            TZDB time zones.
            </summary>
            <remarks>
            <para>
            Each mapping consists of a single Windows time zone ID and a single
            territory to potentially multiple TZDB IDs that are broadly equivalent to that Windows zone/territory
            pair.
            </para>
            <para>
            Mappings for a single Windows system time zone can appear multiple times
            in this list, in different territories. For example, "Central Standard Time"
            maps to different TZDB zones in different countries (the US, Canada, Mexico) and
            even within a single territory there can be multiple zones. Every Windows system time zone covered within
            this collection has a "primary" entry with a territory code of "001" (which is the value of
            <see cref="F:NodaTime.TimeZones.Cldr.MapZone.PrimaryTerritory"/>) and a single corresponding TZDB zone. 
            </para>
            <para>This collection is not guaranteed to cover every Windows time zone. Some zones may be unmappable
            (such as "Mid-Atlantic Standard Time") and there can be a delay between a new Windows time zone being introduced
            and it appearing in CLDR, ready to be used by Noda Time. (There's also bound to be a delay between it appearing
            in CLDR and being used in your production system.) In practice however, you're unlikely to wish to use a time zone
            which isn't covered here.</para>
            </remarks>
            <value>An immutable collection of mappings from Windows system time zones to
            TZDB time zones.</value>
        </member>
        <member name="P:NodaTime.TimeZones.Cldr.WindowsZones.PrimaryMapping">
            <summary>
            Gets an immutable dictionary of primary mappings, from Windows system time zone ID
            to TZDB zone ID. This corresponds to the "001" territory which is present for every zone
            within the mapping file.
            </summary>
            <remarks>
            <para>
            Each value in the dictionary is a canonical ID in CLDR, but it may not be canonical
            in TZDB. For example, the ID corresponding to "India Standard Time" is "Asia/Calcutta", which
            is canonical in CLDR but is an alias in TZDB for "Asia/Kolkata". To obtain a canonical TZDB
            ID, use <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap"/>.
            </para>
            </remarks>
            <value>An immutable dictionary of primary mappings, from Windows system time zone ID
            to TZDB zone ID.</value>
        </member>
        <member name="T:NodaTime.TimeZones.DateTimeZoneCache">
            <summary>
            Provides an implementation of <see cref="T:NodaTime.IDateTimeZoneProvider"/> that caches results from an
            <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource"/>.
            </summary>
            <remarks>
            The process of loading or creating time zones may be an expensive operation. This class implements an
            unlimited-size non-expiring cache over a time zone source, and adapts an implementation of the
            <c>IDateTimeZoneSource</c> interface to an <c>IDateTimeZoneProvider</c>.
            </remarks>
            <seealso cref="T:NodaTime.DateTimeZoneProviders"/>
            <threadsafety>All members of this type are thread-safe as long as the underlying <c>IDateTimeZoneSource</c>
            implementation is thread-safe.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.DateTimeZoneCache.VersionId">
            <summary>
            Gets the version ID of this provider. This is simply the <see cref="P:NodaTime.TimeZones.IDateTimeZoneSource.VersionId"/> returned by
            the underlying source.
            </summary>
            <value>The version ID of this provider.</value>
        </member>
        <member name="P:NodaTime.TimeZones.DateTimeZoneCache.Ids">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCache.#ctor(NodaTime.TimeZones.IDateTimeZoneSource)">
            <summary>
            Creates a provider backed by the given <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource"/>.
            </summary>
            <remarks>
            Note that the source will never be consulted for requests for the fixed-offset timezones "UTC" and
            "UTC+/-Offset" (a standard implementation will be returned instead). This is true even if these IDs are
            advertised by the source.
            </remarks>
            <param name="source">The <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource"/> for this provider.</param>
            <exception cref="T:NodaTime.TimeZones.InvalidDateTimeZoneSourceException"><paramref name="source"/> violates its contract.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCache.GetSystemDefault">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneCache.GetZoneOrNull(System.String)">
            <inheritdoc />
        </member>
        <member name="P:NodaTime.TimeZones.DateTimeZoneCache.Item(System.String)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.TimeZones.DateTimeZoneNotFoundException">
            <summary>
            Exception thrown when time zone is requested from an <see cref="T:NodaTime.IDateTimeZoneProvider"/>,
            but the specified ID is invalid for that provider.
            </summary>
            <remarks>
            This type originally existed as <c>TimeZoneNotFoundException</c> doesn't exist in framework versions
            targeted by earlier versions of Noda Time. It is present now solely to avoid unnecessary
            backward incompatibility. While it could be used to distinguish between exceptions thrown by
            Noda Time and those thrown by <c>TimeZoneInfo</c>, we recommend that you don't use it that way.
            </remarks>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.TimeZones.DateTimeZoneNotFoundException.#ctor(System.String)">
            <summary>
            Creates an instance with the given message.
            </summary>
            <param name="message">The message for the exception.</param>
        </member>
        <member name="T:NodaTime.TimeZones.AmbiguousTimeResolver">
            <summary>
            Chooses between two <see cref="T:NodaTime.ZonedDateTime"/> values that resolve to the same <see cref="T:NodaTime.LocalDateTime"/>.
            </summary>
            <remarks>
            <para>
            This delegate is used by <see cref="M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)"/> when handling an ambiguous local time,
            due to clocks moving backward in a time zone transition (usually due to an autumnal daylight saving transition).
            </para>
            <para>
            The returned value should be one of the two parameter values, based on the policy of the specific
            implementation. Alternatively, it can throw an <see cref="T:NodaTime.AmbiguousTimeException" /> to implement a policy of
            "reject ambiguous times."
            </para>
            <para>See the <see cref="T:NodaTime.TimeZones.Resolvers" /> class for predefined implementations.</para>
            <para>
            Implementations of this delegate can reasonably
            assume that the target local date and time really is ambiguous; the behaviour when the local date and time
            can be unambiguously mapped into the target time zone (or when it's skipped) is undefined.
            </para>
            </remarks>
            <param name="earlier">The earlier of the ambiguous matches for the original local date and time</param>
            <param name="later">The later of the ambiguous matches for the original local date and time</param>
            <exception cref="T:NodaTime.AmbiguousTimeException">The implementation rejects requests to map ambiguous times.</exception>
            <returns>
            A <see cref="T:NodaTime.ZonedDateTime"/> in the target time zone; typically, one of the two input parameters.
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.SkippedTimeResolver">
            <summary>
            Resolves a <see cref="T:NodaTime.LocalDateTime"/> to a <see cref="T:NodaTime.ZonedDateTime" /> in the situation
            where the requested local time does not exist in the target time zone.
            </summary>
            <remarks>
            <para>
            This delegate is used by <see cref="M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)"/> when handling the situation where the
            requested local time does not exist, due to clocks moving forward in a time zone transition (usually due to a
            spring daylight saving transition).
            </para>
            <para>
            The returned value will necessarily represent a different local date and time to the target one, but
            the exact form of mapping is up to the delegate implementation. For example, it could return a value
            as close to the target local date and time as possible, or the time immediately after the transition.
            Alternatively, it can throw a <see cref="T:NodaTime.SkippedTimeException" /> to implement a policy of "reject
            skipped times."
            </para>
            <para>See the <see cref="T:NodaTime.TimeZones.Resolvers" /> class for predefined implementations.</para>
            <para>
            Implementations of this delegate can reasonably
            assume that the target local date and time really is skipped; the behaviour when the local date and time
            can be directly mapped into the target time zone is undefined.
            </para>
            </remarks>
            <param name="localDateTime">The local date and time to map to the given time zone</param>
            <param name="zone">The target time zone</param>
            <param name="intervalBefore">The zone interval directly before the target local date and time would have occurred</param>
            <param name="intervalAfter">The zone interval directly after the target local date and time would have occurred</param>
            <exception cref="T:NodaTime.SkippedTimeException">The implementation rejects requests to map skipped times.</exception>
            <returns>A <see cref="T:NodaTime.ZonedDateTime"/> in the target time zone.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneLocalMappingResolver">
            <summary>
            Resolves the result of attempting to map a local date and time to a target time zone.
            </summary>
            <remarks>
            <para>
            This delegate is consumed by <see cref="M:NodaTime.LocalDateTime.InZone(NodaTime.DateTimeZone,NodaTime.TimeZones.ZoneLocalMappingResolver)"/> and <see cref="M:NodaTime.DateTimeZone.ResolveLocal(NodaTime.LocalDateTime,NodaTime.TimeZones.ZoneLocalMappingResolver)"/>,
            among others. It provides the strategy for converting a <see cref="T:NodaTime.TimeZones.ZoneLocalMapping"/> (the result of attempting
            to map a local date and time to a target time zone) to a <see cref="T:NodaTime.ZonedDateTime"/>.
            </para>
            <para>See the <see cref="T:NodaTime.TimeZones.Resolvers" /> class for predefined implementations and a way of combining
            separate <see cref="T:NodaTime.TimeZones.SkippedTimeResolver" /> and <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver" /> values.</para>
            </remarks>
            <param name="mapping">The intermediate result of mapping a local time to a target time zone.</param>
            <exception cref="T:NodaTime.AmbiguousTimeException">The implementation rejects requests to map ambiguous times.</exception>
            <exception cref="T:NodaTime.SkippedTimeException">The implementation rejects requests to map skipped times.</exception>
            <returns>A <see cref="T:NodaTime.ZonedDateTime"/> in the target time zone.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.FixedDateTimeZone">
            <summary>
            Basic <see cref="T:NodaTime.DateTimeZone" /> implementation that has a fixed name key and offset i.e.
            no daylight savings.
            </summary>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.#ctor(NodaTime.Offset)">
            <summary>
            Creates a new fixed time zone.
            </summary>
            <remarks>The ID and name (for the <see cref="T:NodaTime.TimeZones.ZoneInterval"/>) are generated based on the offset.</remarks>
            <param name="offset">The <see cref="P:NodaTime.TimeZones.FixedDateTimeZone.Offset"/> from UTC.</param>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.#ctor(System.String,NodaTime.Offset)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.FixedDateTimeZone"/> class.
            </summary>
            <remarks>The name (for the <see cref="T:NodaTime.TimeZones.ZoneInterval"/>) is deemed to be the same as the ID.</remarks>
            <param name="id">The id.</param>
            <param name="offset">The offset.</param>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.#ctor(System.String,NodaTime.Offset,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.FixedDateTimeZone"/> class.
            </summary>
            <remarks>The name (for the <see cref="T:NodaTime.TimeZones.ZoneInterval"/>) is deemed to be the same as the ID.</remarks>
            <param name="id">The id.</param>
            <param name="offset">The offset.</param>
            <param name="name">The name to use in the sole <see cref="T:NodaTime.TimeZones.ZoneInterval"/> in this zone.</param>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.MakeId(NodaTime.Offset)">
            <summary>
            Makes the id for this time zone. The format is "UTC+/-Offset".
            </summary>
            <param name="offset">The offset.</param>
            <returns>The generated id string.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetFixedZoneOrNull(System.String)">
            <summary>
            Returns a fixed time zone for the given ID, which must be "UTC" or "UTC[offset]" where "[offset]" can be parsed
            using the "general" offset pattern.
            </summary>
            <param name="id">ID </param>
            <returns>The parsed time zone, or null if the ID doesn't match.</returns>
        </member>
        <member name="P:NodaTime.TimeZones.FixedDateTimeZone.Offset">
            <summary>
            Returns the fixed offset for this time zone.
            </summary>
            <returns>The fixed offset for this time zone.</returns>
        </member>
        <member name="P:NodaTime.TimeZones.FixedDateTimeZone.Name">
            <summary>
            Returns the name used for the zone interval for this time zone.
            </summary>
            <returns>The name used for the zone interval for this time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone interval for the given instant. This implementation always returns the same interval.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.MapLocal(NodaTime.LocalDateTime)">
            <summary>
            Override for efficiency: we know we'll always have an unambiguous mapping for any LocalDateTime.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetUtcOffset(NodaTime.Instant)">
            <summary>
            Returns the offset from UTC, where a positive duration indicates that local time is later
            than UTC. In other words, local time = UTC + offset.
            </summary>
            <param name="instant">The instant for which to calculate the offset.</param>
            <returns>
            The offset from UTC at the specified instant.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified writer.
            </summary>
            <param name="writer">The writer.</param>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.Read(NodaTime.TimeZones.IO.IDateTimeZoneReader,System.String)">
            <summary>
            Reads a fixed time zone from the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <param name="id">The id.</param>
            <returns>The fixed time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to.</param> 
            <filterpriority>2</filterpriority>
            <returns>True if the specified value is a <see cref="T:NodaTime.TimeZones.FixedDateTimeZone"/> with the same name, ID and offset; otherwise, false.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.GetHashCode">
            <summary>
            Computes the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.TimeZones.FixedDateTimeZone.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.IDateTimeZoneSource">
            <summary>
            Provides the interface for objects that can retrieve time zone definitions given an ID.
            </summary>
            <remarks>
            <para>
            The interface presumes that the available time zones are static; there is no mechanism for 
            updating the list of available time zones. Any time zone ID that is returned in <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds"/> 
            must be resolved by <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)"/> for the life of the source.
            </para>
            <para>
            Implementations need not cache time zones or the available time zone IDs. 
            Caching is typically provided by <see cref="T:NodaTime.TimeZones.DateTimeZoneCache"/>, which most consumers should use instead of
            consuming <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource"/> directly in order to get better performance.
            </para>
            <para>
            It is expected that any exceptions thrown are implementation-specific; nothing is explicitly
            specified in the interface. Typically this would be unusual to the point that callers would not
            try to catch them; any implementation which may break in ways that are sensible to catch should advertise
            this clearly, so that clients will know to handle the exceptions appropriately. No wrapper exception
            type is provided by Noda Time to handle this situation, and code in Noda Time does not try to catch
            such exceptions.
            </para>
            </remarks>
            <threadsafety>Implementations are not required to be thread-safe.</threadsafety>
        </member>
        <member name="M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds">
            <summary>
            Returns an unordered enumeration of the IDs available from this source.
            </summary>
            <remarks>
            <para>
            Every value in this enumeration must return a valid time zone from <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)"/> for the life of the source.
            The enumeration may be empty, but must not be null, and must not contain any elements which are null.  It
            should not contain duplicates: this is not enforced, and while it may not have a significant impact on
            clients in some cases, it is generally unfriendly.  The built-in implementations never return duplicates.
            </para>
            <para>
            The source is not required to provide the IDs in any particular order, although they should be distinct.
            </para>
            <para>
            Note that this list may optionally contain any of the fixed-offset timezones (with IDs "UTC" and
            "UTC+/-Offset"), but there is no requirement they be included.
            </para>
            </remarks>
            <returns>The IDs available from this source.</returns>
        </member>
        <member name="P:NodaTime.TimeZones.IDateTimeZoneSource.VersionId">
            <summary>
            Returns an appropriate version ID for diagnostic purposes, which must not be null.
            </summary>
            <remarks>
            This doesn't have any specific format; it's solely for diagnostic purposes.
            The included sources return strings of the format "source identifier: source version" indicating where the
            information comes from and which version of the source information has been loaded.
            </remarks>
            <value>An appropriate version ID for diagnostic purposes.</value>
        </member>
        <member name="M:NodaTime.TimeZones.IDateTimeZoneSource.ForId(System.String)">
            <summary>
            Returns the time zone definition associated with the given ID.
            </summary>
            <remarks>
            <para>
            Note that this is permitted to return a <see cref="T:NodaTime.DateTimeZone"/> that has a different ID to that
            requested, if the ID provided is an alias.
            </para>
            <para>
            Note also that this method is not required to return the same <see cref="T:NodaTime.DateTimeZone"/> instance for
            successive requests for the same ID; however, all instances returned for a given ID must compare as equal.
            </para>
            <para>
            It is advised that sources should document their behaviour regarding any fixed-offset timezones
            (i.e. "UTC" and "UTC+/-Offset") that are included in the list returned by <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds"/>.
            (These IDs will not be requested by <see cref="T:NodaTime.TimeZones.DateTimeZoneCache"/>, but any users calling
            into the source directly may care.)
            </para>
            <para>
            The source need not attempt to cache time zones; caching is typically provided by
            <see cref="T:NodaTime.TimeZones.DateTimeZoneCache"/>.
            </para>
            </remarks>
            <param name="id">The ID of the time zone to return. This must be one of the IDs
            returned by <see cref="M:NodaTime.TimeZones.IDateTimeZoneSource.GetIds"/>.</param>
            <returns>The <see cref="T:NodaTime.DateTimeZone"/> for the given ID.</returns>
            <exception cref="T:System.ArgumentException"><paramref name="id"/> is not supported by this source.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IDateTimeZoneSource.GetSystemDefaultId">
            <summary>
            Returns this source's ID for the system default time zone.
            </summary>
            <returns>
            The ID for the system default time zone for this source,
            or null if the system default time zone has no mapping in this source.
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.InvalidDateTimeZoneSourceException">
            <summary>
            Exception thrown to indicate that a time zone source has violated the contract of <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource"/>.
            This exception is primarily intended to be thrown from <see cref="T:NodaTime.TimeZones.DateTimeZoneCache"/>, and only in the face of a buggy
            source; user code should not usually need to be aware of this or catch it.
            </summary>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.TimeZones.InvalidDateTimeZoneSourceException.#ctor(System.String)">
            <summary>
            Creates a new instance with the given message.
            </summary>
            <param name="message">The message for the exception.</param>
        </member>
        <member name="T:NodaTime.TimeZones.IO.DateTimeZoneReader">
            <summary>
            Implementation of <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneReader"/> for the most recent version
            of the "blob" format of time zone data. If the format changes, this class will be
            renamed (e.g. to DateTimeZoneReaderV0) and the new implementation will replace it.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneReader.input">
            <summary>
            Raw stream to read from. Be careful before reading from this - you need to take
            account of bufferedByte as well.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneReader.stringPool">
            <summary>
            String pool to use, or null if no string pool is in use.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneReader.bufferedByte">
            <summary>
            Sometimes we need to buffer a byte in memory, e.g. to check if there is any
            more data. Anything reading directly from the stream should check here first.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadCount">
            <summary>
            Reads a non-negative integer value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteCount(System.Int32)" />.
            </remarks>
            <returns>The integer value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadSignedCount">
            <summary>
            Reads a (possibly-negative) integer value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteSignedCount(System.Int32)" />.
            </remarks>
            <returns>The integer value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadVarint">
            <summary>
            Reads a base-128 varint value from the stream.
            </summary>
            <remarks>
            The value must have been written by DateTimeZoneWriter.WriteVarint, which
            documents the format.
            </remarks>
            <returns>The integer value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadMilliseconds">
            <summary>
            Reads a number of milliseconds from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteMilliseconds(System.Int32)" />.
            </remarks>
            <returns>The offset value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadOffset">
            <summary>
            Reads an offset value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteOffset(NodaTime.Offset)" />.
            </remarks>
            <returns>The offset value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadDictionary">
            <summary>
            Reads a string to string dictionary value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})" />.
            </remarks>
            <returns>The <see cref="T:System.Collections.Generic.IDictionary`2" /> value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadZoneIntervalTransition(System.Nullable{NodaTime.Instant})">
            <summary>
            Reads an instant representing a zone interval transition from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteZoneIntervalTransition(System.Nullable{NodaTime.Instant},NodaTime.Instant)" />.
            </remarks>
            <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
            <returns>The instant read from the stream</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadString">
            <summary>
            Reads a string value from the stream.
            </summary>
            <remarks>
            The value must have been written by <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteString(System.String)" />.
            </remarks>
            <returns>The string value from the stream.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadInt16">
            <summary>
            Reads a signed 16 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 16 bit int value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadInt32">
            <summary>
            Reads a signed 32 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 32 bit int value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadInt64">
            <summary>
            Reads a signed 64 bit integer value from the stream and returns it as an long.
            </summary>
            <returns>The 64 bit long value.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneReader.ReadByte">
            <summary>
            Reads a signed 8 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 8 bit int value.</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data in the stream has been exhausted.</exception>
            <inheritdoc />
        </member>
        <member name="T:NodaTime.TimeZones.IO.DateTimeZoneWriter">
            <summary>
            Implementation of <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneWriter"/> for the most recent version
            of the "blob" format of time zone data. If the format changes, this class will be
            renamed (e.g. to DateTimeZoneWriterV0) and the new implementation will replace it.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneWriter.ZoneIntervalConstants.EpochForMinutesSinceEpoch">
            <summary>The instant to use as an 'epoch' when writing out a number of minutes-since-epoch.</summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneWriter.ZoneIntervalConstants.MarkerMinValue">
            <summary>The marker value representing the beginning of time.</summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneWriter.ZoneIntervalConstants.MarkerMaxValue">
            <summary>The marker value representing the end of time.</summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneWriter.ZoneIntervalConstants.MarkerRaw">
            <summary>The marker value representing an instant as a fixed 64-bit number of ticks.</summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneWriter.ZoneIntervalConstants.MinValueForHoursSincePrevious">
            <summary>The minimum varint value that represents an number of hours-since-previous.</summary>
            <remarks>Values below this are reserved for markers.</remarks>
        </member>
        <member name="F:NodaTime.TimeZones.IO.DateTimeZoneWriter.ZoneIntervalConstants.MinValueForMinutesSinceEpoch">
            <summary>The minimum varint value that represents an number of minutes since an epoch.</summary>
            <remarks>Values below this are interpreted as hours-since-previous (for a range of about 240 years),
            rather than minutes-since-epoch (for a range of about 4000 years)
            This choice is somewhat arbitrary, though it results in hour values always taking 2 (or
            occasionally 3) bytes when encoded as a varint, while minute values take 4 (or conceivably 5).</remarks>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.#ctor(System.IO.Stream,System.Collections.Generic.IList{System.String})">
            <summary>
            Constructs a DateTimeZoneWriter.
            </summary>
            <param name="output">Where to send the serialized output.</param>
            <param name="stringPool">String pool to add strings to, or null for no pool</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteCount(System.Int32)">
            <summary>
            Writes the given non-negative integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteSignedCount(System.Int32)">
            <summary>
            Writes the given (possibly-negative) integer value to the stream.
            </summary>
            <remarks>
            Unlike <see cref="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteCount(System.Int32)"/>, this can encode negative numbers. It does, however, use a slightly less
            efficient encoding for positive numbers.
            </remarks>
            <param name="count">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteVarint(System.UInt32)">
            <summary>
            Writes the given integer value to the stream as a base-128 varint.
            </summary>
            <remarks>
            The format is a simple 7-bit encoding: while the value is greater than 127 (i.e.
            has more than 7 significant bits) we repeatedly write the least-significant 7 bits
            with the top bit of the byte set as a continuation bit, then shift the value right
            7 bits.
            </remarks>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteOffset(NodaTime.Offset)">
            <summary>
            Writes the offset value to the stream.
            </summary>
            <param name="offset">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Writes the given dictionary of string to string to the stream.
            </summary>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IDictionary`2" /> to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteString(System.String)">
            <summary>
            Writes the string value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteInt16(System.Int16)">
            <summary>
            Writes the given 16 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteInt32(System.Int32)">
            <summary>
            Writes the given 32 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteInt64(System.Int64)">
            <summary>
            Writes the given 64 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:NodaTime.TimeZones.IO.DateTimeZoneWriter.WriteByte(System.Byte)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.TimeZones.IO.IDateTimeZoneReader">
            <summary>
            Interface for reading time-related data from a binary stream.
            This is similar to <see cref="T:System.IO.BinaryReader" />, but heavily
            oriented towards our use cases. 
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.IDateTimeZoneReader.HasMoreData">
            <summary>
            Returns whether or not there is more data in this stream.
            </summary>
            <value>Whether or not there is more data in the stream.</value>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadCount">
            <summary>
            Reads a non-negative integer from the stream, which must have been written
            by a call to <see cref="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteCount(System.Int32)"/>.
            </summary>
            <returns>The integer read from the stream</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadSignedCount">
            <summary>
            Reads a non-negative integer from the stream, which must have been written
            by a call to <see cref="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteSignedCount(System.Int32)"/>.
            </summary>
            <returns>The integer read from the stream</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadString">
            <summary>
            Reads a string from the stream.
            </summary>
            <returns>The string read from the stream; will not be null</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadByte">
            <summary>
            Reads a signed 8 bit integer value from the stream and returns it as an int.
            </summary>
            <returns>The 8 bit int value.</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data in the stream has been exhausted.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadMilliseconds">
            <summary>
            Reads a number of milliseconds from the stream.
            </summary>
            <returns>The number of milliseconds read from the stream</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadOffset">
            <summary>
            Reads an offset from the stream.
            </summary>
            <returns>The offset read from the stream</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadZoneIntervalTransition(System.Nullable{NodaTime.Instant})">
            <summary>
            Reads an instant representing a zone interval transition from the stream.
            </summary>
            <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
            <returns>The instant read from the stream</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneReader.ReadDictionary">
            <summary>
            Reads a string-to-string dictionary from the stream.
            </summary>
            <returns>The dictionary read from the stream</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The data was invalid.</exception>
            <exception cref="T:System.IO.IOException">The stream could not be read.</exception>
        </member>
        <member name="T:NodaTime.TimeZones.IO.IDateTimeZoneWriter">
            <summary>
            Interface for writing time-related data to a binary stream.
            This is similar to <see cref="T:System.IO.BinaryWriter" />, but heavily
            oriented towards our use cases.
            </summary>
            <remarks>
            <para>It is expected that the code reading data written by an implementation
            will be able to identify which implementation to use. As of Noda Time 2.0,
            there is only one implementation - but the interface will allow us to
            evolve the details of the binary structure independently of the code in the
            time zone implementations which knows how to write/read in terms of this interface
            and <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneReader"/>.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteCount(System.Int32)">
            <summary>
            Writes a non-negative integer to the stream. This is optimized towards
            cases where most values will be small.
            </summary>
            <param name="count">The integer to write to the stream.</param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> is negative.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteSignedCount(System.Int32)">
            <summary>
            Writes a possibly-negative integer to the stream. This is optimized for
            values of small magnitudes.
            </summary>
            <param name="count">The integer to write to the stream.</param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteString(System.String)">
            <summary>
            Writes a string to the stream.
            </summary>
            <remarks>Callers can reasonably expect that
            these values will be pooled in some fashion, so should not apply their own pooling.</remarks>
            <param name="value">The string to write to the stream.</param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteMilliseconds(System.Int32)">
            <summary>
            Writes a number of milliseconds to the stream, where the number
            of milliseconds must be in the range (-1 day, +1 day).
            </summary>
            <param name="millis">The number of milliseconds to write to the stream.</param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millis"/> is out of range.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteOffset(NodaTime.Offset)">
            <summary>
            Writes an offset to the stream.
            </summary>
            <param name="offset">The offset to write to the stream.</param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteZoneIntervalTransition(System.Nullable{NodaTime.Instant},NodaTime.Instant)">
            <summary>
            Writes an instant representing a zone interval transition to the stream.
            </summary>
            <remarks>
            This method takes a previously-written transition. Depending on the implementation, this value may be
            required by the reader in order to reconstruct the next transition, so it should be deterministic for any
            given value.
            </remarks>
            <param name="previous">The previous transition written (usually for a given timezone), or null if there is
            no previous transition.</param>
            <param name="value">The transition to write to the stream.</param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteDictionary(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Writes a string-to-string dictionary to the stream.
            </summary>
            <param name="dictionary"></param>
            <exception cref="T:System.IO.IOException">The value couldn't be written to the stream.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.IO.IDateTimeZoneWriter.WriteByte(System.Byte)">
            <summary>
            Writes the given 8 bit integer value to the stream.
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="T:NodaTime.TimeZones.IO.TzdbStreamData">
            <summary>
            Provides the raw data exposed by <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/>.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.TzdbVersion">
            <summary>
            Returns the TZDB version string.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.TzdbIdMap">
            <summary>
            Returns the TZDB ID dictionary (alias to canonical ID).
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.WindowsMapping">
            <summary>
            Returns the Windows mapping dictionary. (As the type is immutable, it can be exposed directly
            to callers.)
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.ZoneLocations">
            <summary>
            Returns the zone locations for the source, or null if no location data is available.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.IO.TzdbStreamData.Zone1970Locations">
            <summary>
            Returns the "zone 1970" locations for the source, or null if no such location data is available.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.IO.TzdbStreamData.CreateZone(System.String,System.String)">
            <summary>
            Creates the <see cref="T:NodaTime.DateTimeZone"/> for the given canonical ID, which will definitely
            be one of the values of the TzdbAliases dictionary.
            </summary>
            <param name="id">ID for the returned zone, which may be an alias.</param>
            <param name="canonicalId">Canonical ID for zone data</param>
        </member>
        <member name="T:NodaTime.TimeZones.IO.TzdbStreamData.Builder">
            <summary>
            Mutable builder class used during parsing.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.IO.TzdbStreamField">
            <summary>
            An unparsed field within a stream.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.IO.TzdbStreamField.CreateStream">
            <summary>
            Creates a new read-only stream over the data for this field.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.IO.TzdbStreamFieldId">
            <summary>
            Enumeration of the fields which can occur in a TZDB stream file.
            This enables the file to be self-describing to a reasonable extent.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.StringPool">
            <summary>
            String pool. Format is: number of strings (WriteCount) followed by that many string values.
            The indexes into the resultant list are used for other strings in the file, in some fields.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.TimeZone">
            <summary>
            Repeated field of time zones. Format is: zone ID, then zone as written by DateTimeZoneWriter.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.TzdbVersion">
            <summary>
            Single field giving the version of the TZDB source data. A string value which does *not* use the string pool.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.TzdbIdMap">
            <summary>
            Single field giving the mapping of ID to canonical ID, as written by DateTimeZoneWriter.WriteDictionary.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.CldrSupplementalWindowsZones">
            <summary>
            Single field containing mapping data as written by WindowsZones.Write.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.WindowsAdditionalStandardNameToIdMapping">
            <summary>
            Single field giving the mapping of Windows StandardName to TZDB canonical ID,
            for time zones where TimeZoneInfo.Id != TimeZoneInfo.StandardName,
            as written by DateTimeZoneWriter.WriteDictionary.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.ZoneLocations">
            <summary>
            Single field providing all zone locations. The format is simply a count, and then that many copies of
            TzdbZoneLocation data.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.IO.TzdbStreamFieldId.Zone1970Locations">
            <summary>
            Single field providing all "zone 1970" locations. The format is simply a count, and then that many copies of
            TzdbZone1970Location data. This field was introduced in Noda Time 2.0.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.IZoneIntervalMap">
            <summary>
            The core part of a DateTimeZone: mapping an Instant to an Interval.
            Separating this out into an interface allows for flexible caching.
            </summary>
            <remarks>
            Benchmarking shows that a delegate may be slightly faster here, but the difference
            isn't very significant even for very fast calls (cache hits). The interface ends up
            feeling slightly cleaner elsewhere in the code.
            </remarks>
        </member>
        <member name="T:NodaTime.TimeZones.PartialZoneIntervalMap">
            <summary>
            Like ZoneIntervalMap, representing just part of the time line. The intervals returned by this map
            are clamped to the portion of the time line being represented, to make it easier to work with.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.PartialZoneIntervalMap.Start">
            <summary>
            Start of the interval during which this map is valid.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.PartialZoneIntervalMap.End">
            <summary>
            End (exclusive) of the interval during which this map is valid.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PartialZoneIntervalMap.ForZoneInterval(System.String,NodaTime.Instant,NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Builds a PartialZoneIntervalMap for a single zone interval with the given name, start, end, wall offset and daylight savings.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PartialZoneIntervalMap.ForZoneInterval(NodaTime.TimeZones.ZoneInterval)">
            <summary>
            Builds a PartialZoneIntervalMap wrapping the given zone interval, taking its start and end as the start and end of
            the portion of the time line handled by the partial map.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.PartialZoneIntervalMap.IsSingleInterval">
            <summary>
            Returns true if this map only contains a single interval; that is, if the first interval includes the end of the map.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PartialZoneIntervalMap.WithStart(NodaTime.Instant)">
            <summary>
            Returns a partial zone interval map equivalent to this one, but with the given start point.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PartialZoneIntervalMap.WithEnd(NodaTime.Instant)">
            <summary>
            Returns a partial zone interval map equivalent to this one, but with the given end point.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PartialZoneIntervalMap.ConvertToFullMap(System.Collections.Generic.IEnumerable{NodaTime.TimeZones.PartialZoneIntervalMap})">
            <summary>
            Converts a sequence of PartialZoneIntervalMaps covering the whole time line into an IZoneIntervalMap.
            The partial maps are expected to be in order, with the start of the first map being Instant.BeforeMinValue,
            the end of the last map being Instant.AfterMaxValue, and each adjacent pair of maps abutting (i.e. current.End == next.Start).
            Zone intervals belonging to abutting maps but which are equivalent in terms of offset and name
            are coalesced in the resulting map.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.PartialZoneIntervalMap.CombinedPartialZoneIntervalMap">
            <summary>
            Implementation of IZoneIntervalMap used by ConvertToFullMap
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.PrecalculatedDateTimeZone">
            <summary>
            Most time zones have a relatively small set of transitions at their start until they finally 
            settle down to either a fixed time zone or a daylight savings time zone. This provides the
            container for the initial zone intervals and a pointer to the time zone that handles all of
            the rest until the end of time.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.PrecalculatedDateTimeZone.tailZoneStart">
            <summary>
            The first instant covered by the tail zone, or Instant.AfterMaxValue if there's no tail zone.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.#ctor(System.String,NodaTime.TimeZones.ZoneInterval[],NodaTime.TimeZones.IZoneIntervalMap)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.PrecalculatedDateTimeZone"/> class.
            </summary>
            <param name="id">The id.</param>
            <param name="intervals">The intervals before the tail zone.</param>
            <param name="tailZone">The tail zone - which can be any IZoneIntervalMap for normal operation,
            but must be a StandardDaylightAlternatingMap if the result is to be serialized.</param>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.ValidatePeriods(NodaTime.TimeZones.ZoneInterval[],NodaTime.TimeZones.IZoneIntervalMap)">
            <summary>
            Validates that all the periods before the tail zone make sense. We have to start at the beginning of time,
            and then have adjoining periods. This is only called in the constructors.
            </summary>
            <remarks>This is only called from the constructors, but is internal to make it easier to test.</remarks>
            <exception cref="T:System.ArgumentException">The periods specified are invalid.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone offset period for the given instant.
            </summary>
            <param name="instant">The Instant to find.</param>
            <returns>The ZoneInterval including the given instant.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified writer.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="M:NodaTime.TimeZones.PrecalculatedDateTimeZone.Read(NodaTime.TimeZones.IO.IDateTimeZoneReader,System.String)">
            <summary>
            Reads a time zone from the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <param name="id">The id.</param>
            <returns>The time zone.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.Resolvers">
            <summary>
            Commonly-used implementations of the delegates used in resolving a <see cref="T:NodaTime.LocalDateTime"/> to a
            <see cref="T:NodaTime.ZonedDateTime"/>, and a method to combine two "partial" resolvers into a full one.
            </summary>
            <remarks>
            <para>
            This class contains predefined implementations of <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/>,
            <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/>, and <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/>, along with
            <see cref="M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)"/>, which produces a <c>ZoneLocalMappingResolver</c> from instances of the
            other two.
            </para>
            </remarks>
            <threadsafety>All members of this class are thread-safe, as are the values returned by them.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.Resolvers.ReturnEarlier">
            <summary>
            An <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/> which returns the earlier of the two matching times.
            </summary>
            <value>An <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/> which returns the earlier of the two matching times.</value>
        </member>
        <member name="P:NodaTime.TimeZones.Resolvers.ReturnLater">
            <summary>
            An <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/> which returns the later of the two matching times.
            </summary>
            <value>An <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/> which returns the later of the two matching times.</value>
        </member>
        <member name="P:NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous">
            <summary>
            An <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/> which simply throws an <see cref="T:NodaTime.AmbiguousTimeException"/>.
            </summary>
            <value>An <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/> which simply throws an <see cref="T:NodaTime.AmbiguousTimeException"/>.</value>
        </member>
        <member name="P:NodaTime.TimeZones.Resolvers.ReturnEndOfIntervalBefore">
            <summary>
            A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> which returns the final tick of the time zone interval
            before the "gap".
            </summary>
            <value>A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> which returns the final tick of the time zone interval
            before the "gap".</value>
        </member>
        <member name="P:NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter">
            <summary>
            A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> which returns the first tick of the time zone interval
            after the "gap".
            </summary>
            <value>
            A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> which returns the first tick of the time zone interval
            after the "gap".
            </value>
        </member>
        <member name="P:NodaTime.TimeZones.Resolvers.ReturnForwardShifted">
            <summary>
            A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> which shifts values in the "gap" forward by the duration
            of the gap (which is usually 1 hour). This corresponds to the instant that would have occured,
            had there not been a transition.
            </summary>
            <value>
            A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> which shifts values in the "gap" forward by the duration
            of the gap (which is usually 1 hour). 
            </value>
        </member>
        <member name="P:NodaTime.TimeZones.Resolvers.ThrowWhenSkipped">
            <summary>
            A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> which simply throws a <see cref="T:NodaTime.SkippedTimeException"/>.
            </summary>
            <value>A <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> which simply throws a <see cref="T:NodaTime.SkippedTimeException"/>.</value>
        </member>
        <member name="P:NodaTime.TimeZones.Resolvers.StrictResolver">
            <summary>
            A <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/> which only ever succeeds in the (usual) case where the result
            of the mapping is unambiguous.
            </summary>
            <remarks>
            If the mapping is ambiguous or skipped, this throws <see cref="T:NodaTime.SkippedTimeException"/> or
            <see cref="T:NodaTime.AmbiguousTimeException"/>, as appropriate. This resolver combines
            <see cref="P:NodaTime.TimeZones.Resolvers.ThrowWhenAmbiguous"/> and <see cref="P:NodaTime.TimeZones.Resolvers.ThrowWhenSkipped"/>.
            </remarks>
            <seealso cref="M:NodaTime.DateTimeZone.AtStrictly(NodaTime.LocalDateTime)"/>
            <value>A <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/> which only ever succeeds in the (usual) case where the result
            of the mapping is unambiguous.</value>
        </member>
        <member name="P:NodaTime.TimeZones.Resolvers.LenientResolver">
            <summary>
            A <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/> which never throws an exception due to ambiguity or skipped time.
            </summary>
            <remarks>
            Ambiguity is handled by returning the earlier occurrence, and skipped times are shifted forward by the duration
            of the gap. This resolver combines <see cref="P:NodaTime.TimeZones.Resolvers.ReturnEarlier"/> and <see cref="P:NodaTime.TimeZones.Resolvers.ReturnForwardShifted"/>.
            <para>Note: The behavior of this resolver was changed in version 2.0 to fit the most commonly seen real-world
            usage pattern.  Previous versions combined the <see cref="P:NodaTime.TimeZones.Resolvers.ReturnLater"/> and <see cref="P:NodaTime.TimeZones.Resolvers.ReturnStartOfIntervalAfter"/>
            resolvers, which can still be used separately if desired.</para>
            </remarks>
            <seealso cref="M:NodaTime.DateTimeZone.AtLeniently(NodaTime.LocalDateTime)"/>
            <value>A <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/> which never throws an exception due to ambiguity or skipped time.</value>
        </member>
        <member name="M:NodaTime.TimeZones.Resolvers.CreateMappingResolver(NodaTime.TimeZones.AmbiguousTimeResolver,NodaTime.TimeZones.SkippedTimeResolver)">
            <summary>
            Combines an <see cref="T:NodaTime.TimeZones.AmbiguousTimeResolver"/> and a <see cref="T:NodaTime.TimeZones.SkippedTimeResolver"/> to create a
            <see cref="T:NodaTime.TimeZones.ZoneLocalMappingResolver"/>.
            </summary>
            <remarks>
            The <c>ZoneLocalMappingResolver</c> created by this method operates in the obvious way: unambiguous mappings
            are returned directly, ambiguous mappings are delegated to the given <c>AmbiguousTimeResolver</c>, and
            "skipped" mappings are delegated to the given <c>SkippedTimeResolver</c>.
            </remarks>
            <param name="ambiguousTimeResolver">Resolver to use for ambiguous mappings.</param>
            <param name="skippedTimeResolver">Resolver to use for "skipped" mappings.</param>
            <returns>The logical combination of the two resolvers.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.SingleZoneIntervalMap">
            <summary>
            Implementation of IZoneIntervalMap which just returns a single interval (provided on construction) regardless of
            the instant requested.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.StandardDaylightAlternatingMap">
            <summary>
            Provides a zone interval map representing an infinite sequence of standard/daylight
            transitions from a pair of rules.
            </summary>
            <remarks>
            IMPORTANT: This class *accepts* recurrences which start from a particular year
            rather than being infinite back to the start of time, but *treats* them as if
            they were infinite. This makes various calculations easier, but this map should
            only be used as part of a zone which will only ask it for values within the right
            portion of the timeline.
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.StandardDaylightAlternatingMap.#ctor(NodaTime.Offset,NodaTime.TimeZones.ZoneRecurrence,NodaTime.TimeZones.ZoneRecurrence)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.StandardDaylightAlternatingMap"/> class.
            </summary>
            <remarks>
            At least one of the recurrences (it doesn't matter which) must be a "standard", i.e. not have any savings
            applied. The other may still not have any savings (e.g. for America/Resolute) or (for BCL compatibility) may
            even have negative daylight savings.
            </remarks>
            <param name="standardOffset">The standard offset.</param>
            <param name="startRecurrence">The start recurrence.</param>
            <param name="endRecurrence">The end recurrence.</param>
        </member>
        <member name="M:NodaTime.TimeZones.StandardDaylightAlternatingMap.GetZoneInterval(NodaTime.Instant)">
            <summary>
            Gets the zone interval for the given instant.
            </summary>
            <param name="instant">The Instant to test.</param>
            <returns>The ZoneInterval in effect at the given instant.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The instant falls outside the bounds
            of the recurrence rules of the zone.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.StandardDaylightAlternatingMap.NextTransition(NodaTime.Instant,NodaTime.TimeZones.ZoneRecurrence@)">
            <summary>
            Returns the transition occurring strictly after the specified instant. The <paramref name="recurrence"/>
            parameter will be populated with the recurrence the transition goes *from*.
            </summary>
            <param name="instant">The instant after which to consider transitions.</param>
            <param name="recurrence">Receives the savings offset for the transition.</param>
        </member>
        <member name="M:NodaTime.TimeZones.StandardDaylightAlternatingMap.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
            <summary>
            Writes the time zone to the specified writer.
            </summary>
            <param name="writer">The writer to write to.</param>
        </member>
        <member name="T:NodaTime.TimeZones.TimeZoneInfoInterceptor">
            <summary>
            Interception for TimeZoneInfo static methods. These are still represented as
            static methods in this class, but they're implemented via a replaceable shim, which
            by default delegates to the static methods in TimeZoneInfo.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.TimeZoneInfoInterceptor.Shim">
            <summary>
            The shim to use for all the static methods. We don't care about thread safety here,
            beyond "it must be correct when used in production" - it's only ever changed in tests,
            which are single-threaded anyway.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.TimeZoneInfoInterceptor.BclShim">
            <summary>
            Implementation that just delegates in a simple manner.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.Transition">
            <summary>
            A transition between two offsets, usually for daylight saving reasons. This type only knows about
            the new offset, and the transition point.
            </summary>
            
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.Transition.NewOffset">
            <summary>
            The offset from the time when this transition occurs until the next transition.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.op_Equality(NodaTime.TimeZones.Transition,NodaTime.TimeZones.Transition)">
            <summary>
            Implements the operator == (equality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.op_Inequality(NodaTime.TimeZones.Transition,NodaTime.TimeZones.Transition)">
            <summary>
            Implements the operator != (inequality).
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.Transition.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.TransitionMode">
            <summary>
            Specifies how transitions are calculated. Whether relative to UTC, the time zones standard
            offset, or the wall (or daylight savings) offset.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TransitionMode.Utc">
            <summary>
            Calculate transitions against UTC.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TransitionMode.Wall">
            <summary>
            Calculate transitions against wall offset.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TransitionMode.Standard">
            <summary>
            Calculate transitions against standard offset.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.TzdbDateTimeZoneSource">
            <summary>
            Provides an implementation of <see cref="T:NodaTime.TimeZones.IDateTimeZoneSource" /> that loads data originating from the
            <a href="https://www.iana.org/time-zones">tz database</a> (also known as the IANA Time Zone database, or zoneinfo
            or Olson database).
            </summary>
            <remarks>
            All calls to <see cref="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String)"/> for fixed-offset IDs advertised by the source (i.e. "UTC" and "UTC+/-Offset")
            will return zones equal to those returned by <see cref="M:NodaTime.DateTimeZone.ForOffset(NodaTime.Offset)"/>.
            </remarks>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Default">
            <summary>
            Gets the <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/> initialised from resources within the NodaTime assembly.
            </summary>
            <value>The source initialised from resources within the NodaTime assembly.</value>
        </member>
        <member name="F:NodaTime.TimeZones.TzdbDateTimeZoneSource.source">
            <summary>
            Original source data - we delegate to this to create actual DateTimeZone instances,
            and for windows mappings.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.TzdbDateTimeZoneSource.version">
            <summary>
            Composite version ID including TZDB and Windows mapping version strings.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Aliases">
            <summary>
            Gets a lookup from canonical time zone ID (e.g. "Europe/London") to a group of aliases for that time zone
            (e.g. {"Europe/Belfast", "Europe/Guernsey", "Europe/Jersey", "Europe/Isle_of_Man", "GB", "GB-Eire"}).
            </summary>
            <remarks>
            The group of values for a key never contains the canonical ID, only aliases. Any time zone
            ID which is itself an alias or has no aliases linking to it will not be present in the lookup.
            The aliases within a group are returned in alphabetical (ordinal) order.
            </remarks>
            <value>A lookup from canonical ID to the aliases of that ID.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.CanonicalIdMap">
            <summary>
            Returns a read-only map from time zone ID to the canonical ID. For example, the key "Europe/Jersey"
            would be associated with the value "Europe/London".
            </summary>
            <remarks>
            <para>This map contains an entry for every ID returned by <see cref="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds"/>, where
            canonical IDs map to themselves.</para>
            <para>The returned map is read-only; any attempts to call a mutating method will throw
            <see cref="T:System.NotSupportedException" />.</para>
            </remarks>
            <value>A map from time zone ID to the canonical ID.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations">
            <summary>
            Gets a read-only list of zone locations known to this source, or null if the original source data
            does not include zone locations.
            </summary>
            <remarks>
            Every zone location's time zone ID is guaranteed to be valid within this source (assuming the source
            has been validated).
            </remarks>
            <value>A read-only list of zone locations known to this source.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.Zone1970Locations">
            <summary>
            Gets a read-only list of "zone 1970" locations known to this source, or null if the original source data
            does not include zone locations.
            </summary>
            <remarks>
            <p>
            This location data differs from <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.ZoneLocations"/> in two important respects:
            <ul>
              <li>Where multiple similar zones exist but only differ in transitions before 1970,
                this location data chooses one zone to be the canonical "post 1970" zone.
              </li>
              <li>
                This location data can represent multiple ISO-3166 country codes in a single entry. For example,
                the entry corresponding to "Europe/London" includes country codes GB, GG, JE and IM (Britain,
                Guernsey, Jersey and the Isle of Man, respectively).
              </li>
            </ul>
            </p>
            <p>
            Every zone location's time zone ID is guaranteed to be valid within this source (assuming the source
            has been validated).
            </p>
            </remarks>
            <value>A read-only list of zone locations known to this source.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.VersionId">
            <inheritdoc />
            <remarks>
            <para>
            This source returns a string such as "TZDB: 2013b (mapping: 8274)" corresponding to the versions of the tz
            database and the CLDR Windows zones mapping file.
            </para>
            <para>
            Note that there is no need to parse this string to extract any of the above information, as it is available
            directly from the <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion"/> and <see cref="P:NodaTime.TimeZones.Cldr.WindowsZones.Version"/> properties.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.FromStream(System.IO.Stream)">
            <summary>
            Creates an instance from a stream in the custom Noda Time format. The stream must be readable.
            </summary>
            <remarks>
            <para>
            The stream is not closed by this method, but will be read from
            without rewinding. A successful call will read the stream to the end.
            </para>
            <para>
            See the user guide for instructions on how to generate an updated time zone database file from a copy of the
            (textual) tz database.
            </para>
            </remarks>
            <param name="stream">The stream containing time zone data</param>
            <returns>A <c>TzdbDateTimeZoneSource</c> providing information from the given stream.</returns>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The stream contains invalid time zone data, or data which cannot
            be read by this version of Noda Time.</exception>
            <exception cref="T:System.IO.IOException">Reading from the stream failed.</exception>
            <exception cref="T:System.InvalidOperationException">The supplied stream doesn't support reading.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.BuildTzdbToWindowsIdMap">
            <summary>
            Builds the dictionary returned by <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbToWindowsIds"/>; this is called lazily.
            This method assumes the source is valid, for uniqueness purposes etc.
            /// </summary>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.BuildWindowsToTzdbId">
            <summary>
            Builds the dictionary returned by <see cref="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsToTzdbIds"/>; this is called lazily.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.ForId(System.String)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.GetIds">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.GetSystemDefaultId">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.GuessZoneIdByTransitionsUncached(System.TimeZoneInfo,System.Collections.Generic.List{NodaTime.DateTimeZone})">
            <summary>
            In cases where we can't get a zone mapping directly, we try to work out a good fit
            by checking the transitions within the next few years.
            This can happen if the Windows data isn't up-to-date, or if we're on a system where
            TimeZoneInfo.Local.Id just returns "local", or if TimeZoneInfo.Local is a custom time
            zone for some reason. We return null if we don't get a 70% hit rate.
            We look at all transitions in all canonical IDs for the next 5 years.
            Heuristically, this seems to be good enough to get the right results in most cases.
            This method used to only be called in the PCL build in 1.x, but it seems reasonable enough to
            call it if we can't get an exact match anyway.
            </summary>
            <param name="zone">Zone to resolve in a best-effort fashion.</param>
            <param name="candidates">All the Noda Time zones to consider - normally a list 
            obtained from this source.</param>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbVersion">
            <summary>
            Gets just the TZDB version (e.g. "2013a") of the source data.
            </summary>
            <value>The TZDB version (e.g. "2013a") of the source data.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsMapping">
            <summary>
            Gets the Windows time zone mapping information provided in the CLDR
            supplemental "windowsZones.xml" file.
            </summary>
            <value>The Windows time zone mapping information provided in the CLDR
            supplemental "windowsZones.xml" file.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.TzdbToWindowsIds">
            <summary>
            Returns a dictionary mapping TZDB IDs to Windows IDs.
            </summary>
            <remarks>
            <para>
            Where a TZDB alias isn't present directly in the Windows mapping, but its canonical ID is,
            the dictionary will contain an entry for the alias as well. For example, the TZDB ID
            "Africa/Asmara" is an alias for "Africa/Nairobi", which has a Windows ID of "E. Africa Standard Time".
            "Africa/Asmara" doesn't appear in the Windows mapping directly, but it will still be present in the
            returned dictionary.
            </para>
            <para>
            Where a TZDB canonical ID isn't present in the Windows mapping, but an alias is, the dictionary
            will contain an entry for the canonical ID as well. For example, the Windows mapping uses the
            TZDB ID "Asia/Calcutta" for "India Standard Time". This is an alias for "Asia/Kolkata" in TZDB,
            so the returned dictionary will have an entry mapping "Asia/Kolkata" to "Asia/Calcutta".
            If multiple aliases for the same canonical ID have entries in the Windows mapping with different
            Windows IDs, the alias that is earliest in lexicographical ordering determines the value for the entry.
            </para>
            <para>
            If a canonical ID is not present in the mapping, nor any of its aliases, it will not be present in
            the returned dictionary.
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbDateTimeZoneSource.WindowsToTzdbIds">
            <summary>
            Returns a dictionary mapping Windows IDs to canonical TZDB IDs, using the
            primary mapping in each <see cref="T:NodaTime.TimeZones.Cldr.MapZone"/>.
            </summary>
            <remarks>
            Sometimes the Windows mapping contains values which are not canonical TZDB IDs.
            Every value in the returned dictionary is a canonical ID. For example, the Windows
            mapping contains as "Asia/Calcutta" for the Windows ID "India Standard Time", but
            "Asia/Calcutta" is an alias for "Asia/Kolkata". The entry for "India Standard Time"
            in the returned dictionary therefore has "Asia/Kolkata" as the value.
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbDateTimeZoneSource.Validate">
            <summary>
            Validates that the data within this source is consistent with itself.
            </summary>
            <remarks>
            Source data is not validated automatically when it's loaded, but any source
            loaded from data produced by <c>NodaTime.TzdbCompiler</c> (including the data shipped with Noda Time)
            will already have been validated via this method when it was originally produced. This method should
            only normally be called explicitly if you have data from a source you're unsure of.
            </remarks>
            <exception cref="T:NodaTime.Utility.InvalidNodaDataException">The source data is invalid. The source may not function
            correctly.</exception>
        </member>
        <member name="T:NodaTime.TimeZones.TzdbZone1970Location">
            <summary>
            A location entry generated from the "zone1970.tab" file in a TZDB release. This can be used to provide
            users with a choice of time zone, although it is not internationalized. This is equivalent to
            <see cref="T:NodaTime.TimeZones.TzdbZoneLocation"/>, except that multiple countries may be represented.
            </summary>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZone1970Location.Latitude">
            <summary>
            Gets the latitude in degrees; positive for North, negative for South.
            </summary>
            <remarks>The value will be in the range [-90, 90].</remarks>
            <value>The latitude in degrees; positive for North, negative for South.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZone1970Location.Longitude">
            <summary>
            Gets the longitude in degrees; positive for East, negative for West.
            </summary>
            <remarks>The value will be in the range [-180, 180].</remarks>
            <value>The longitude in degrees; positive for East, negative for West.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZone1970Location.Countries">
            <summary>
            Gets the list of countries associated with this location.
            </summary>
            <remarks>
            The list is immutable, and will always contain at least one entry. The list is
            in the order specified in "zone1970.tab", so the first entry is always the
            country containing the position indicated by the latitude and longitude, and
            is the most populous country in the list. No entry in this list is ever null.
            </remarks>
            <value>The list of countries associated with this location</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZone1970Location.ZoneId">
            <summary>
            The ID of the time zone for this location.
            </summary>
            <remarks>If this mapping was fetched from a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/>, it will always be a valid ID within that source.
            </remarks>
            <value>The ID of the time zone for this location.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZone1970Location.Comment">
            <summary>
            Gets the comment (in English) for the mapping, if any.
            </summary>
            <remarks>
            This is usually used to differentiate between locations in the same country.
            This will return an empty string if no comment was provided in the original data.
            </remarks>
            <value>The comment (in English) for the mapping, if any.</value>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbZone1970Location.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{NodaTime.TimeZones.TzdbZone1970Location.Country},System.String,System.String)">
            <summary>
            Creates a new location.
            </summary>
            <remarks>This constructor is only public for the sake of testability. Non-test code should
            usually obtain locations from a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/>.
            </remarks>
            <param name="latitudeSeconds">Latitude of the location, in seconds.</param>
            <param name="longitudeSeconds">Longitude of the location, in seconds.</param>
            <param name="countries">Countries associated with this location. Must not be null, must have at least
            one entry, and all entries must be non-null.</param>
            <param name="zoneId">Time zone identifier of the location. Must not be null.</param>
            <param name="comment">Optional comment. Must not be null, but may be empty.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The latitude or longitude is invalid.</exception>
        </member>
        <member name="T:NodaTime.TimeZones.TzdbZone1970Location.Country">
            <summary>
            A country represented within an entry in the "zone1970.tab" file, with the English name
            mapped from the "iso3166.tab" file.
            </summary>
            <remarks>
            <para>Equality is defined component-wise: two values are considered equal if their country names are equal to
            each other, and their country codes are equal to each other.</para>
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZone1970Location.Country.Name">
            <summary>
            Gets the English name of the country.
            </summary>
            <value>The English name of the country.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZone1970Location.Country.Code">
            <summary>
            Gets the ISO-3166 2-letter country code for the country.
            </summary>
            <value>The ISO-3166 2-letter country code for the country.</value>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbZone1970Location.Country.#ctor(System.String,System.String)">
            <summary>
            Constructs a new country from its name and ISO-3166 2-letter code.
            </summary>
            <param name="name">Country name; must not be empty.</param>
            <param name="code">2-letter code</param>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbZone1970Location.Country.Equals(NodaTime.TimeZones.TzdbZone1970Location.Country)">
            <summary>
            Compares countries for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="other">The country to compare with this one.</param>
            <returns><c>true</c> if the given country has the same name and code as this one; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbZone1970Location.Country.Equals(System.Object)">
            <summary>
            Compares countries for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The object to compare this one with.</param>
            <returns><c>true</c> if the given object is a country with the same name and code as this one; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbZone1970Location.Country.GetHashCode">
            <summary>
            Returns a hash code for this country.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>A hash code for this country.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbZone1970Location.Country.ToString">
            <summary>
            Returns a string representation of this country, including the code and name.
            </summary>
            <returns>A string representation of this country.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.TzdbZoneLocation">
            <summary>
            A location entry generated from the "zone.tab" file in a TZDB release. This can be used to provide
            users with a choice of time zone, although it is not internationalized.
            </summary>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZoneLocation.Latitude">
            <summary>
            Gets the latitude in degrees; positive for North, negative for South.
            </summary>
            <remarks>The value will be in the range [-90, 90].</remarks>
            <value>The latitude in degrees; positive for North, negative for South.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZoneLocation.Longitude">
            <summary>
            Gets the longitude in degrees; positive for East, negative for West.
            </summary>
            <remarks>The value will be in the range [-180, 180].</remarks>
            <value>The longitude in degrees; positive for East, negative for West.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZoneLocation.CountryName">
            <summary>
            Gets the English name of the country containing the location, which is never empty.
            </summary>
            <value>The English name of the country containing the location.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZoneLocation.CountryCode">
            <summary>
            Gets the ISO-3166 2-letter country code for the country containing the location.
            </summary>
            <value>The ISO-3166 2-letter country code for the country containing the location.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZoneLocation.ZoneId">
            <summary>
            The ID of the time zone for this location.
            </summary>
            <remarks>If this mapping was fetched from a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/>, it will always be a valid ID within that source.
            </remarks>
            <value>The ID of the time zone for this location.</value>
        </member>
        <member name="P:NodaTime.TimeZones.TzdbZoneLocation.Comment">
            <summary>
            Gets the comment (in English) for the mapping, if any.
            </summary>
            <remarks>
            This is usually used to differentiate between locations in the same country.
            This will return an empty string if no comment was provided in the original data.
            </remarks>
            <value>The comment (in English) for the mapping, if any.</value>
        </member>
        <member name="M:NodaTime.TimeZones.TzdbZoneLocation.#ctor(System.Int32,System.Int32,System.String,System.String,System.String,System.String)">
            <summary>
            Creates a new location.
            </summary>
            <remarks>This constructor is only public for the sake of testability. Non-test code should
            usually obtain locations from a <see cref="T:NodaTime.TimeZones.TzdbDateTimeZoneSource"/>.
            </remarks>
            <param name="latitudeSeconds">Latitude of the location, in seconds.</param>
            <param name="longitudeSeconds">Longitude of the location, in seconds.</param>
            <param name="countryName">English country name of the location, in degrees. Must not be null.</param>
            <param name="countryCode">ISO-3166 country code of the location. Must not be null.</param>
            <param name="zoneId">Time zone identifier of the location. Must not be null.</param>
            <param name="comment">Optional comment. Must not be null, but may be empty.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The latitude or longitude is invalid.</exception>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneEqualityComparer">
            <summary>
            Equality comparer for time zones, comparing specific aspects of the zone intervals within
            a time zone for a specific interval of the time line.
            </summary>
            <remarks>
            The default behaviour of this comparator is to consider two time zones to be equal if they share the same wall
            offsets at all points within a given time interval, regardless of other aspects of each
            <see cref="T:NodaTime.TimeZones.ZoneInterval"/> within the two time zones. This behaviour can be changed using the
            <see cref="M:NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)"/> method.
            </remarks>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneEqualityComparer.Options">
            <summary>
            Options to use when comparing time zones for equality. Each option makes the comparison more restrictive.
            </summary>
            <remarks>
            <para>
            By default, the comparer only compares the wall offset (total of standard offset and any daylight saving offset)
            at every instant within the interval over which the comparer operates. In practice, this is done by comparing each
            <see cref="T:NodaTime.TimeZones.ZoneInterval"/> which includes an instant within the interval (using <see cref="M:NodaTime.DateTimeZone.GetZoneIntervals(NodaTime.Interval)"/>).
            For most purposes, this is all that's required: from the simple perspective of a time zone being just a function from instants to local time,
            the default option of <see cref="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset"/> effectively checks that the function gives the same result across the two time
            zones being compared, for any given instant within the interval.
            </para>
            <para>
            It's possible for a time zone to have a transition from one <c>ZoneInterval</c> to another which doesn't adjust the offset: it
            might just change the name, or the balance between standard offset to daylight saving offset. (As an example, at midnight local
            time on October 27th 1968, the Europe/London time zone went from a standard offset of 0 and a daylight saving offset of 1 hour
            to a standard offset of 1 and a daylight saving offset of 0... which left the clocks unchanged.) This transition is irrelevant
            to the default options, so the two zone intervals involved are effectively coalesced.
            </para>
            <para>
            The options available change what sort of comparison is performed - which can also change which zone intervals can be coalesced. For
            example, by specifying just the <see cref="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions"/> option, you would indicate that even though you don't care about the name within a zone
            interval or how the wall offset is calculated, you do care about the fact that there was a transition at all, and when it occurred.
            With that option enabled, zone intervals are never coalesced and the transition points within the operating interval are checked.
            </para>
            <para>Similarly, the <see cref="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions"/> option is the only one where instants outside the operating interval are
            relevant. For example, consider a comparer which operates over the interval [2000-01-01T00:00:00Z, 2011-01-01T00:00:00Z). Normally,
            anything that happens before the year 2000 (UTC) would be irrelevant - but with this option enabled, the transitions of the first and last zone
            intervals are part of the comparison... so if one time zone has a zone interval 1999-09-01T00:00:00Z to 2000-03-01T00:00:00Z and the other has
            a zone interval 1999-10-15T00:00:00Z to 2000-03-01T00:00:Z, the two zones would be considered unequal, despite the fact that the only instants observing
            the difference occur outside the operating interval.
            </para>
            </remarks>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.OnlyMatchWallOffset">
            <summary>
            The default comparison, which only cares about the wall offset at any particular
            instant, within the interval of the comparer. In other words, if <see cref="M:NodaTime.DateTimeZone.GetUtcOffset(NodaTime.Instant)"/>
            returns the same value for all instants in the interval, the comparer will consider the zones to be equal.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchOffsetComponents">
            <summary>
            Instead of only comparing wall offsets, the standard/savings split is also considered. So when this
            option is used, two zones which both have a wall offset of +2 at one instant would be considered
            unequal if one of those offsets was +1 standard, +1 savings and the other was +2 standard with no daylight
            saving.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchNames">
            <summary>
            Compare the names of zone intervals as well as offsets.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchAllTransitions">
            <summary>
            This option prevents adjacent zone intervals from being coalesced, even if they are otherwise considered
            equivalent according to other options.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.MatchStartAndEndTransitions">
            <summary>
            Includes the transitions into the first zone interval and out of the
            last zone interval as part of the comparison, even if they do not affect
            the offset or name for any instant within the operating interval.
            </summary>
        </member>
        <member name="F:NodaTime.TimeZones.ZoneEqualityComparer.Options.StrictestMatch">
            <summary>
            The combination of all available match options.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.CheckOption(NodaTime.TimeZones.ZoneEqualityComparer.Options,NodaTime.TimeZones.ZoneEqualityComparer.Options)">
            <summary>
            Checks whether the given set of options includes the candidate one. This would be an extension method, but
            that causes problems on Mono at the moment.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneEqualityComparer.IntervalForTest">
            <summary>
            Returns the interval over which this comparer operates.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneEqualityComparer.OptionsForTest">
            <summary>
            Returns the options used by this comparer.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.#ctor(NodaTime.Interval,NodaTime.TimeZones.ZoneEqualityComparer.Options)">
            <summary>
            Creates a new comparer for the given interval, with the given comparison options.
            </summary>
            <param name="interval">The interval within the time line to use for comparisons.</param>
            <param name="options">The options to use when comparing time zones.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified options are invalid.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.ForInterval(NodaTime.Interval)">
            <summary>
            Returns a <see cref="T:NodaTime.TimeZones.ZoneEqualityComparer"/> for the given interval with the default options.
            </summary>
            <remarks>
            The default behaviour of this comparator is to consider two time zones to be equal if they share the same wall
            offsets at all points within a given interval.
            To specify non-default options, call the <see cref="M:NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)"/> method on the result
            of this method.</remarks>
            <param name="interval">The interval over which to compare time zones. This must have both a start and an end.</param>
            <returns>A ZoneEqualityComparer for the given interval with the default options.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.WithOptions(NodaTime.TimeZones.ZoneEqualityComparer.Options)">
            <summary>
            Returns a comparer operating over the same interval as this one, but with the given
            set of options.
            </summary>
            <remarks>
            This method does not modify the comparer on which it's called.
            </remarks>
            <param name="options">New set of options, which must consist of flags defined within the <see cref="T:NodaTime.TimeZones.ZoneEqualityComparer.Options"/> enum.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">The specified options are invalid.</exception>
            <returns>A comparer operating over the same interval as this one, but with the given set of options.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.Equals(NodaTime.DateTimeZone,NodaTime.DateTimeZone)">
            <summary>
            Compares two time zones for equality according to the options and interval provided to this comparer.
            </summary>
            <param name="x">The first <see cref="T:NodaTime.DateTimeZone"/> to compare.</param>
            <param name="y">The second <see cref="T:NodaTime.DateTimeZone"/> to compare.</param>
            <returns><c>true</c> if the specified time zones are equal under the options and interval of this comparer; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.GetHashCode(NodaTime.DateTimeZone)">
            <summary>
            Returns a hash code for the specified time zone.
            </summary>
            <remarks>
            The hash code generated by any instance of <c>ZoneEqualityComparer</c> will be equal to the hash code
            generated by any other instance constructed with the same options and interval, for the same time zone (or equal ones).
            Two instances of <c>ZoneEqualityComparer</c> with different options or intervals may (but may not) produce
            different hash codes for the same zone.
            </remarks>
            <param name="obj">The time zone to compute a hash code for.</param>
            <returns>A hash code for the specified object.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneEqualityComparer.ZoneIntervalEqualityComparer.EqualExceptStartAndEnd(NodaTime.TimeZones.ZoneInterval,NodaTime.TimeZones.ZoneInterval)">
            <summary>
            Compares the parts of two zone intervals which are deemed "interesting" by the options.
            The wall offset is always compared, regardless of options, but the start/end points are
            never compared.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneInterval">
            <summary>
            Represents a range of time for which a particular Offset applies.
            </summary>
            <remarks>
            <para>
            Equality is defined component-wise in terms of all properties: the name, the start and end, and the offsets.
            There is no ordering defined between zone intervals.
            </para>
            </remarks>
            <threadsafety>This type is an immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.RawStart">
            <summary>
            Returns the underlying start instant of this zone interval. If the zone interval extends to the
            beginning of time, the return value will be <see cref="F:NodaTime.Instant.BeforeMinValue"/>; this value
            should *not* be exposed publicly.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.RawEnd">
            <summary>
            Returns the underlying end instant of this zone interval. If the zone interval extends to the
            end of time, the return value will be <see cref="F:NodaTime.Instant.AfterMaxValue"/>; this value
            should *not* be exposed publicly.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.StandardOffset">
            <summary>
            Gets the standard offset for this period. This is the offset without any daylight savings
            contributions.
            </summary>
            <remarks>
            This is effectively <c>WallOffset - Savings</c>.
            </remarks>
            <value>The base Offset.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Duration">
            <summary>
            Gets the duration of this zone interval.
            </summary>
            <remarks>
            This is effectively <c>End - Start</c>.
            </remarks>
            <value>The Duration of this zone interval.</value>
            <exception cref="T:System.InvalidOperationException">This zone extends to the start or end of time.</exception>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.HasStart">
            <summary>
            Returns <c>true</c> if this zone interval has a fixed start point, or <c>false</c> if it
            extends to the beginning of time.
            </summary>
            <value><c>true</c> if this interval has a fixed start point, or <c>false</c> if it
            extends to the beginning of time.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.End">
            <summary>
            Gets the last Instant (exclusive) that the Offset applies.
            </summary>
            <value>The last Instant (exclusive) that the Offset applies.</value>
            <exception cref="T:System.InvalidOperationException">The zone interval extends to the end of time</exception>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.HasEnd">
            <summary>
            Returns <c>true</c> if this zone interval has a fixed end point, or <c>false</c> if it
            extends to the end of time.
            </summary>
            <value><c>true</c> if this interval has a fixed end point, or <c>false</c> if it
            extends to the end of time.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.IsoLocalStart">
            <summary>
            Gets the local start time of the interval, as a <see cref="T:NodaTime.LocalDateTime" />
            in the ISO calendar.
            </summary>
            <value>The local start time of the interval in the ISO calendar, with the offset of
            this zone interval.</value>
            <exception cref="T:System.OverflowException">The interval starts too early to represent as a `LocalDateTime`.</exception>
            <exception cref="T:System.InvalidOperationException">The interval extends to the start of time.</exception>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.IsoLocalEnd">
            <summary>
            Gets the local end time of the interval, as a <see cref="T:NodaTime.LocalDateTime" />
            in the ISO calendar.
            </summary>
            <value>The local end time of the interval in the ISO calendar, with the offset
            of this zone interval. As the end time is exclusive, by the time this local time
            is reached, the next interval will be in effect and the local time will usually
            have changed (e.g. by adding or subtracting an hour).</value>
            <exception cref="T:System.OverflowException">The interval ends too late to represent as a `LocalDateTime`.</exception>
            <exception cref="T:System.InvalidOperationException">The interval extends to the end of time.</exception>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Name">
            <summary>
            Gets the name of this offset period (e.g. PST or PDT).
            </summary>
            <value>The name of this offset period (e.g. PST or PDT).</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.WallOffset">
            <summary>
            Gets the offset from UTC for this period. This includes any daylight savings value.
            </summary>
            <value>The offset from UTC for this period.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Savings">
            <summary>
            Gets the daylight savings value for this period.
            </summary>
            <value>The savings value.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneInterval.Start">
            <summary>
            Gets the first Instant that the Offset applies.
            </summary>
            <value>The first Instant that the Offset applies.</value>
            <exception cref="T:System.InvalidOperationException">The interval extends to the start of time.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.#ctor(System.String,System.Nullable{NodaTime.Instant},System.Nullable{NodaTime.Instant},NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneInterval" /> class.
            </summary>
            <param name="name">The name of this offset period (e.g. PST or PDT).</param>
            <param name="start">The first <see cref="T:NodaTime.Instant" /> that the <paramref name = "wallOffset" /> applies,
            or <c>null</c> to make the zone interval extend to the start of time.</param>
            <param name="end">The last <see cref="T:NodaTime.Instant" /> (exclusive) that the <paramref name = "wallOffset" /> applies,
            or <c>null</c> to make the zone interval extend to the end of time.</param>
            <param name="wallOffset">The <see cref="P:NodaTime.TimeZones.ZoneInterval.WallOffset" /> from UTC for this period including any daylight savings.</param>
            <param name="savings">The <see cref="P:NodaTime.TimeZones.ZoneInterval.WallOffset" /> daylight savings contribution to the offset.</param>
            <exception cref="T:System.ArgumentException">If <c><paramref name = "start" /> &gt;= <paramref name = "end" /></c>.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.#ctor(System.String,NodaTime.Instant,NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneInterval" /> class.
            </summary>
            <param name="name">The name of this offset period (e.g. PST or PDT).</param>
            <param name="start">The first <see cref="T:NodaTime.Instant" /> that the <paramref name = "wallOffset" /> applies,
            or <see cref="F:NodaTime.Instant.BeforeMinValue"/> to make the zone interval extend to the start of time.</param>
            <param name="end">The last <see cref="T:NodaTime.Instant" /> (exclusive) that the <paramref name = "wallOffset" /> applies,
            or <see cref="F:NodaTime.Instant.AfterMaxValue"/> to make the zone interval extend to the end of time.</param>
            <param name="wallOffset">The <see cref="P:NodaTime.TimeZones.ZoneInterval.WallOffset" /> from UTC for this period including any daylight savings.</param>
            <param name="savings">The <see cref="P:NodaTime.TimeZones.ZoneInterval.WallOffset" /> daylight savings contribution to the offset.</param>
            <exception cref="T:System.ArgumentException">If <c><paramref name = "start" /> &gt;= <paramref name = "end" /></c>.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.WithStart(NodaTime.Instant)">
            <summary>
            Returns a copy of this zone interval, but with the given start instant.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.WithEnd(NodaTime.Instant)">
            <summary>
            Returns a copy of this zone interval, but with the given end instant.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Contains(NodaTime.Instant)">
            <summary>
              Determines whether this period contains the given Instant in its range.
            </summary>
            <remarks>
            Usually this is half-open, i.e. the end is exclusive, but an interval with an end point of "the end of time" 
            is deemed to be inclusive at the end.
            </remarks>
            <param name="instant">The instant to test.</param>
            <returns>
              <c>true</c> if this period contains the given Instant in its range; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Contains(NodaTime.LocalInstant)">
            <summary>
              Determines whether this period contains the given LocalInstant in its range.
            </summary>
            <param name="localInstant">The local instant to test.</param>
            <returns>
              <c>true</c> if this period contains the given LocalInstant in its range; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.EqualIgnoreBounds(NodaTime.TimeZones.ZoneInterval)">
            <summary>
            Returns whether this zone interval has the same offsets and name as another.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Equals(NodaTime.TimeZones.ZoneInterval)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name = "other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.op_Equality(NodaTime.TimeZones.ZoneInterval,NodaTime.TimeZones.ZoneInterval)">
            <summary>
            Implements the operator == (equality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.op_Inequality(NodaTime.TimeZones.ZoneInterval,NodaTime.TimeZones.ZoneInterval)">
            <summary>
            Implements the operator != (inequality).
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The left hand side of the operator.</param>
            <param name="right">The right hand side of the operator.</param>
            <returns><c>true</c> if values are not equal to each other, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, <c>false</c>.
            </returns>
            <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.GetHashCode">
            <summary>
            Returns a hash code for this zone interval.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>A hash code for this zone interval.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneInterval.ToString">
            <summary>
              Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
              A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneLocalMapping">
            <summary>
            The result of mapping a <see cref="T:NodaTime.LocalDateTime" /> within a time zone, i.e. finding out
            at what "global" time the "local" time occurred.
            </summary>
            <remarks>
            <para>
            This class is used as the return type of <see cref="M:NodaTime.DateTimeZone.MapLocal(NodaTime.LocalDateTime)" />. It allows for
            finely-grained handling of the three possible results:
            </para>
            <list type="bullet">
              <item>
                <term>Unambiguous mapping</term>
                <description>
                  The local time occurs exactly once in the target time zone.
                </description>
              </item>
              <item>
                <term>Ambiguous mapping</term>
                <description>
                  The local time occurs twice in the target time zone, due to the offset from UTC
                  changing. This usually occurs for an autumnal daylight saving transition, where the clocks
                  are put back by an hour. If the clocks change from 2am to 1am for example, then 1:30am occurs
                  twice - once before the transition and once afterwards.
                </description>
              </item>
              <item>
                <term>Impossible mapping</term>
                <description>
                  The local time does not occur at all in the target time zone, due to the offset from UTC
                  changing. This usually occurs for a vernal (spring-time) daylight saving transition, where the clocks
                  are put forward by an hour. If the clocks change from 1am to 2am for example, then 1:30am is
                  skipped entirely.
                </description>
              </item>
            </list>
            </remarks>
            <threadsafety>This type is an immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.Zone">
            <summary>
            Gets the <see cref="T:NodaTime.DateTimeZone" /> in which this mapping was performed.
            </summary>
            <value>The time zone in which this mapping was performed.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.LocalDateTime">
            <summary>
            Gets the <see cref="T:NodaTime.LocalDateTime" /> which was mapped within the time zone.
            </summary>
            <value>The local date and time which was mapped within the time zone.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval">
            <summary>
            Gets the earlier <see cref="T:NodaTime.TimeZones.ZoneInterval" /> within this mapping.
            </summary>
            <remarks>
            For unambiguous mappings, this is the same as <see cref="P:NodaTime.TimeZones.ZoneLocalMapping.LateInterval" />; for ambiguous mappings,
            this is the interval during which the mapped local time first occurs; for impossible
            mappings, this is the interval before which the mapped local time occurs.
            </remarks>
            <value>The earlier zone interval within this mapping.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.LateInterval">
            <summary>
            Gets the later <see cref="T:NodaTime.TimeZones.ZoneInterval" /> within this mapping.
            </summary>
            <remarks>
            For unambiguous
            mappings, this is the same as <see cref="P:NodaTime.TimeZones.ZoneLocalMapping.EarlyInterval" />; for ambiguous mappings,
            this is the interval during which the mapped local time last occurs; for impossible
            mappings, this is the interval after which the mapped local time occurs.
            </remarks>
            <value>The later zone interval within this mapping.</value>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneLocalMapping.Count">
            <summary>
            Gets the number of results within this mapping: the number of distinct
            <see cref="T:NodaTime.ZonedDateTime" /> values which map to the original <see cref="T:NodaTime.LocalDateTime" />.
            </summary>
            <value>The number of results within this mapping: the number of distinct values which map to the
            original local date and time.</value>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneLocalMapping.Single">
            <summary>
            Returns the single <see cref="T:NodaTime.ZonedDateTime"/> which maps to the original
            <see cref="T:NodaTime.LocalDateTime" /> in the mapped <see cref="T:NodaTime.DateTimeZone" />.
            </summary>
            <exception cref="T:NodaTime.SkippedTimeException">The local date/time was skipped in the time zone.</exception>
            <exception cref="T:NodaTime.AmbiguousTimeException">The local date/time was ambiguous in the time zone.</exception>
            <returns>The unambiguous result of mapping the local date/time in the time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneLocalMapping.First">
            <summary>
            Returns a <see cref="T:NodaTime.ZonedDateTime"/> which maps to the original <see cref="T:NodaTime.LocalDateTime" />
            in the mapped <see cref="T:NodaTime.DateTimeZone" />: either the single result if the mapping is unambiguous,
            or the earlier result if the local date/time occurs twice in the time zone due to a time zone
            offset change such as an autumnal daylight saving transition.
            </summary>
            <exception cref="T:NodaTime.SkippedTimeException">The local date/time was skipped in the time zone.</exception>
            <returns>The unambiguous result of mapping a local date/time in a time zone.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneLocalMapping.Last">
            <summary>
            Returns a <see cref="T:NodaTime.ZonedDateTime"/> which maps to the original <see cref="T:NodaTime.LocalDateTime" />
            in the mapped <see cref="T:NodaTime.DateTimeZone" />: either the single result if the mapping is unambiguous,
            or the later result if the local date/time occurs twice in the time zone due to a time zone
            offset change such as an autumnal daylight saving transition.
            </summary>
            <exception cref="T:NodaTime.SkippedTimeException">The local date/time was skipped in the time zone.</exception>
            <returns>The unambiguous result of mapping a local date/time in a time zone.</returns>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneRecurrence">
            <summary>
            Extends <see cref="T:NodaTime.TimeZones.ZoneYearOffset"/> with a name and savings.
            </summary>
            <remarks>
            <para>
            This represents a recurring transition from or to a daylight savings time. The name is the
            name of the time zone during this period (e.g. PST or PDT). The savings is usually 0 or the
            daylight offset. This is also used to support some of the tricky transitions that occurred
            before the time zones were normalized (i.e. when they were still tightly longitude-based,
            with multiple towns in the same country observing different times).
            </para>
            <para>
            Immutable, thread safe.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.#ctor(System.String,NodaTime.Offset,NodaTime.TimeZones.ZoneYearOffset,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneRecurrence"/> class.
            </summary>
            <param name="name">The name of the time zone period e.g. PST.</param>
            <param name="savings">The savings for this period.</param>
            <param name="yearOffset">The year offset of when this period starts in a year.</param>
            <param name="fromYear">The first year in which this recurrence is valid</param>
            <param name="toYear">The last year in which this recurrence is valid</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.WithName(System.String)">
            <summary>
            Returns a new recurrence which has the same values as this, but a different name.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.ForSingleYear(System.Int32)">
            <summary>
            Returns a new recurrence with the same values as this, but just for a single year.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Equals(NodaTime.TimeZones.ZoneRecurrence)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter;
            otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Next(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the first transition which occurs strictly after the given instant.
            </summary>
            <remarks>
            If the given instant is before the starting year, the year of the given instant is
            adjusted to the beginning of the starting year. The first transition after the
            adjusted instant is determined. If the next adjustment is after the ending year, this
            method returns null; otherwise the next transition is returned.
            </remarks>
            <param name="instant">The <see cref="T:NodaTime.Instant"/> lower bound for the next transition.</param>
            <param name="standardOffset">The <see cref="T:NodaTime.Offset"/> standard offset.</param>
            <param name="previousSavings">The <see cref="T:NodaTime.Offset"/> savings adjustment at the given Instant.</param>
            <returns>The next transition, or null if there is no next transition. The transition may be
            infinite, i.e. after the end of representable time.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.PreviousOrSame(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the last transition which occurs before or on the given instant.
            </summary>
            <param name="instant">The <see cref="T:NodaTime.Instant"/> lower bound for the next transition.</param>
            <param name="standardOffset">The <see cref="T:NodaTime.Offset"/> standard offset.</param>
            <param name="previousSavings">The <see cref="T:NodaTime.Offset"/> savings adjustment at the given Instant.</param>
            <returns>The previous transition, or null if there is no previous transition. The transition may be
            infinite, i.e. before the start of representable time.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.NextOrFail(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Piggy-backs onto Next, but fails with an InvalidOperationException if there's no such transition.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.PreviousOrSameOrFail(NodaTime.Instant,NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Piggy-backs onto PreviousOrSame, but fails with a descriptive InvalidOperationException if there's no such transition.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
            <summary>
            Writes this object to the given <see cref="T:NodaTime.TimeZones.IO.DateTimeZoneWriter"/>.
            </summary>
            <param name="writer">Where to send the output.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Read(NodaTime.TimeZones.IO.IDateTimeZoneReader)">
            <summary>
            Reads a recurrence from the specified reader.
            </summary>
            <param name="reader">The reader.</param>
            <returns>The recurrence read from the reader.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents this instance.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneRecurrence.ToStartOfTime">
            <summary>
            Returns either "this" (if this zone recurrence already has a from year of int.MinValue)
            or a new zone recurrence which is identical but with a from year of int.MinValue.
            </summary>
        </member>
        <member name="T:NodaTime.TimeZones.ZoneYearOffset">
            <summary>
            Defines an offset within a year as an expression that can be used to reference multiple
            years.
            </summary>
            <remarks>
            <para>
            A year offset defines a way of determining an offset into a year based on certain criteria.
            The most basic is the month of the year and the day of the month. If only these two are
            supplied then the offset is always the same day of each year. The only exception is if the
            day is February 29th, then it only refers to those years that have a February 29th.
            </para>
            <para>
            If the day of the week is specified then the offset determined by the month and day are
            adjusted to the nearest day that falls on the given day of the week. If the month and day
            fall on that day of the week then nothing changes. Otherwise the offset is moved forward or
            backward up to 6 days to make the day fall on the correct day of the week. The direction the
            offset is moved is determined by the <see cref="P:NodaTime.TimeZones.ZoneYearOffset.AdvanceDayOfWeek"/> property.
            </para>
            <para>
            Finally the <see cref="P:NodaTime.TimeZones.ZoneYearOffset.Mode"/> property determines whether the <see cref="P:NodaTime.TimeZones.ZoneYearOffset.TimeOfDay"/> value
            is added to the calculated offset to generate an offset within the day.
            </para>
            <para>
            Immutable, thread safe
            </para>
            </remarks>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.Mode">
            <summary>
            Gets the method by which offsets are added to Instants to get LocalInstants.
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.AdvanceDayOfWeek">
            <summary>
            Gets a value indicating whether [advance day of week].
            </summary>
        </member>
        <member name="P:NodaTime.TimeZones.ZoneYearOffset.TimeOfDay">
            <summary>
            Gets the time of day when the rule takes effect.
            </summary>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.#ctor(NodaTime.TimeZones.TransitionMode,System.Int32,System.Int32,System.Int32,System.Boolean,NodaTime.LocalTime)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneYearOffset"/> class.
            </summary>
            <param name="mode">The transition mode.</param>
            <param name="monthOfYear">The month year offset.</param>
            <param name="dayOfMonth">The day of month. Negatives count from end of month.</param>
            <param name="dayOfWeek">The day of week. 0 means not set.</param>
            <param name="advance">if set to <c>true</c> [advance].</param>
            <param name="timeOfDay">The tick within the day.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.#ctor(NodaTime.TimeZones.TransitionMode,System.Int32,System.Int32,System.Int32,System.Boolean,NodaTime.LocalTime,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.TimeZones.ZoneYearOffset"/> class.
            </summary>
            <param name="mode">The transition mode.</param>
            <param name="monthOfYear">The month year offset.</param>
            <param name="dayOfMonth">The day of month. Negatives count from end of month.</param>
            <param name="dayOfWeek">The day of week. 0 means not set.</param>
            <param name="advance">if set to <c>true</c> [advance].</param>
            <param name="timeOfDay">The time of day at which the transition occurs.</param>
            <param name="addDay">Whether to add an extra day (for 24:00 handling).</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.VerifyFieldValue(System.Int64,System.Int64,System.String,System.Int64,System.Boolean)">
            <summary>
            Verifies the input value against the valid range of the calendar field.
            </summary>
            <remarks>
            If this becomes more widely required, move to Preconditions.
            </remarks>
            <param name="minimum">The minimum valid value.</param>
            <param name="maximum">The maximum valid value (inclusive).</param>
            <param name="name">The name of the field for the error message.</param>
            <param name="value">The value to check.</param>
            <param name="allowNegated">if set to <c>true</c> all the range of value to be the negative as well.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If the given value is not in the valid range of the given calendar field.</exception>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Equals(NodaTime.TimeZones.ZoneYearOffset)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <param name="other">An object to compare with this object.</param>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.GetOccurrenceForYear(System.Int32)">
            <summary>
            Returns the occurrence of this rule within the given year, as a LocalInstant.
            </summary>
            <remarks>LocalInstant is used here so that we can use the representation of "AfterMaxValue"
            for December 31st 9999 24:00.</remarks>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Write(NodaTime.TimeZones.IO.IDateTimeZoneWriter)">
            <summary>
            Writes this object to the given <see cref="T:NodaTime.TimeZones.IO.IDateTimeZoneWriter"/>.
            </summary>
            <param name="writer">Where to send the output.</param>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.GetRuleOffset(NodaTime.Offset,NodaTime.Offset)">
            <summary>
            Returns the offset to use for this rule's <see cref="T:NodaTime.TimeZones.TransitionMode"/>.
            The year/month/day/time for a rule is in a specific frame of reference:
            UTC, "wall" or "standard".
            </summary>
            <param name="standardOffset">The standard offset.</param>
            <param name="savings">The daylight savings adjustment.</param>
            <returns>The base time offset as a <see cref="T:NodaTime.Duration"/>.</returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to this instance.
            </summary>
            <param name="obj">The <see cref="T:System.Object"/> to compare with this instance.</param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:NodaTime.TimeZones.ZoneYearOffset.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
            <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data
            structures like a hash table. 
            </returns>
        </member>
        <member name="T:NodaTime.Utility.BclConversions">
            <summary>
            Conversion methods which don't naturally fit into any other types - for example, for
            enums which can't specify any other code. In most cases, conversions to and from BCL types
            are provided within the type itself - such as <see cref="M:NodaTime.LocalDateTime.ToDateTimeUnspecified"/>
            and <see cref="M:NodaTime.LocalDateTime.FromDateTime(System.DateTime)"/>.
            </summary>
            <remarks>
            These methods are also available in the form of extension methods in the <c>NodaTime.Extensions</c> namespace.
            </remarks>
            <threadsafety>All members of this type are thread-safe. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.Utility.BclConversions.ToDayOfWeek(NodaTime.IsoDayOfWeek)">
            <summary>
            Converts from the Noda Time <see cref="T:NodaTime.IsoDayOfWeek"/> enum to the equivalent BCL
            <see cref="T:System.DayOfWeek"/> value. Other than Sunday, the BCL and ISO values are the same -
            but ISO 8601 defines Sunday as day 7, and the BCL defines it as day 0.
            </summary>
            <param name="isoDayOfWeek">ISO day of week value to convert.</param>
            <returns>The ISO day of week value equivalent to the one passed in.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="isoDayOfWeek"/> parameter
            is not a valid day of the week.</exception>
        </member>
        <member name="M:NodaTime.Utility.BclConversions.ToIsoDayOfWeek(System.DayOfWeek)">
            <summary>
            Converts from the BCL <see cref="T:System.DayOfWeek"/> enum to the equivalent Noda Time <see cref="T:NodaTime.IsoDayOfWeek"/> value.
            Other than Sunday, the BCL and ISO values are the same - but ISO 8601 defines
            Sunday as day 7, and the BCL defines it as day 0.
            </summary>
            <param name="dayOfWeek">ISO day of week value to convert.</param>
            <returns>The BCL day of week value equivalent to the one passed in.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="dayOfWeek"/> parameter
            is not a valid day of the week.</exception>
        </member>
        <member name="T:NodaTime.Utility.Cache`2">
            <summary>
            Implements a thread-safe cache of a fixed size, with a single computation function.
            (That happens to be all we need at the time of writing.)
            </summary>
            <remarks>
            For simplicity's sake, eviction is currently on a least-recently-added basis (not LRU). This
            may change in the future.
            </remarks>
            <typeparam name="TKey">Type of key</typeparam>
            <typeparam name="TValue">Type of value</typeparam>
        </member>
        <member name="M:NodaTime.Utility.Cache`2.GetOrAdd(`0)">
            <summary>
            Fetches a value from the cache, populating it if necessary.
            </summary>
            <param name="key">Key to fetch</param>
            <returns>The value associated with the key.</returns>
        </member>
        <member name="P:NodaTime.Utility.Cache`2.Count">
            <summary>
            Returns the number of entries currently in the cache, primarily for diagnostic purposes.
            </summary>
        </member>
        <member name="P:NodaTime.Utility.Cache`2.Keys">
            <summary>
            Returns a copy of the keys in the cache as a list, for diagnostic purposes.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.Cache`2.Clear">
            <summary>
            Clears the cache. This is never surfaced publicly (directly or indirectly) - it's just
            for testing.
            </summary>
        </member>
        <member name="T:NodaTime.Utility.HashCodeHelper">
            <summary>
            Provides method to help with generating hash codes for structures and classes. This handles
            value types, nullable type, and objects.
            </summary>
            <remarks>
            The basic usage pattern is:
            <example>
            <code>
             public override int GetHashCode() => HashCodeHelper.Initialize().Hash(Field1).Hash(Field2).Hash(Field3).Value;
            </code>
            </example>
            </remarks>
        </member>
        <member name="F:NodaTime.Utility.HashCodeHelper.HashCodeMultiplier">
            <summary>
            The multiplier for each value.
            </summary>
        </member>
        <member name="F:NodaTime.Utility.HashCodeHelper.HashCodeInitializer">
            <summary>
            The initial hash value.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.HashCodeHelper.Hash``2(``0,``1)">
            <summary>
            Convenience method to hash two values.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.HashCodeHelper.Hash``3(``0,``1,``2)">
            <summary>
            Convenience method to hash three values.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.HashCodeHelper.Initialize">
            <summary>
            Returns the initial value for a hash code.
            </summary>
            <returns>The initial integer wrapped in a <see cref="T:NodaTime.Utility.HashCodeHelper"/> value.</returns>
        </member>
        <member name="M:NodaTime.Utility.HashCodeHelper.Hash``1(``0)">
            <summary>
            Adds the hash value for the given value to the current hash and returns the new value.
            </summary>
            <typeparam name="T">The type of the value being hashed.</typeparam>
            <param name="value">The value to hash.</param>
            <returns>The new hash code.</returns>
        </member>
        <member name="T:NodaTime.Utility.InvalidNodaDataException">
            <summary>
            Exception thrown when data read by Noda Time (such as serialized time zone data) is invalid. This includes
            data which is truncated, i.e. we expect more data than we can read.
            </summary>
            <remarks>
            This type only exists as <c>InvalidDataException</c> didn't exist in Portable Class Libraries.
            That does exist in netstandard1.3, but as we shipped 2.0 without realizing this, we're stuck with the
            new exception type.
            Unfortunately, <c>InvalidDataException</c> itself is sealed, so we can't derive from it for the sake
            of backward compatibility.
            </remarks>
            <threadsafety>Any public static members of this type are thread safe. Any instance members are not guaranteed to be thread safe.
            See the thread safety section of the user guide for more information.
            </threadsafety>
        </member>
        <member name="M:NodaTime.Utility.InvalidNodaDataException.#ctor(System.String)">
            <summary>
            Creates an instance with the given message.
            </summary>
            <param name="message">The message for the exception.</param>
        </member>
        <member name="M:NodaTime.Utility.InvalidNodaDataException.#ctor(System.String,System.Exception)">
            <summary>
            Creates an instance with the given message.
            </summary>
            <param name="message">The message for the exception.</param>
            <param name="innerException">Underlying cause of the error.</param>
        </member>
        <member name="T:NodaTime.Utility.Preconditions">
            <summary>
            Helper static methods for argument/state validation.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.Preconditions.CheckNotNull``1(``0,System.String)">
            <summary>
            Returns the given argument after checking whether it's null. This is useful for putting
            nullity checks in parameters which are passed to base class constructors.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.Preconditions.DebugCheckNotNull``1(``0,System.String)">
            <summary>
            Like <see cref="M:NodaTime.Utility.Preconditions.CheckNotNull``1(``0,System.String)"/>, but only checked in debug builds. (This means it can't return anything...)
            </summary>
        </member>
        <member name="M:NodaTime.Utility.Preconditions.DebugCheckArgumentRange(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Range change to perform just within debug builds. This is typically for internal sanity checking, where we normally
            trusting the argument value to be valid, and adding a check just for the sake of documentation - and to help find
            internal bugs during development.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.Preconditions.DebugCheckArgumentRange(System.String,System.Int64,System.Int64,System.Int64)">
            <summary>
            Range change to perform just within debug builds. This is typically for internal sanity checking, where we normally
            trusting the argument value to be valid, and adding a check just for the sake of documentation - and to help find
            internal bugs during development.
            </summary>
        </member>
        <member name="T:NodaTime.Utility.ReferenceEqualityComparer`1">
            <summary>
            An equality comparer which compares references for equality and uses the "original" object hash code
            for hash codes.
            </summary>
        </member>
        <member name="T:NodaTime.Utility.TickArithmetic">
            <summary>
            Common operations on ticks.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.TickArithmetic.TicksToDaysAndTickOfDay(System.Int64,System.Int64@)">
            <summary>
            Cautiously converts a number of ticks (which can have any value) into a number of 
            days and a tick within that day.
            </summary>
            <remarks>
            Used by <see cref="M:NodaTime.Duration.FromTicks(System.Int64)"/>.
            </remarks>
        </member>
        <member name="M:NodaTime.Utility.TickArithmetic.NonNegativeTicksToDaysAndTickOfDay(System.Int64,System.Int64@)">
            <summary>
            Similar to <see cref="M:NodaTime.Utility.TickArithmetic.TicksToDaysAndTickOfDay(System.Int64,System.Int64@)"/> but
            trusting that the input is non-negative, which can be proved in certain cases.
            </summary>
            <remarks>
            Used by <see cref="M:NodaTime.LocalDateTime.FromDateTime(System.DateTime)"/> and 
            <see cref="M:NodaTime.LocalDateTime.FromDateTime(System.DateTime,NodaTime.CalendarSystem)"/>.
            </remarks>
        </member>
        <member name="M:NodaTime.Utility.TickArithmetic.DaysAndTickOfDayToTicks(System.Int32,System.Int64)">
            <summary>
            Cautiously computes a number of ticks from day/tick-of-day value. This may overflow,
            but will only do so if it has to.
            </summary>
        </member>
        <member name="M:NodaTime.Utility.TickArithmetic.BoundedDaysAndTickOfDayToTicks(System.Int32,System.Int64)">
            <summary>
            Computes a number of ticks from a day/tick-of-day value which is trusted not to overflow,
            even when computed in the simplest way. Only call this method from places where there
            are suitable constraints on the input.
            </summary>
        </member>
        <member name="T:NodaTime.Xml.XmlSchemaDefinition">
            <summary>
            Provides XML schema types.
            </summary>
        </member>
        <member name="P:NodaTime.Xml.XmlSchemaDefinition.NodaTimeXmlNamespace">
            <summary>
            Gets the XML namespace for all NodaTime types.
            </summary>
            <remarks>See [Namespaces in XML 1.1 (Second Edition)](https://www.w3.org/TR/xml-names11/).</remarks>
        </member>
        <member name="P:NodaTime.Xml.XmlSchemaDefinition.NodaTimeXmlSchema">
            <summary>
            Gets the compiled XML schema describing the structure for all NodaTime types that implement the <see cref="T:System.Xml.Serialization.IXmlSerializable"/> interface.
            </summary>
            <remarks>
            All the pattern restrictions as regular expressions are not meant to fully validate the XML content,
            they only serve to describe the general shape of the XML content.
            </remarks>
        </member>
        <member name="M:NodaTime.Xml.XmlSchemaDefinition.QualifySchemaType``1(``0)">
            <summary>
            Sets the <see cref="P:System.Xml.Schema.XmlSchemaType.QualifiedName"/> of the given <paramref name="schemaType"/>
            to belong to <see cref="P:NodaTime.Xml.XmlSchemaDefinition.NodaTimeXmlNamespace"/>.
            </summary>
            <remarks>
            Going through an <see cref="T:System.Xml.Schema.XmlSchema"/> and an <see cref="T:System.Xml.Schema.XmlSchemaSet"/> is a bit convoluted but
            <c>XmlSchemaType.SetQualifiedName()</c> is internal.
            </remarks>
            <param name="schemaType">The schema type to qualify.</param>
            <typeparam name="T">The type of the <see cref="T:System.Xml.Schema.XmlSchemaType"/></typeparam>
            <returns>The qualified <paramref name="schemaType"/>.</returns>
        </member>
        <member name="T:NodaTime.Xml.XmlSerializationSettings">
            <summary>
            Ambient settings applied during XML serialization and deserialization.
            XML serialization in .NET does not provide any "hooks" for advanced configuration.
            Most of the time that's a good thing, in terms of compatibility: we want
            the same data to be serialized the same way across multiple programs for
            interoperability. There are some exceptions to this however, where decisions
            need to be made and there's no single "right for everyone" choice.
            </summary>
        </member>
        <member name="P:NodaTime.Xml.XmlSerializationSettings.DateTimeZoneProvider">
            <summary>
            Gets the <see cref="T:NodaTime.IDateTimeZoneProvider"/> to use to interpret a time zone ID read as part of
            XML serialization.
            </summary>
            <remarks>
            This property defaults to <see cref="P:NodaTime.DateTimeZoneProviders.Tzdb"/>.
            </remarks>
            <value>The <c>IDateTimeZoneProvider</c> to use to interpret a time zone ID read as part of
            XML serialization.</value>
        </member>
        <member name="T:NodaTime.YearMonth">
            <summary>
            A year and month in a particular calendar. This is effectively
            <see cref="T:NodaTime.LocalDate"/> without the day-of-month component.
            </summary>
            <remarks>
            <para>
            Values can freely be compared for equality: a value in a different calendar system is not equal to
            a value in a different calendar system. However, ordering comparisons
            fail with <see cref="T:System.ArgumentException"/>; attempting to compare values in different calendars
            almost always indicates a bug in the calling code.
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="F:NodaTime.YearMonth.startOfMonth">
            <summary>
            The start of month. This is used as our base representation as we already have
            plenty of other code that integrates it, and it implements a compact representation
            without us having to duplicate any of the logic.
            </summary>
        </member>
        <member name="P:NodaTime.YearMonth.Calendar">
            <summary>Gets the calendar system associated with this year/month.</summary>
            <value>The calendar system associated with this year/month.</value>
        </member>
        <member name="P:NodaTime.YearMonth.Year">
            <summary>Gets the year of this year/month.</summary>
            <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
            <value>The year of this year/month.</value>
        </member>
        <member name="P:NodaTime.YearMonth.Month">
            <summary>Gets the month of this year/month within the year.</summary>
            <value>The month of this year/month within the year.</value>
        </member>
        <member name="P:NodaTime.YearMonth.YearOfEra">
            <summary>Gets the year of this value within the era.</summary>
            <value>The year of this value within the era.</value>
        </member>
        <member name="P:NodaTime.YearMonth.Era">
            <summary>Gets the era of this year/month.</summary>
            <value>The era of this year/month.</value>
        </member>
        <member name="P:NodaTime.YearMonth.StartDate">
            <summary>
            Returns the date of the start of this year/month.
            </summary>
        </member>
        <member name="P:NodaTime.YearMonth.EndDate">
            <summary>
            Returns the date of the end of this year/month.
            </summary>
        </member>
        <member name="M:NodaTime.YearMonth.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs an instance for the given year and month in the ISO calendar.
            </summary>
            <param name="year">The year. This is the "absolute year", so a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <returns>The resulting year/month.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid year/month.</exception>
        </member>
        <member name="M:NodaTime.YearMonth.#ctor(System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Constructs an instance for the given year and month in the specified calendar.
            </summary>
            <param name="year">The year. This is the "absolute year", so, for
            the ISO calendar, a value of 0 means 1 BC, for example.</param>
            <param name="month">The month of year.</param>
            <param name="calendar">Calendar system in which to create the year/month.</param>
            <returns>The resulting year/month.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid year/month.</exception>
        </member>
        <member name="M:NodaTime.YearMonth.#ctor(NodaTime.Calendars.Era,System.Int32,System.Int32)">
            <summary>
            Constructs an instance for the given era, year of era and month in the ISO calendar.
            </summary>
            <param name="era">The era within which to create a year/month. Must be a valid era within the ISO calendar.</param>
            <param name="yearOfEra">The year of era.</param>
            <param name="month">The month of year.</param>
            <returns>The resulting year/month.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid year/month.</exception>
        </member>
        <member name="M:NodaTime.YearMonth.#ctor(NodaTime.Calendars.Era,System.Int32,System.Int32,NodaTime.CalendarSystem)">
            <summary>
            Constructs an instance for the given era, year of era and month in the specified calendar.
            </summary>
            <param name="era">The era within which to create a year/month. Must be a valid era within the specified calendar.</param>
            <param name="yearOfEra">The year of era.</param>
            <param name="month">The month of year.</param>
            <param name="calendar">Calendar system in which to create the year/month.</param>
            <returns>The resulting year/month.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">The parameters do not form a valid year/month.</exception>
        </member>
        <member name="M:NodaTime.YearMonth.ToDateInterval">
            <summary>
            Returns a <see cref="T:NodaTime.DateInterval"/> covering the month represented by this value.
            </summary>
            <returns>A <see cref="T:NodaTime.DateInterval"/> covering the month represented by this value.</returns>
        </member>
        <member name="M:NodaTime.YearMonth.PlusMonths(System.Int32)">
            <summary>
            Returns a <see cref="T:NodaTime.YearMonth"/> object which is the result of adding the specified number
            of months to this object.
            </summary>
            <param name="months">The number of months to add to this object.</param>
            <returns>The resulting <see cref="T:NodaTime.YearMonth"/> after adding the specified number of months.</returns>
        </member>
        <member name="M:NodaTime.YearMonth.OnDayOfMonth(System.Int32)">
            <summary>
            Returns a <see cref="T:NodaTime.LocalDate"/> with the year/month of this value, and the given day of month.
            </summary>
            <param name="day">The day within the month.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="day"/> does not fall within the
            month represented by this value.</exception>
            <returns>The result of combining this year and month with <paramref name="day"/>.</returns>
        </member>
        <member name="M:NodaTime.YearMonth.CompareTo(NodaTime.YearMonth)">
            <summary>
            Indicates whether this year/month is earlier, later or the same as another one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="other">The other year/month to compare this one with</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="other"/> is not the
            same as the calendar system of this value.</exception>
            <returns>A value less than zero if this year/month is earlier than <paramref name="other"/>;
            zero if this year/month is the same as <paramref name="other"/>; a value greater than zero if this date is
            later than <paramref name="other"/>.</returns>
        </member>
        <member name="M:NodaTime.YearMonth.TrustedCompareTo(NodaTime.YearMonth)">
            <summary>
            Performs a comparison with another YearMonth, trusting that the calendar of the other date is already correct.
            This avoids duplicate calendar checks.
            </summary>
        </member>
        <member name="M:NodaTime.YearMonth.System#IComparable#CompareTo(System.Object)">
            <summary>
            Implementation of <see cref="M:System.IComparable.CompareTo(System.Object)"/> to compare two YearMonth values.
            See the type documentation for a description of ordering semantics.
            </summary>
            <remarks>
            This uses explicit interface implementation to avoid it being called accidentally. The generic implementation should usually be preferred.
            </remarks>
            <exception cref="T:System.ArgumentException"><paramref name="obj"/> is non-null but does not refer to an instance of <see cref="T:NodaTime.YearMonth"/>, or refers
            to a value in a different calendar system.</exception>
            <param name="obj">The object to compare this value with.</param>
            <returns>The result of comparing this YearMonth with another one.
            If <paramref name="obj"/> is null, this method returns a value greater than 0.
            </returns>
        </member>
        <member name="M:NodaTime.YearMonth.op_LessThan(NodaTime.YearMonth,NodaTime.YearMonth)">
            <summary>
            Compares two YearMonth values to see if the left one is strictly earlier than the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is strictly earlier than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.YearMonth.op_LessThanOrEqual(NodaTime.YearMonth,NodaTime.YearMonth)">
            <summary>
            Compares two YearMonth values to see if the left one is earlier than or equal to the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is earlier than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.YearMonth.op_GreaterThan(NodaTime.YearMonth,NodaTime.YearMonth)">
            <summary>
            Compares two YearMonth values to see if the left one is strictly later than the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is strictly later than <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.YearMonth.op_GreaterThanOrEqual(NodaTime.YearMonth,NodaTime.YearMonth)">
            <summary>
            Compares two YearMonth values to see if the left one is later than or equal to the right one.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="lhs">First operand of the comparison</param>
            <param name="rhs">Second operand of the comparison</param>
            <exception cref="T:System.ArgumentException">The calendar system of <paramref name="rhs"/> is not the same
            as the calendar of <paramref name="lhs"/>.</exception>
            <returns>true if the <paramref name="lhs"/> is later than or equal to <paramref name="rhs"/>, false otherwise.</returns>
        </member>
        <member name="M:NodaTime.YearMonth.GetHashCode">
            <summary>
            Returns a hash code for this year/month.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>A hash code for this value.</returns>
        </member>
        <member name="M:NodaTime.YearMonth.Equals(System.Object)">
            <summary>
            Compares two <see cref="T:NodaTime.YearMonth"/> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="obj">The object to compare this year/month with.</param>
            <returns>True if the given value is another year/month equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.YearMonth.Equals(NodaTime.YearMonth)">
            <summary>
            Compares two <see cref="T:NodaTime.YearMonth"/> values for equality.
            See the type documentation for a description of ordering semantics.
            </summary>
            <param name="other">The value to compare this year/month with.</param>
            <returns>True if the given value is another year/month equal to this one; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.YearMonth.op_Equality(NodaTime.YearMonth,NodaTime.YearMonth)">
            <summary>
            Compares two <see cref="T:NodaTime.YearMonth" /> values for equality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>True if the two year/month values are the same and in the same calendar; false otherwise</returns>
        </member>
        <member name="M:NodaTime.YearMonth.op_Inequality(NodaTime.YearMonth,NodaTime.YearMonth)">
            <summary>
            Compares two <see cref="T:NodaTime.YearMonth" /> values for inequality.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="lhs">The first value to compare</param>
            <param name="rhs">The second value to compare</param>
            <returns>False if the two year/month values are the same and in the same calendar; true otherwise</returns>
        </member>
        <member name="M:NodaTime.YearMonth.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <remarks>
            Unlike most <see cref="T:System.IFormattable"/> implementations, a <paramref name="patternText"/> of null with
            the current thread's culture does not yield the same result as the parameterless <see cref="M:NodaTime.YearMonth.ToString"/>
            overload, for backward-compatibility reasons. (It uses the ISO format, which is culture-insensitive.)
            </remarks>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the ISO format pattern ("g").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.YearMonth.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the culture-specific default format pattern ("G"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.YearMonth.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.YearMonth"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.YearMonth.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.YearMonth.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.YearMonth.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.YearMonthDay">
            <summary>
            A compact representation of a year, month and day in a single 32-bit integer. 
            </summary>
            <remarks>
            <para>
            See <see cref="T:NodaTime.YearMonthDayCalendar"/> for the number of bits per component,
            but this doesn't have the calendar component, so bit 0 is part of the day value.
            This type is naive: comparisons are performed assuming that a larger month number
            always comes after a smaller month number, etc.
            This is suitable for most, but not all, calendar systems.
            </para>
            <para>
            The internal representation actually uses 0 for 1 (etc) for each component.
            That means the default value is 0001-01-01, which is reasonable for all
            supported calendars.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.YearMonthDay.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a new value for the given year, month and day. No validation is performed.
            </summary>
        </member>
        <member name="T:NodaTime.YearMonthDayCalendar">
            <summary>
            A compact representation of a year, month and day and calendar ordinal (integer ID) in a single 32-bit integer. 
            </summary>
            <remarks>
            <para>
            The calendar is represented in bits 0-5.
            The day is represented in bits 6-11.
            The month is represented in bits 12-16.
            The year is represented in bits 17-31. (It's convenient to put this at the top as it can be negative.)
            
            This type does not implement IComparable[YearMonthDayCalendar] as it turns out it doesn't need to:
            comparisons are always done through the calendar system, which uses YearMonthDay instead. We could potentially
            optimize by bypassing the calendar and embedding knowledge of calendars which have "odd" month numberings
            in here, but it would be a bit of a design smell.
            
            Equality is easily tested, however, as it can check for calendar equality.
            </para>
            <para>
            The internal representation actually uses 0 for 1 (etc) for each component.
            That means the default value is 0001-01-01, which is reasonable for all
            supported calendars.
            </para>
            </remarks>
        </member>
        <member name="M:NodaTime.YearMonthDayCalendar.#ctor(System.Int32,System.Int32,System.Int32,NodaTime.CalendarOrdinal)">
            <summary>
            Constructs a new value for the given year, month, day and calendar. No validation is performed.
            </summary>
        </member>
        <member name="T:NodaTime.ZonedClock">
            <summary>
            A clock with an associated time zone and calendar. This is effectively a convenience
            class decorating an <see cref="T:NodaTime.IClock"/>.
            </summary>
            <threadsafety>This type is immutable reference type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="P:NodaTime.ZonedClock.Clock">
            <summary>Gets the clock used to provide the current instant.</summary>
            <value>The clock associated with this zoned clock.</value>
        </member>
        <member name="P:NodaTime.ZonedClock.Zone">
            <summary>Gets the time zone used when converting the current instant into a zone-sensitive value.</summary>
            <value>The time zone associated with this zoned clock.</value>
        </member>
        <member name="P:NodaTime.ZonedClock.Calendar">
            <summary>Gets the calendar system used when converting the current instant into a calendar-sensitive value.</summary>
            <value>The calendar system associated with this zoned clock.</value>
        </member>
        <member name="M:NodaTime.ZonedClock.#ctor(NodaTime.IClock,NodaTime.DateTimeZone,NodaTime.CalendarSystem)">
            <summary>
            Creates a new <see cref="T:NodaTime.ZonedClock"/> with the given clock, time zone and calendar system.
            </summary>
            <param name="clock">Clock to use to obtain instants.</param>
            <param name="zone">Time zone to adjust instants into.</param>
            <param name="calendar">Calendar system to use.</param>
        </member>
        <member name="M:NodaTime.ZonedClock.GetCurrentInstant">
            <summary>
            Returns the current instant provided by the underlying clock.
            </summary>
            <returns>The current instant provided by the underlying clock.</returns>
        </member>
        <member name="M:NodaTime.ZonedClock.GetCurrentZonedDateTime">
            <summary>
            Returns the current instant provided by the underlying clock, adjusted
            to the time zone of this object.
            </summary>
            <returns>The current instant provided by the underlying clock, adjusted to the
            time zone of this object.</returns>
        </member>
        <member name="M:NodaTime.ZonedClock.GetCurrentLocalDateTime">
            <summary>
            Returns the local date/time of the current instant provided by the underlying clock, adjusted
            to the time zone of this object.
            </summary>
            <returns>The local date/time of the current instant provided by the underlying clock, adjusted to the
            time zone of this object.</returns>
        </member>
        <member name="M:NodaTime.ZonedClock.GetCurrentOffsetDateTime">
            <summary>
            Returns the offset date/time of the current instant provided by the underlying clock, adjusted
            to the time zone of this object.
            </summary>
            <returns>The offset date/time of the current instant provided by the underlying clock, adjusted to the
            time zone of this object.</returns>
        </member>
        <member name="M:NodaTime.ZonedClock.GetCurrentDate">
            <summary>
            Returns the local date of the current instant provided by the underlying clock, adjusted
            to the time zone of this object.
            </summary>
            <returns>The local date of the current instant provided by the underlying clock, adjusted to the
            time zone of this object.</returns>
        </member>
        <member name="M:NodaTime.ZonedClock.GetCurrentTimeOfDay">
            <summary>
            Returns the local time of the current instant provided by the underlying clock, adjusted
            to the time zone of this object.
            </summary>
            <returns>The local time of the current instant provided by the underlying clock, adjusted to the
            time zone of this object.</returns>
        </member>
        <member name="T:NodaTime.ZonedDateTime">
            <summary>
            A <see cref="T:NodaTime.LocalDateTime" /> in a specific time zone and with a particular offset to distinguish
            between otherwise-ambiguous instants. A <see cref="T:NodaTime.ZonedDateTime"/> is global, in that it maps to a single
            <see cref="T:NodaTime.Instant"/>.
            </summary>
            <remarks>
            <para>Although <see cref="T:NodaTime.ZonedDateTime" /> includes both local and global concepts, it only supports
            duration-based - and not calendar-based - arithmetic. This avoids ambiguities
            and skipped date/time values becoming a problem within a series of calculations; instead,
            these can be considered just once, at the point of conversion to a <see cref="T:NodaTime.ZonedDateTime"/>.
            </para>
            <para>
            <c>ZonedDateTime</c> does not implement ordered comparison operators, as there is no obvious natural ordering that works in all cases. 
            Equality is supported however, requiring equality of zone, calendar and date/time. If you want to sort <c>ZonedDateTime</c>
            values, you should explicitly choose one of the orderings provided via the static properties in the
            <see cref="T:NodaTime.ZonedDateTime.Comparer"/> nested class (or implement your own comparison).
            </para>
            </remarks>
            <threadsafety>This type is an immutable value type. See the thread safety section of the user guide for more information.</threadsafety>
        </member>
        <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.OffsetDateTime,NodaTime.DateTimeZone)">
            <summary>
            Internal constructor from pre-validated values.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.Instant,NodaTime.DateTimeZone,NodaTime.CalendarSystem)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.ZonedDateTime"/> struct.
            </summary>
            <param name="instant">The instant.</param>
            <param name="zone">The time zone.</param>
            <param name="calendar">The calendar system.</param>
        </member>
        <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.Instant,NodaTime.DateTimeZone)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.ZonedDateTime" /> struct in the specified time zone
            and the ISO calendar.
            </summary>
            <param name="instant">The instant.</param>
            <param name="zone">The time zone.</param>
        </member>
        <member name="M:NodaTime.ZonedDateTime.#ctor(NodaTime.LocalDateTime,NodaTime.DateTimeZone,NodaTime.Offset)">
            <summary>
            Initializes a new instance of the <see cref="T:NodaTime.ZonedDateTime"/> struct in the specified time zone
            from a given local time and offset. The offset is validated to be correct as part of initialization.
            In most cases a local time can only map to a single instant anyway, but the offset is included here for cases
            where the local time is ambiguous, usually due to daylight saving transitions.
            </summary>
            <param name="localDateTime">The local date and time.</param>
            <param name="zone">The time zone.</param>
            <param name="offset">The offset between UTC and local time at the desired instant.</param>
            <exception cref="T:System.ArgumentException"><paramref name="offset"/> is not a valid offset at the given
            local date and time.</exception>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Offset">
            <summary>Gets the offset of the local representation of this value from UTC.</summary>
            <value>The offset of the local representation of this value from UTC.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Zone">
            <summary>Gets the time zone associated with this value.</summary>
            <value>The time zone associated with this value.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.LocalDateTime">
            <summary>
            Gets the local date and time represented by this zoned date and time.
            </summary>
            <remarks>
            The returned
            <see cref="T:NodaTime.LocalDateTime"/> will have the same calendar system and return the same values for
            each of the calendar properties (Year, MonthOfYear and so on), but will not be associated with any
            particular time zone.
            </remarks>
            <value>The local date and time represented by this zoned date and time.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Calendar">
            <summary>Gets the calendar system associated with this zoned date and time.</summary>
            <value>The calendar system associated with this zoned date and time.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Date">
            <summary>
            Gets the local date represented by this zoned date and time.
            </summary>
            <remarks>
            The returned <see cref="T:NodaTime.LocalDate"/>
            will have the same calendar system and return the same values for each of the date-based calendar
            properties (Year, MonthOfYear and so on), but will not be associated with any particular time zone.
            </remarks>
            <value>The local date represented by this zoned date and time.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.TimeOfDay">
            <summary>
            Gets the time portion of this zoned date and time.
            </summary>
            <remarks>
            The returned <see cref="T:NodaTime.LocalTime"/> will
            return the same values for each of the time-based properties (Hour, Minute and so on), but
            will not be associated with any particular time zone.
            </remarks>
            <value>The time portion of this zoned date and time.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Era">
            <summary>Gets the era for this zoned date and time.</summary>
            <value>The era for this zoned date and time.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Year">
            <summary>Gets the year of this zoned date and time.</summary>
            <remarks>This returns the "absolute year", so, for the ISO calendar,
            a value of 0 means 1 BC, for example.</remarks>
            <value>The year of this zoned date and time.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.YearOfEra">
            <summary>Gets the year of this zoned date and time within its era.</summary>
            <value>The year of this zoned date and time within its era.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Month">
            <summary>Gets the month of this zoned date and time within the year.</summary>
            <value>The month of this zoned date and time within the year.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.DayOfYear">
            <summary>Gets the day of this zoned date and time within the year.</summary>
            <value>The day of this zoned date and time within the year.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Day">
            <summary>
            Gets the day of this zoned date and time within the month.
            </summary>
            <value>The day of this zoned date and time within the month.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.DayOfWeek">
            <summary>
            Gets the week day of this zoned date and time expressed as an <see cref="T:NodaTime.IsoDayOfWeek"/> value.
            </summary>
            <value>The week day of this zoned date and time expressed as an <c>IsoDayOfWeek</c> value.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Hour">
            <summary>
            Gets the hour of day of this zoned date and time, in the range 0 to 23 inclusive.
            </summary>
            <value>The hour of day of this zoned date and time, in the range 0 to 23 inclusive.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.ClockHourOfHalfDay">
            <summary>
            Gets the hour of the half-day of this zoned date and time, in the range 1 to 12 inclusive.
            </summary>
            <value>The hour of the half-day of this zoned date and time, in the range 1 to 12 inclusive.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Minute">
            <summary>
            Gets the minute of this zoned date and time, in the range 0 to 59 inclusive.
            </summary>
            <value>The minute of this zoned date and time, in the range 0 to 59 inclusive.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Second">
            <summary>
            Gets the second of this zoned date and time within the minute, in the range 0 to 59 inclusive.
            </summary>
            <value>The second of this zoned date and time within the minute, in the range 0 to 59 inclusive.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Millisecond">
            <summary>
            Gets the millisecond of this zoned date and time within the second, in the range 0 to 999 inclusive.
            </summary>
            <value>The millisecond of this zoned date and time within the second, in the range 0 to 999 inclusive.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.TickOfSecond">
            <summary>
            Gets the tick of this zoned date and time within the second, in the range 0 to 9,999,999 inclusive.
            </summary>
            <value>The tick of this zoned date and time within the second, in the range 0 to 9,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.TickOfDay">
            <summary>
            Gets the tick of this zoned date and time within the day, in the range 0 to 863,999,999,999 inclusive.
            </summary>
            <remarks>
            This is the TickOfDay portion of the contained <see cref="T:NodaTime.OffsetDateTime"/>.
            On daylight saving time transition dates, it may not be the same as the number of ticks elapsed since the beginning of the day.
            </remarks>
            <value>The tick of this zoned date and time within the day, in the range 0 to 863,999,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.NanosecondOfSecond">
            <summary>
            Gets the nanosecond of this zoned date and time within the second, in the range 0 to 999,999,999 inclusive.
            </summary>
            <value>The nanosecond of this zoned date and time within the second, in the range 0 to 999,999,999 inclusive.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.NanosecondOfDay">
            <summary>
            Gets the nanosecond of this zoned date and time within the day, in the range 0 to 86,399,999,999,999 inclusive.
            </summary>
            <remarks>
            This is the NanosecondOfDay portion of the contained <see cref="T:NodaTime.OffsetDateTime"/>.
            On daylight saving time transition dates, it may not be the same as the number of nanoseconds elapsed since the beginning of the day.
            </remarks>
            <value>The nanosecond of this zoned date and time within the day, in the range 0 to 86,399,999,999,999 inclusive.</value>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToInstant">
            <summary>
            Converts this value to the instant it represents on the time line.
            </summary>
            <remarks>
            This is always an unambiguous conversion. Any difficulties due to daylight saving
            transitions or other changes in time zone are handled when converting from a
            <see cref="T:NodaTime.LocalDateTime" /> to a <see cref="T:NodaTime.ZonedDateTime"/>; the <c>ZonedDateTime</c> remembers
            the actual offset from UTC to local time, so it always knows the exact instant represented.
            </remarks>
            <returns>The instant corresponding to this value.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.WithZone(NodaTime.DateTimeZone)">
            <summary>
            Creates a new <see cref="T:NodaTime.ZonedDateTime"/> representing the same instant in time, in the
            same calendar but a different time zone.
            </summary>
            <param name="targetZone">The target time zone to convert to.</param>
            <returns>A new value in the target time zone.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.WithCalendar(NodaTime.CalendarSystem)">
            <summary>
            Creates a new ZonedDateTime representing the same physical date, time and offset, but in a different calendar.
            The returned ZonedDateTime is likely to have different date field values to this one.
            For example, January 1st 1970 in the Gregorian calendar was December 19th 1969 in the Julian calendar.
            </summary>
            <param name="calendar">The calendar system to convert this zoned date and time to.</param>
            <returns>The converted ZonedDateTime.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
            <returns>True if the specified value is the same instant in the same time zone; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to.</param> 
            <filterpriority>2</filterpriority>
            <returns>True if the specified value is a <see cref="T:NodaTime.ZonedDateTime"/> representing the same instant in the same time zone; false otherwise.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.GetHashCode">
            <summary>
            Computes the hash code for this instance.
            See the type documentation for a description of equality semantics.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Equality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Implements the operator ==.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The first value to compare</param>
            <param name="right">The second value to compare</param>
            <returns>True if the two operands are equal according to <see cref="M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)"/>; false otherwise</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Inequality(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Implements the operator !=.
            See the type documentation for a description of equality semantics.
            </summary>
            <param name="left">The first value to compare</param>
            <param name="right">The second value to compare</param>
            <returns>False if the two operands are equal according to <see cref="M:NodaTime.ZonedDateTime.Equals(NodaTime.ZonedDateTime)"/>; true otherwise</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Add(NodaTime.ZonedDateTime,NodaTime.Duration)">
            <summary>
            Adds a duration to a zoned date and time.
            </summary>
            <remarks>
            This is an alternative way of calling <see cref="M:NodaTime.ZonedDateTime.op_Addition(NodaTime.ZonedDateTime,NodaTime.Duration)"/>.
            </remarks>
            <param name="zonedDateTime">The value to add the duration to.</param>
            <param name="duration">The duration to add</param>
            <returns>A new value with the time advanced by the given duration, in the same calendar system and time zone.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Plus(NodaTime.Duration)">
            <summary>
            Returns the result of adding a duration to this zoned date and time.
            </summary>
            <remarks>
            This is an alternative way of calling <see cref="M:NodaTime.ZonedDateTime.op_Addition(NodaTime.ZonedDateTime,NodaTime.Duration)"/>.
            </remarks>
            <param name="duration">The duration to add</param>
            <returns>A new <see cref="T:NodaTime.ZonedDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.PlusHours(System.Int32)">
            <summary>
            Returns the result of adding a increment of hours to this zoned date and time
            </summary>
            <param name="hours">The number of hours to add</param>
            <returns>A new <see cref="T:NodaTime.ZonedDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.PlusMinutes(System.Int32)">
            <summary>
            Returns the result of adding an increment of minutes to this zoned date and time
            </summary>
            <param name="minutes">The number of minutes to add</param>
            <returns>A new <see cref="T:NodaTime.ZonedDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.PlusSeconds(System.Int64)">
            <summary>
            Returns the result of adding an increment of seconds to this zoned date and time
            </summary>
            <param name="seconds">The number of seconds to add</param>
            <returns>A new <see cref="T:NodaTime.ZonedDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.PlusMilliseconds(System.Int64)">
            <summary>
            Returns the result of adding an increment of milliseconds to this zoned date and time
            </summary>
            <param name="milliseconds">The number of milliseconds to add</param>
            <returns>A new <see cref="T:NodaTime.ZonedDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.PlusTicks(System.Int64)">
            <summary>
            Returns the result of adding an increment of ticks to this zoned date and time
            </summary>
            <param name="ticks">The number of ticks to add</param>
            <returns>A new <see cref="T:NodaTime.ZonedDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.PlusNanoseconds(System.Int64)">
            <summary>
            Returns the result of adding an increment of nanoseconds to this zoned date and time
            </summary>
            <param name="nanoseconds">The number of nanoseconds to add</param>
            <returns>A new <see cref="T:NodaTime.ZonedDateTime" /> representing the result of the addition.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Addition(NodaTime.ZonedDateTime,NodaTime.Duration)">
            <summary>
            Returns a new <see cref="T:NodaTime.ZonedDateTime"/> with the time advanced by the given duration. Note that
            due to daylight saving time changes this may not advance the local time by the same amount.
            </summary>
            <remarks>
            The returned value retains the calendar system and time zone of <paramref name="zonedDateTime"/>.
            </remarks>
            <param name="zonedDateTime">The <see cref="T:NodaTime.ZonedDateTime"/> to add the duration to.</param>
            <param name="duration">The duration to add.</param>
            <returns>A new value with the time advanced by the given duration, in the same calendar system and time zone.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Subtract(NodaTime.ZonedDateTime,NodaTime.Duration)">
            <summary>
            Subtracts a duration from a zoned date and time.
            </summary>
            <remarks>
            This is an alternative way of calling <see cref="M:NodaTime.ZonedDateTime.op_Subtraction(NodaTime.ZonedDateTime,NodaTime.Duration)"/>.
            </remarks>
            <param name="zonedDateTime">The value to subtract the duration from.</param>
            <param name="duration">The duration to subtract.</param>
            <returns>A new value with the time "rewound" by the given duration, in the same calendar system and time zone.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Minus(NodaTime.Duration)">
            <summary>
            Returns the result of subtracting a duration from this zoned date and time, for a fluent alternative to
            <see cref="M:NodaTime.ZonedDateTime.op_Subtraction(NodaTime.ZonedDateTime,NodaTime.Duration)"/>
            </summary>
            <param name="duration">The duration to subtract</param>
            <returns>A new <see cref="T:NodaTime.ZonedDateTime" /> representing the result of the subtraction.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Subtraction(NodaTime.ZonedDateTime,NodaTime.Duration)">
            <summary>
            Returns a new <see cref="T:NodaTime.ZonedDateTime"/> with the duration subtracted. Note that
            due to daylight saving time changes this may not change the local time by the same amount.
            </summary>
            <remarks>
            The returned value retains the calendar system and time zone of <paramref name="zonedDateTime"/>.
            </remarks>
            <param name="zonedDateTime">The value to subtract the duration from.</param>
            <param name="duration">The duration to subtract.</param>
            <returns>A new value with the time "rewound" by the given duration, in the same calendar system and time zone.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Subtract(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Subtracts one zoned date and time from another, returning an elapsed duration.
            </summary>
            <remarks>
            This is an alternative way of calling <see cref="M:NodaTime.ZonedDateTime.op_Subtraction(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)"/>.
            </remarks>
            <param name="end">The zoned date and time value to subtract from; if this is later than <paramref name="start"/>
            then the result will be positive.</param>
            <param name="start">The zoned date and time to subtract from <paramref name="end"/>.</param>
            <returns>The elapsed duration from <paramref name="start"/> to <paramref name="end"/>.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Minus(NodaTime.ZonedDateTime)">
            <summary>
            Returns the result of subtracting another zoned date and time from this one, resulting in the elapsed duration
            between the two instants represented in the values.
            </summary>
            <remarks>
            This is an alternative way of calling <see cref="M:NodaTime.ZonedDateTime.op_Subtraction(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)"/>.
            </remarks>
            <param name="other">The zoned date and time to subtract from this one.</param>
            <returns>The elapsed duration from <paramref name="other"/> to this value.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.op_Subtraction(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Subtracts one <see cref="T:NodaTime.ZonedDateTime"/> from another, resulting in the elapsed time between
            the two values.
            </summary>
            <remarks>
            This is equivalent to <c>end.ToInstant() - start.ToInstant()</c>; in particular:
            <list type="bullet">
              <item><description>The two values can use different calendar systems</description></item>
              <item><description>The two values can be in different time zones</description></item>
              <item><description>The two values can have different UTC offsets</description></item>
            </list>
            </remarks>
            <param name="end">The zoned date and time value to subtract from; if this is later than <paramref name="start"/>
            then the result will be positive.</param>
            <param name="start">The zoned date and time to subtract from <paramref name="end"/>.</param>
            <returns>The elapsed duration from <paramref name="start"/> to <paramref name="end"/>.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.GetZoneInterval">
            <summary>
            Returns the <see cref="T:NodaTime.TimeZones.ZoneInterval"/> containing this value, in the time zone this
            value refers to.
            </summary>
            <remarks>
            This is simply a convenience method - it is logically equivalent to converting this
            value to an <see cref="T:NodaTime.Instant"/> and then asking the appropriate <see cref="T:NodaTime.DateTimeZone"/>
            for the <c>ZoneInterval</c> containing that instant.
            </remarks>
            <returns>The <c>ZoneInterval</c> containing this value.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.IsDaylightSavingTime">
            <summary>
            Indicates whether or not this <see cref="T:NodaTime.ZonedDateTime"/> is in daylight saving time
            for its time zone. This is determined by checking the <see cref="P:NodaTime.TimeZones.ZoneInterval.Savings"/> property
            of the zone interval containing this value.
            </summary>
            <seealso cref="M:NodaTime.ZonedDateTime.GetZoneInterval"/>
            <returns><c>true</c> if the zone interval containing this value has a non-zero savings
            component; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            The value of the current instance in the default format pattern ("G"), using the current thread's
            culture to obtain a format provider.
            </returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified pattern.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="patternText">The <see cref="T:System.String" /> specifying the pattern to use,
            or null to use the default format pattern ("G").
            </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use when formatting the value,
            or null to use the current thread's culture to obtain a format provider.
            </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToDateTimeOffset">
            <summary>
            Constructs a <see cref="T:System.DateTimeOffset"/> value with the same local time and offset from
            UTC as this value.
            </summary>
            <remarks>
            <para>
            An offset does not convey as much information as a time zone; a <see cref="T:System.DateTimeOffset"/>
            represents an instant in time along with an associated local time, but it doesn't allow you
            to find out what the local time would be for another instant.
            </para>
            <para>
            If the date and time is not on a tick boundary (the unit of granularity of DateTime) the value will be truncated
            towards the start of time.
            </para>
            <para>
            If the offset has a non-zero second component, this is truncated as <c>DateTimeOffset</c> has an offset
            granularity of minutes.
            </para>
            <para>
            <see cref="T:System.DateTimeOffset"/> uses the Gregorian calendar by definition, so the value is implicitly converted
            to the Gregorian calendar first. The result will be the same instant in time (potentially truncated as described
            above), but the values returned by the Year/Month/Day properties of the <see cref="T:System.DateTimeOffset"/> may not
            match the Year/Month/Day properties of this value.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The date/time is outside the range of <c>DateTimeOffset</c>,
            or the offset is outside the range of +/-14 hours (the range supported by <c>DateTimeOffset</c>).</exception>
            <returns>A <c>DateTimeOffset</c> with the same local date/time and offset as this. The <see cref="T:System.DateTime"/> part of
            the result always has a "kind" of Unspecified.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.FromDateTimeOffset(System.DateTimeOffset)">
            <summary>
            Returns a new <see cref="T:NodaTime.ZonedDateTime"/> representing the same instant in time as the given
            <see cref="T:System.DateTimeOffset"/>.
            The time zone used will be a fixed time zone, which uses the same offset throughout time.
            </summary>
            <param name="dateTimeOffset">Date and time value with an offset.</param>
            <returns>A <see cref="T:NodaTime.ZonedDateTime"/> value representing the same instant in time as the given <see cref="T:System.DateTimeOffset"/>.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToDateTimeUtc">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this <see cref="T:NodaTime.ZonedDateTime"/> which has a
            <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Utc"/> and represents the same instant of time as
            this value rather than the same local time.
            </summary>
            <remarks>
            <para>
            If the date and time is not on a tick boundary (the unit of granularity of DateTime) the value will be truncated
            towards the start of time.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The final date/time is outside the range of <c>DateTime</c>.</exception>
            <returns>A <see cref="T:System.DateTime"/> representation of this value with a "universal" kind, with the same
            instant of time as this value.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToDateTimeUnspecified">
            <summary>
            Constructs a <see cref="T:System.DateTime"/> from this <see cref="T:NodaTime.ZonedDateTime"/> which has a
            <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Unspecified"/> and represents the same local time as
            this value rather than the same instant in time.
            </summary>
            <remarks>
            <para>
            <see cref="F:System.DateTimeKind.Unspecified"/> is slightly odd - it can be treated as UTC if you use <see cref="M:System.DateTime.ToLocalTime"/>
            or as system local time if you use <see cref="M:System.DateTime.ToUniversalTime"/>, but it's the only kind which allows
            you to construct a <see cref="T:System.DateTimeOffset"/> with an arbitrary offset.
            </para>
            <para>
            If the date and time is not on a tick boundary (the unit of granularity of DateTime) the value will be truncated
            towards the start of time.
            </para>
            <para>
            <see cref="T:System.DateTime"/> uses the Gregorian calendar by definition, so the value is implicitly converted
            to the Gregorian calendar first. The result will be on the same physical date,
            but the values returned by the Year/Month/Day properties of the <see cref="T:System.DateTime"/> may not
            match the Year/Month/Day properties of this value.
            </para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">The date/time is outside the range of <c>DateTime</c>.</exception>
            <returns>A <see cref="T:System.DateTime"/> representation of this value with an "unspecified" kind, with the same
            local date and time as this value.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.ToOffsetDateTime">
            <summary>
            Constructs an <see cref="T:NodaTime.OffsetDateTime"/> with the same local date and time, and the same offset
            as this zoned date and time, effectively just "removing" the time zone itself.
            </summary>
            <returns>An OffsetDateTime with the same local date/time and offset as this value.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Deconstruct(NodaTime.LocalDateTime@,NodaTime.DateTimeZone@,NodaTime.Offset@)">
            <summary>
            Deconstruct this <see cref="T:NodaTime.ZonedDateTime"/> into its components.
            </summary>
            <param name="localDateTime">The <see cref="P:NodaTime.ZonedDateTime.LocalDateTime"/> component.</param>
            <param name="dateTimeZone">The <see cref="T:NodaTime.DateTimeZone"/> component.</param>
            <param name="offset">The <see cref="P:NodaTime.ZonedDateTime.Offset"/> component.</param>
        </member>
        <member name="T:NodaTime.ZonedDateTime.Comparer">
            <summary>
            Base class for <see cref="T:NodaTime.ZonedDateTime"/> comparers.
            </summary>
            <remarks>
            Use the static properties of this class to obtain instances. This type is exposed so that the
            same value can be used for both equality and ordering comparisons.
            </remarks>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Comparer.Local">
            <summary>
            Gets a comparer which compares <see cref="T:NodaTime.ZonedDateTime"/> values by their local date/time, without reference to
            the time zone or offset. Comparisons between two values of different calendar systems will fail with <see cref="T:System.ArgumentException"/>.
            </summary>
            <remarks>
            <para>For example, this comparer considers 2013-03-04T20:21:00 (Europe/London) to be later than
            2013-03-04T19:21:00 (America/Los_Angeles) even though the second value represents a later instant in time.</para>
            <para>This property will return a reference to the same instance every time it is called.</para>
            </remarks>
            <value>A comparer which compares values by their local date/time.</value>
        </member>
        <member name="P:NodaTime.ZonedDateTime.Comparer.Instant">
            <summary>
            Gets a comparer which compares <see cref="T:NodaTime.ZonedDateTime"/> values by the instants obtained by applying the offset to
            the local date/time, ignoring the calendar system.
            </summary>
            <remarks>
            <para>For example, this comparer considers 2013-03-04T20:21:00 (Europe/London) to be earlier than
            2013-03-04T19:21:00 (America/Los_Angeles) even though the second value has a local time which is earlier; the time zones
            mean that the first value occurred earlier in the universal time line.</para>
            <para>This property will return a reference to the same instance every time it is called.</para>
            </remarks>
            <value>A comparer which compares values by the instants obtained by applying the offset to
            the local date/time, ignoring the calendar system.</value>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Comparer.#ctor">
            <summary>
            Internal constructor to prevent external classes from deriving from this.
            (That means we can add more abstract members in the future.)
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Comparer.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Compares two <see cref="T:NodaTime.ZonedDateTime"/> values and returns a value indicating whether one is less than, equal to, or greater than the other.
            </summary>
            <param name="x">The first value to compare.</param>
            <param name="y">The second value to compare.</param>
            <returns>A signed integer that indicates the relative values of <paramref name="x"/> and <paramref name="y"/>, as shown in the following table.
              <list type = "table">
                <listheader>
                  <term>Value</term>
                  <description>Meaning</description>
                </listheader>
                <item>
                  <term>Less than zero</term>
                  <description><paramref name="x"/> is less than <paramref name="y"/>.</description>
                </item>
                <item>
                  <term>Zero</term>
                  <description><paramref name="x"/> is equals to <paramref name="y"/>.</description>
                </item>
                <item>
                  <term>Greater than zero</term>
                  <description><paramref name="x"/> is greater than <paramref name="y"/>.</description>
                </item>
              </list>
            </returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Comparer.Equals(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <summary>
            Determines whether the specified <c>ZonedDateTime</c> values are equal.
            </summary>
            <param name="x">The first <c>ZonedDateTime</c> to compare.</param>
            <param name="y">The second <c>ZonedDateTime</c> to compare.</param>
            <returns><c>true</c> if the specified objects are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.Comparer.GetHashCode(NodaTime.ZonedDateTime)">
            <summary>
            Returns a hash code for the specified <c>ZonedDateTime</c>.
            </summary>
            <param name="obj">The <c>ZonedDateTime</c> for which a hash code is to be returned.</param>
            <returns>A hash code for the specified value.</returns>
        </member>
        <member name="T:NodaTime.ZonedDateTime.LocalComparer">
            <summary>
            Implementation for <see cref="P:NodaTime.ZonedDateTime.Comparer.Local"/>.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.LocalComparer.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.ZonedDateTime.LocalComparer.Equals(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.ZonedDateTime.LocalComparer.GetHashCode(NodaTime.ZonedDateTime)">
            <inheritdoc />
        </member>
        <member name="T:NodaTime.ZonedDateTime.InstantComparer">
            <summary>
            Implementation for <see cref="P:NodaTime.ZonedDateTime.Comparer.Instant"/>.
            </summary>
        </member>
        <member name="M:NodaTime.ZonedDateTime.InstantComparer.Compare(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.ZonedDateTime.InstantComparer.Equals(NodaTime.ZonedDateTime,NodaTime.ZonedDateTime)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.ZonedDateTime.InstantComparer.GetHashCode(NodaTime.ZonedDateTime)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.ZonedDateTime.AddSchema(System.Xml.Schema.XmlSchemaSet)">
            <summary>
            Adds the XML schema type describing the structure of the <see cref="T:NodaTime.ZonedDateTime"/> XML serialization to the given <paramref name="xmlSchemaSet"/>.
            </summary>
            <param name="xmlSchemaSet">The XML schema set provided by <see cref="T:System.Xml.Serialization.XmlSchemaExporter"/>.</param>
            <returns>The qualified name of the schema type that was added to the <paramref name="xmlSchemaSet"/>.</returns>
        </member>
        <member name="M:NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <inheritdoc />
        </member>
        <member name="M:NodaTime.ZonedDateTime.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>
            </summary>
            <example><code>
            public void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the method doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null, and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>
            </summary>
            <example><code>
            [Pure] private int Multiply(int x, int y) { return x * y; }
            public void Foo() {
              const int a = 2, b = 2;
              Multiply(a, b); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
    </members>
</doc>
